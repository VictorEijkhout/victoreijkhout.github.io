<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src=https://ccrs.cac.cornell.edu:8443/client.0.2.js></script>
<script id="script">
class Example {
  constructor(buttonID, editorID, outputID, sourceFile, fileName, commandStr) {
    this.buttonID = buttonID;
    this.editorID = editorID;
    this.outputID = outputID;
    this.sourceFile = sourceFile;
    this.fileName = fileName;
    this.commandStr = commandStr;
  }
    
  async display(results, object) {
    if (results.stdout.length > 0)
      document.getElementById(object.outputID).textContent = results.stdout;
    else
      document.getElementById(object.outputID).textContent = results.stderr;
  }

  async initialize() {
    this.editor = await MonacoEditorFileSource.create(this.editorID);
    this.editor.setTextFromFile(this.sourceFile);
    this.job = await Job.create(JobType.MPI);
    this.command = new CommandWithFiles(this.job, this.commandStr);
    this.command.addFileSource(this.editor, this.fileName);
    this.trigger = new ButtonTrigger(this.command, this.display, this.buttonID, this);
    document.getElementById(this.buttonID).disabled = false;
  }
}
</script>
<style></style>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>PETSc tools</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


39.1 : <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a><br>
39.1.1 : <a href="petsc-tools.html#Debugmode">Debug mode</a><br>
39.1.2 : <a href="petsc-tools.html#Errorcodes">Error codes</a><br>
39.1.3 : <a href="petsc-tools.html#Memorycorruption">Memory corruption</a><br>
39.1.3.1 : <a href="petsc-tools.html#Valgrind">Valgrind</a><br>
39.2 : <a href="petsc-tools.html#Programoutput">Program output</a><br>
39.2.1 : <a href="petsc-tools.html#ScreenIO">Screen I/O</a><br>
39.2.1.1 : <a href="petsc-tools.html#printfreplacements">printf replacements</a><br>
39.2.1.2 : <a href="petsc-tools.html#scanfreplacement">scanf replacement</a><br>
39.2.2 : <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a><br>
39.2.2.1 : <a href="petsc-tools.html#Viewertypes">Viewer types</a><br>
39.2.2.2 : <a href="petsc-tools.html#Viewerformats">Viewer formats</a><br>
39.2.2.3 : <a href="petsc-tools.html#Commandlineoptionforviewers">Commandline option for viewers</a><br>
39.2.2.4 : <a href="petsc-tools.html#Namingobjects">Naming objects</a><br>
39.3 : <a href="petsc-tools.html#Commandlineoptions">Commandline options</a><br>
39.3.1 : <a href="petsc-tools.html#Addingyourownoptions">Adding your own options</a><br>
39.3.2 : <a href="petsc-tools.html#Optionsprefix">Options prefix</a><br>
39.3.3 : <a href="petsc-tools.html#Wheretospecifyoptions">Where to specify options</a><br>
39.4 : <a href="petsc-tools.html#Timingandprofiling">Timing and profiling</a><br>
39.4.1 : <a href="petsc-tools.html#Logging">Logging</a><br>
39.5 : <a href="petsc-tools.html#Memorymanagement">Memory management</a><br>
39.5.1 : <a href="petsc-tools.html#GPUallocation">GPU allocation</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>39 PETSc tools</h1>
<!-- TranslatingLineGenerator file ['file'] -->
</p>

<h2><a id="Errorcheckinganddebugging">39.1</a> Error checking and debugging</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a>
</p>
<p name="switchToTextMode">

<h3><a id="Debugmode">39.1.1</a> Debug mode</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a> > <a href="petsc-tools.html#Debugmode">Debug mode</a>
</p>

</p>

<p name="switchToTextMode">
During installation (see section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-design.html#PETScinstallation">32.3</a>
),
there is an option of turning on debug mode.
An installation with debug turned on:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Does more runtime checks on numerics, or array indices;
<li>
Does a memory analysis when you insert the 
<tt>CHKMEMQ</tt>
 macro
  (section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-tools.html#Memorycorruption">39.1.3</a>
);
<li>
Has the macro 
<tt>PETSC_USE_DEBUG</tt>
 set to~1.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Errorcodes">39.1.2</a> Error codes</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a> > <a href="petsc-tools.html#Errorcodes">Error codes</a>
</p>

</p>

<p name="switchToTextMode">
PETSc performs a good amount of runtime error checking. Some of this
is for internal consistency, but it can also detect certain
mathematical errors. To facilitate error reporting, the following
scheme is used.
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
Every PETSc routine is a function returning a parameter of type
<tt>PetscErrorCode</tt>
.
<li>
For a good traceback, surround the executable part of any subprogram
  with 
<tt>PetscFunctionBegin</tt>
 and 
<tt>PetscFunctionReturn</tt>
,
  where the latter has the return value as parameter.
<li>
Calling the macro 
<tt>CHKERRQ</tt>
 on the error code will
  cause an error to be printed and the current routine to be
  terminated. Recursively this gives a traceback of where the error
  occurred.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscErrorCode ierr;
ierr = AnyPetscRoutine( arguments ); CHKERRQ(ierr);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<li>
Other error checking macros are 
<tt>CHKERRABORT</tt>
  which aborts immediately, and 
<tt>CHKERRMPI</tt>
.
<li>
You can effect your own error return by using
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#SETERRQ" aria-expanded="false" aria-controls="SETERRQ">
        Routine reference: SETERRQ
      </button>
    </h5>
  </div>
  <div id="SETERRQ" class="collapse">
  <pre>
#include <petscsys.h>
PetscErrorCode SETERRQ (MPI_Comm comm,PetscErrorCode ierr,char *message)
PetscErrorCode SETERRQ1(MPI_Comm comm,PetscErrorCode ierr,char *formatmessage,arg1)
PetscErrorCode SETERRQ2(MPI_Comm comm,PetscErrorCode ierr,char *formatmessage,arg1,arg2)
PetscErrorCode SETERRQ3(MPI_Comm comm,PetscErrorCode ierr,char *formatmessage,arg1,arg2,arg3)

Input Parameters:
comm - A communicator, so that the error can be collective
ierr - nonzero error code, see the list of standard error codes in include/petscerror.h
message - error message in the printf format
arg1,arg2,arg3 - argument (for example an integer, string or double)

</pre>
</div>
</div>
<i>SETERRQ</i>
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

<!-- environment: fortrannote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=fortrannote ]] -->
<remark>
<b>Fortran note</b>
<p name="remark">
<!-- TranslatingLineGenerator fortrannote ['fortrannote'] -->
  In the main program, use 
<tt>CHKERRA</tt>
 and
<tt>SETERRA</tt>
. Also beware that these error `commands' are
  macros, and after expansion may interfere with
<i>Fortran line length</i>
, so they should only be
  used in 
<tt>.F90</tt>
 files.
</p name="remark">
</remark>
<!-- environment: fortrannote end embedded generator -->
<p name="switchToTextMode">
{Error code handling}
</p>

<p name="switchToTextMode">
Example. We write a routine that sets an error:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#petscbacktrace" aria-expanded="false" aria-controls="petscbacktrace">
        C Code: petscbacktrace
      </button>
    </h5>
  </div>
  <div id="petscbacktrace" class="collapse">
  <pre>
// backtrace.c
PetscErrorCode this_function_bombs() {
  PetscFunctionBegin;
  SETERRQ(PETSC_COMM_SELF,1,"We cannot go on like this");
  PetscFunctionReturn(0);
}
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
Running this gives, in process&nbsp;zero, the output
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
[0]PETSC ERROR: We cannot go on like this
[0]PETSC ERROR: See https://www.mcs.anl.gov/petsc/documentation/faq.html for trouble shooting.
[0]PETSC ERROR: Petsc Release Version 3.12.2, Nov, 22, 2019
[0]PETSC ERROR: backtrace on a [computer name]
[0]PETSC ERROR: Configure options [all options]
[0]PETSC ERROR: #1 this_function_bombs() line 20 in backtrace.c
[0]PETSC ERROR: #2 main() line 30 in backtrace.c
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: fortrannote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=fortrannote ]] -->
<remark>
<b>Fortran note</b>
<p name="remark">
<!-- TranslatingLineGenerator fortrannote ['fortrannote'] -->
  In Fortran the backtrace is not quite as elegant.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#petscbacktracef" aria-expanded="false" aria-controls="petscbacktracef">
        Fortran Code: petscbacktracef
      </button>
    </h5>
  </div>
  <div id="petscbacktracef" class="collapse">
  <pre>
!! backtrace.F90
  Subroutine this_function_bombs(ierr)
    implicit none
    integer,intent(out) :: ierr

    SETERRQ(PETSC_COMM_SELF,1,"We cannot go on like this")
    ierr = -1

  end Subroutine this_function_bombs
</pre>
</div>
</div>
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
[0]PETSC ERROR: ----- Error Message ------------------------------
[0]PETSC ERROR: We cannot go on like this
[....]
[0]PETSC ERROR: #1 User provided function() line 0 in User file
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</remark>
<!-- environment: fortrannote end embedded generator -->
<p name="switchToTextMode">
{Backtrace on error}
</p>

<!-- environment: remark start embedded generator -->
<!-- environment block purpose: [[ environment=remark ]] -->
<remark>
<b>Remark</b>
<p name="remark">
<!-- TranslatingLineGenerator remark ['remark'] -->
  In this example, the use of 
<tt>PETSC_COMM_SELF</tt>
 indicates
  that this error is individually generated on a process;
  use 
<tt>PETSC_COMM_WORLD</tt>
 only if the same error would
  be detected everywhere.
</p name="remark">
</remark>
<!-- environment: remark end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Look up the definition of 
<tt>SETERRQ1</tt>
.
  Write a routine to compute square roots that is used as follows:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
  x = 1.5; ierr = square_root(x,&rootx); CHKERRQ(ierr);
  PetscPrintf(PETSC_COMM_WORLD,"Root of %f is %f\n",x,rootx);
  x = -2.6; ierr = square_root(x,&rootx); CHKERRQ(ierr);
  PetscPrintf(PETSC_COMM_WORLD,"Root of %f is %f\n",x,rootx);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
This should give as output:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
Root of 1.500000 is 1.224745
[0]PETSC ERROR: ----- Error Message ----------------------------------------------
[0]PETSC ERROR: Cannot compute the root of -2.600000
[...]
[0]PETSC ERROR: #1 square_root() line 23 in root.c
[0]PETSC ERROR: #2 main() line 39 in root.c
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Memorycorruption">39.1.3</a> Memory corruption</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a> > <a href="petsc-tools.html#Memorycorruption">Memory corruption</a>
</p>

</p>

<p name="switchToTextMode">
PETSc has its own memory management (section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-tools.html#Memorymanagement">39.5</a>
)
and this facilitates finding memory corruption errors.
The macro 
<tt>CHKMEMQ</tt>
 (
<tt>CHKMEMA</tt>
 in void functions)
checks all memory that was allocated by PETSc,
either internally or throug the allocation routines,
for corruption. Sprinkling this macro through your code
can detect memory problems before they lead to a 
<i>segfault</i>
.
</p>

<p name="switchToTextMode">
This testing is only done if the commandline argument
<tt>-malloc_debug</tt>
 (
<tt>-malloc_test</tt>
 in debug mode)
is supplied, so it carries no overhead for production runs.
</p>

<h4><a id="Valgrind">39.1.3.1</a> Valgrind</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Errorcheckinganddebugging">Error checking and debugging</a> > <a href="petsc-tools.html#Memorycorruption">Memory corruption</a> > <a href="petsc-tools.html#Valgrind">Valgrind</a>
</p>
<p name="switchToTextMode">

Valgrind is rather verbose in its output.
To limit the number of processs that run under valgrind:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
mpiexec -n 3 valgrind --track-origins=yes ./app -args : -n 5 ./app -args
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Programoutput">39.2</a> Program output</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a>
</p>
</p>

<p name="switchToTextMode">
PETSc has as variety of mechanisms to export or visualize program data.
We will consider a few possibilities here.
</p>

<h3><a id="ScreenIO">39.2.1</a> Screen I/O</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#ScreenIO">Screen I/O</a>
</p>
<p name="switchToTextMode">

Printing screen output in parallel is tricky. If two processes execute
a print statement at more or less the same time there is no guarantee
as to in what order they may appear on screen. (Even attempts to have
them print one after the other may not result in the right ordering.)
Furthermore, lines from multi-line print actions on two processes may
wind up on the screen interleaved.
</p>

<h4><a id="printfreplacements">39.2.1.1</a> printf replacements</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#ScreenIO">Screen I/O</a> > <a href="petsc-tools.html#printfreplacements">printf replacements</a>
</p>
<p name="switchToTextMode">

PETSc has two routines that fix this problem. First of all, often the
information printed is the same on all processes, so it is enough if
only one process, for instance process&nbsp;0, prints it. This is done with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscPrintf" aria-expanded="false" aria-controls="PetscPrintf">
        Routine reference: PetscPrintf
      </button>
    </h5>
  </div>
  <div id="PetscPrintf" class="collapse">
  <pre>
C:
PetscErrorCode  PetscPrintf(MPI_Comm comm,const char format[],...)

Fortran:
PetscPrintf(MPI_Comm, character(*), PetscErrorCode ierr)

Python:
PETSc.Sys.Print(type cls, *args, **kwargs)
kwargs:
comm : communicator object
</pre>
</div>
</div>
<i>PetscPrintf</i>
.
</p>

<p name="switchToTextMode">
If all processes need to print, you can use
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscSynchronizedPrintf" aria-expanded="false" aria-controls="PetscSynchronizedPrintf">
        Routine reference: PetscSynchronizedPrintf
      </button>
    </h5>
  </div>
  <div id="PetscSynchronizedPrintf" class="collapse">
  <pre>
C:
PetscErrorCode  PetscSynchronizedPrintf(
    MPI_Comm comm,const char format[],...)

Fortran:
PetscSynchronizedPrintf(MPI_Comm, character(*), PetscErrorCode ierr)

python:
PETSc.Sys.syncPrint(type cls, *args, **kargs)
kwargs:
comm : communicator object
flush : if True, do synchronizedFlush
other keyword args as for python3 print function
</pre>
</div>
</div>
<i>PetscSynchronizedPrintf</i>
 that forces the
output to appear in process order.
</p>

<p name="switchToTextMode">
To make sure that output is properly flushed from all system buffers
use 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscSynchronizedFlush" aria-expanded="false" aria-controls="PetscSynchronizedFlush">
        Routine reference: PetscSynchronizedFlush
      </button>
    </h5>
  </div>
  <div id="PetscSynchronizedFlush" class="collapse">
  <pre>
C:
PetscErrorCode  PetscSynchronizedFlush(MPI_Comm comm,FILE *fd)
fd : output file pointer, needs to be valid on process zero

Fortran:
PetscSynchronizedFlush(comm,fd,err)
Integer :: comm
fd is usually PETSC_STDOUT
PetscErrorCode :: err

python:
PETSc.Sys.syncFlush(type cls, comm=None)
</pre>
</div>
</div>
<i>PetscSynchronizedFlush</i>
where for ordinary screen output you would use 
<tt>stdout</tt>
 for the file.
</p>

<!-- environment: fortrannote start embedded generator -->
<!-- environment block purpose: [[ environment=fortrannote ]] -->
<remark>
<b>Fortran note</b>
<p name="remark">
<!-- TranslatingLineGenerator fortrannote ['fortrannote'] -->
  The Fortran calls are only wrappers around C&nbsp;routines, so you can
  use 
 <tt>\n</tt>  newline characters in the Fortran string argument
  to 
<tt>PetscPrintf</tt>
.
</p>

<p name="switchToTextMode">
  The file to flush is typically 
<tt>PETSC_STDOUT</tt>
.
</p name="remark">
</remark>
<!-- environment: fortrannote end embedded generator -->
<p name="switchToTextMode">
{Printing and newlines}
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  Since the print routines use the python 
<tt>print</tt>
 call, they
  automatically include the trailing newline. You don't have to
  specify it as in the C&nbsp;calls.
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<h4><a id="scanfreplacement">39.2.1.2</a> scanf replacement</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#ScreenIO">Screen I/O</a> > <a href="petsc-tools.html#scanfreplacement">scanf replacement</a>
</p>
</p>

<p name="switchToTextMode">
Using 
<tt>scanf</tt>
 in Petsc is tricky, since integers and real numbers can be
of different sizes, depending on the installation.
Instead, use 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscViewerRead" aria-expanded="false" aria-controls="PetscViewerRead">
        Routine reference: PetscViewerRead
      </button>
    </h5>
  </div>
  <div id="PetscViewerRead" class="collapse">
  <pre>
Synopsis

#include "petscviewer.h"
PetscErrorCode  PetscViewerRead(PetscViewer viewer, void *data, PetscInt num, PetscInt *count, PetscDataType dtype)

Collective

Input Parameters
	viewer 	- The viewer
	data 	- Location to write the data
	num 	- Number of items of data to read
	datatype 	- Type of data to read

Output Parameters
count -number of items of data actually read, or NULL
</pre>
</div>
</div>
<i>PetscViewerRead</i>
, which operates in terms of
<tt>PetscDataType</tt>
.
</p>

<h3><a id="Exportinginternaldatastructures">39.2.2</a> Exporting internal data structures</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a>
</p>

<p name="switchToTextMode">

In order to export PETSc matrix or vector data structures
there is a 
<tt>PetscViewer</tt>
 object type.
This is a quite general concept of viewing: it encompasses ascii output to screen,
binary dump to file, or communication to a running Matlab process.
Calls such as  
<tt>MatView</tt>
 or 
<tt>KSPView</tt>
accept a 
<tt>PetscViewer</tt>
 argument.
</p>

<p name="switchToTextMode">
In cases where this makes sense, there is also an inverse `load' operation.
See section 
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#FileIO">33.3.5</a>
 for vectors.
</p>

<p name="switchToTextMode">
Some viewers are predefined, such as
<tt>PETSC_VIEWER_STDOUT_WORLD</tt>
 for ascii rendering to
standard out. (In&nbsp;C, specifying zero or 
<tt>NULL</tt>
 also uses this
default viewer; for Fortran use 
</p>

<h4><a id="Viewertypes">39.2.2.1</a> Viewer types</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a> > <a href="petsc-tools.html#Viewertypes">Viewer types</a>
</p>
<p name="switchToTextMode">

For activities such as dumping to file
you first need create the viewer
with 
<tt>PetscViewerCreate</tt>
and set its type with 
<tt>PetscViewerSetType</tt>
.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscViewerCreate(comm,&viewer);
PetscViewerSetType(viewer,PETSCVIEWERBINARY);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Popular types include
<tt>PETSCVIEWERASCII</tt>
,
<tt>PETSCVIEWERBINARY</tt>
,
<tt>PETSCVIEWERSTRING</tt>
,
<tt>PETSCVIEWERDRAW</tt>
,
<tt>PETSCVIEWERSOCKET</tt>
,
<tt>PETSCVIEWERHDF5</tt>
,
<tt>PETSCVIEWERVTK</tt>
;
the full list can be found in 
<tt>include/petscviewer.h</tt>
.
</p>

<h4><a id="Viewerformats">39.2.2.2</a> Viewer formats</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a> > <a href="petsc-tools.html#Viewerformats">Viewer formats</a>
</p>
<p name="switchToTextMode">

Viewers can take further format specifications by using
<tt>PetscViewerPushFormat</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscViewerPushFormat
   (PETSC_VIEWER_STDOUT_WORLD,
    PETSC_VIEWER_ASCII_INFO_DETAIL);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
and afterwards a corresponding 
<tt>PetscViewerPopFormat</tt>
</p>

<h4><a id="Commandlineoptionforviewers">39.2.2.3</a> Commandline option for viewers</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a> > <a href="petsc-tools.html#Commandlineoptionforviewers">Commandline option for viewers</a>
</p>
<p name="switchToTextMode">

Petsc objects viewers can be activated by calls such as 
<tt>MatView</tt>
,
but often it is more convenient to do this through commandline options,
such as 
<tt>mat_view</tt>
, 
<tt>vec_view</tt>
,
or 
<tt>ksp_view</tt>
.
By default, these output to 
<tt>stdout</tt>
 in 
<tt>ascii</tt>
 form,
but this can be controlled by further option values:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
program -mat_view binary:matrix.dat
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
where 
<tt>binary</tt>
 forces a binary dump (
<tt>ascii</tt>
 is the default)
and a file name is explicitly given.
</p>

<p name="switchToTextMode">
If a viewer needs to be triggered at a specific location,
calls such as 
<tt>VecViewFromOptions</tt>
 can be used.
<tt>VecSetOptionsPrefix</tt>
.
These routines all have a similar calling sequence:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
#include "petscsys.h"
PetscErrorCode  PetscObjectViewFromOptions(PetscObject obj,PetscObject bobj,const char optionname[])
PetscErrorCode  VecViewFromOptions(Vec A,PetscObject obj,const char name[])
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

\begin{raggedlist}
<tt>AOViewFromOptions</tt>
,
<tt>DMViewFromOptions</tt>
,
<tt>ISViewFromOptions</tt>
,
<tt>ISLocalToGlobalMappingViewFromOptions</tt>
,
<tt>KSPConvergedReasonViewFromOptions</tt>
,
<tt>KSPViewFromOptions</tt>
,
<tt>MatPartitioningViewFromOptions</tt>
,
<tt>MatCoarsenViewFromOptions</tt>
,
<tt>MatViewFromOptions</tt>
,
<tt>PetscObjectViewFromOptions</tt>
,
<tt>PetscPartitionerViewFromOptions</tt>
,
<tt>PetscDrawViewFromOptions</tt>
,
<tt>PetscRandomViewFromOptions</tt>
,
<tt>PetscDualSpaceViewFromOptions</tt>
,
<tt>PetscSFViewFromOptions</tt>
,
<tt>PetscFEViewFromOptions</tt>
,
<tt>PetscFVViewFromOptions</tt>
,
<tt>PetscSectionViewFromOptions</tt>
,
<tt>PCViewFromOptions</tt>
,
<tt>PetscSpaceViewFromOptions</tt>
,
<tt>PFViewFromOptions</tt>
,
<tt>PetscLimiterViewFromOptions</tt>
,
<tt>PetscLogViewFromOptions</tt>
,
<tt>PetscDSViewFromOptions</tt>
,
<tt>PetscViewerViewFromOptions</tt>
,
<tt>SNESConvergedReasonViewFromOptions</tt>
,
<tt>SNESViewFromOptions</tt>
,
<tt>TSTrajectoryViewFromOptions</tt>
,
<tt>TSViewFromOptions</tt>
,
<tt>TaoLineSearchViewFromOptions</tt>
,
<tt>TaoViewFromOptions</tt>
,
<tt>VecViewFromOptions</tt>
,
<tt>VecScatterViewFromOptions</tt>
,
\end{raggedlist}
</p>

<h4><a id="Namingobjects">39.2.2.4</a> Naming objects</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Programoutput">Program output</a> > <a href="petsc-tools.html#Exportinginternaldatastructures">Exporting internal data structures</a> > <a href="petsc-tools.html#Namingobjects">Naming objects</a>
</p>
<p name="switchToTextMode">

A helpful facility for viewing is to name an object:
that name will then be displayed when the object is viewed.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Vec i_local;
ierr = VecCreate(comm,&i_local); CHKERRQ(ierr);
ierr = PetscObjectSetName((PetscObject)i_local,"space local"); CHKERRQ(ierr);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
giving:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
Vec Object: space local 4 MPI processes
  type: mpi
Process [0]
[ ... et cetera ... ]
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Commandlineoptions">39.3</a> Commandline options</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Commandlineoptions">Commandline options</a>
</p>

</p>

<p name="switchToTextMode">
PETSc has as large number of commandline options, most of which we
will discuss later. For now we only mention 
<tt>-log_summary</tt>
 which
will print out profile of the time taken in various routines.
For these options to be parsed, it is necessary to pass 
<tt>argc,argv</tt>

to the 
<tt>PetscInitialize</tt>
 call.
</p>

<h3><a id="Addingyourownoptions">39.3.1</a> Adding your own options</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Commandlineoptions">Commandline options</a> > <a href="petsc-tools.html#Addingyourownoptions">Adding your own options</a>
</p>
<p name="switchToTextMode">

You can add custom
commandline options to your program.
Various routines such as 
<tt>PetscOptionsGetInt</tt>
scan the commandline for options and set parameters accordingly.
For instance,
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#optionint" aria-expanded="false" aria-controls="optionint">
        C Code: optionint
      </button>
    </h5>
  </div>
  <div id="optionint" class="collapse">
  <pre>
// ksp.c
PetscBool flag;
int domain_size = 100;
ierr = PetscOptionsGetInt
  (NULL,PETSC_NULL,"-n",&domain_size,&flag); CHKERRQ(ierr);
PetscPrintf(comm,"Using domain size %d\n",domain_size);
</pre>
</div>
</div>
declares the existence of an option 
<tt>-n</tt>
 to be followed by an integer.
</p>

<p name="switchToTextMode">
Now executing
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
mpiexec yourprogram -n 5
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
will
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
set the 
<tt>flag</tt>
 to true, and
<li>
set the parameter 
<tt>domain_size</tt>
 to the value on the commandline.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">
Omitting the 
<tt>-n</tt>
 option will leave the default value of 
<tt>domain_size</tt>

unaltered.
</p>

<p name="switchToTextMode">
For flags, use 
<tt>PetscOptionsHasName</tt>
.
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  In Python, do not specify the initial hyphen of an option name.
  Also, the functions such as 
<tt>getInt</tt>
 do not return the boolean flag;
  if you need to test for the existence of the commandline option, use:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
hasn = PETSc.Options().hasName("n")
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

There is a related mechanism using
<tt>PetscOptionsBegin</tt>
&nbsp;/ 
<tt>PetscOptionsEnd</tt>
:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#petscoptionsblock" aria-expanded="false" aria-controls="petscoptionsblock">
        C Code: petscoptionsblock
      </button>
    </h5>
  </div>
  <div id="petscoptionsblock" class="collapse">
  <pre>
// optionsbegin.c
ierr = PetscOptionsBegin(comm,NULL,"Parameters",NULL); CHKERRQ(ierr);
ierr = PetscOptionsInt("-i","i value",__FILE__,i_value,&i_value,&i_flag); CHKERRQ(ierr);
ierr = PetscOptionsInt("-j","j value",__FILE__,j_value,&j_value,&j_flag); CHKERRQ(ierr);
ierr = PetscOptionsEnd(); CHKERRQ(ierr);
if (i_flag)
  PetscPrintf(comm,"Option `-i' was used\n");
if (j_flag)
  PetscPrintf(comm,"Option `-j' was used\n");
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
The selling point for this approach is that running your code with
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
mpiexec yourprogram -help
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
will display these options as a block.
Together with a ton of other options, unfortunately.
</p>

<h3><a id="Optionsprefix">39.3.2</a> Options prefix</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Commandlineoptions">Commandline options</a> > <a href="petsc-tools.html#Optionsprefix">Options prefix</a>
</p>
<p name="switchToTextMode">

In many cases, your code will have only one 
<tt>KSP</tt>
 solver object,
so specifying 
<tt>ksp_view</tt>
 or 
<tt>ksp_monitor</tt>
will display&nbsp;/ trace that one.
However, you may have multiple solvers, or nested solvers. You may then
not want to display all of them.
</p>

<p name="switchToTextMode">
As an example of the nest solver case, consider the case of a
<i>block jacobi preconditioner</i>
, where the block is itself solved
with an iterative method. You can trace that one with
<tt>-sub_ksp_monitor</tt>
.
</p>

<p name="switchToTextMode">
The 
<tt>sub_</tt>
 is an 
<i>option prefix</i>
, and you can defined
your own with
<tt>KSPSetOptionsPrefix</tt>
.
(There are similar routines for other PETSc object types.)
</p>

<p name="switchToTextMode">
Example:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
KSPCreate(comm,&time_solver);
KSPCreate(comm,&space_solver);
KSPSetOptionsPrefix(time_solver,"time_");
KSPSetOptionsPrefix(space_solver,"space_");
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
You can then use options 
<tt>-time_ksp_monitor</tt>
 and such.
Note that the prefix does not have a leading dash,
but it does have the trailing underscore.
</p>

<p name="switchToTextMode">
\begin{raggedlist}
Similar routines:
<tt>MatSetOptionsPrefix</tt>
,
<tt>PCSetOptionsPrefix</tt>
,
<tt>PetscObjectSetOptionsPrefix</tt>
,
<tt>PetscViewerSetOptionsPrefix</tt>
,
<tt>SNESSetOptionsPrefix</tt>
,
<tt>TSSetOptionsPrefix</tt>
,
<tt>VecSetOptionsPrefix</tt>
,
and some more obscure ones.
\end{raggedlist}
</p>

<p name="switchToTextMode">

<h3><a id="Wheretospecifyoptions">39.3.3</a> Where to specify options</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Commandlineoptions">Commandline options</a> > <a href="petsc-tools.html#Wheretospecifyoptions">Where to specify options</a>
</p>

</p>

<p name="switchToTextMode">
Commandline options can obviously go on the commandline. However, there are more
places where they can be specified.
</p>

<p name="switchToTextMode">
Options can be specified programmatically with
<tt>PetscOptionsSetValue</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscOptionsSetValue( NULL, // for global options
  "-some_option","value_as_string");
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Options can be specified in a file 
<tt>.petscrc</tt>
 in the user's home directory
or the current directory.
</p>

<p name="switchToTextMode">
Finally, an environment variable 
<tt>PETSC_OPTIONS</tt>
 can be set.
</p>

<p name="switchToTextMode">
The 
<tt>rc</tt>
 file is processed first, then the environment variable,
then any commandline arguments. This parsing is done in 
<tt>PetscInitialize</tt>
,
so any values from 
<tt>PetscOptionsSetValue</tt>
 override this.
</p>

<h2><a id="Timingandprofiling">39.4</a> Timing and profiling</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Timingandprofiling">Timing and profiling</a>
</p>

<p name="switchToTextMode">

PETSc has a number of timing routines that make it unnecessary to
use system routines such as 
<tt>getrusage</tt>
or MPI routines such as 
<tt>MPI_Wtime</tt>
.
The main (wall clock) timer is 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscTime" aria-expanded="false" aria-controls="PetscTime">
        Routine reference: PetscTime
      </button>
    </h5>
  </div>
  <div id="PetscTime" class="collapse">
  <pre>
Synopsis
Returns the CPU time in seconds used by the process.

#include "petscsys.h"
#include "petsctime.h"
PetscErrorCode PetscGetCPUTime(PetscLogDouble *t)
PetscErrorCode PetscTime(PetscLogDouble *v)
</pre>
</div>
</div>
<i>PetscTime</i>
.
Note the return type of 
<tt>PetscLogDouble</tt>
 which
can have a different precision from 
<tt>PetscReal</tt>
.
</p>

<p name="switchToTextMode">
The routine 
<tt>PetscGetCPUTime</tt>
 is less useful, since it measures only
time spent in computation, and ignores things such as communication.
</p>

<h3><a id="Logging">39.4.1</a> Logging</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Timingandprofiling">Timing and profiling</a> > <a href="petsc-tools.html#Logging">Logging</a>
</p>
<p name="switchToTextMode">

Petsc does a lot of logging on its own operations.
Additionally, you can introduce your own routines into this log.
</p>

<p name="switchToTextMode">
The simplest way to display statistics is to run
with an option 
<tt>log_view</tt>
.
This takes an optional file name argument:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
mpiexec -n 10 yourprogram -log_view :statistics.txt
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
The corresponding routine is 
<tt>PetscLogView</tt>
.
</p>

<h2><a id="Memorymanagement">39.5</a> Memory management</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Memorymanagement">Memory management</a>
</p>

<p name="switchToTextMode">

Allocate the memory for a given pointer: 
<tt>PetscNew</tt>
,
allocate arbitrary memory with 
<tt>PetscMalloc</tt>
,
allocate a number of objects with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscMalloc1" aria-expanded="false" aria-controls="PetscMalloc1">
        Routine reference: PetscMalloc1
      </button>
    </h5>
  </div>
  <div id="PetscMalloc1" class="collapse">
  <pre>
Synopsis
Allocates an array of memory aligned to PETSC_MEMALIGN

C:
#include <petscsys.h>
PetscErrorCode PetscMalloc1(size_t m1,type **r1)

Input Parameter:
m1 - number of elements to allocate (may be zero)

Output Parameter:
r1 - memory allocated
</pre>
</div>
</div>
<i>PetscMalloc1</i>
(this does not zero the memory allocated,
 use 
<tt>PetscCalloc1</tt>
 to obtain memory that has been zeroed);
use 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscFree" aria-expanded="false" aria-controls="PetscFree">
        Routine reference: PetscFree
      </button>
    </h5>
  </div>
  <div id="PetscFree" class="collapse">
  <pre>
Synopsis
Frees memory, not collective

C:
#include <petscsys.h>
PetscErrorCode PetscFree(void *memory)

Input Parameter:
memory - memory to free (the pointer is ALWAYS set to NULL upon sucess)
</pre>
</div>
</div>
<i>PetscFree</i>
 to free.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscInt *idxs;
PetscMalloc1(10,&idxs);
// better than:
// PetscMalloc(10*sizeof(PetscInt),&idxs);
for (PetscInt i=0; i&lt;10; i++)
  idxs[i] = f(i);
PetscFree(idxs);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Allocated memory is aligned to 
<tt>PETSC_MEMALIGN</tt>
.
</p>

<p name="switchToTextMode">
The state of memory allocation can be written to file or standard out
with 
<tt>PetscMallocDump</tt>
. The commandline option
<tt>-malloc_dump</tt>
 outputs all not-freed memory during
<tt>PetscFinalize</tt>
.
</p>

<h3><a id="GPUallocation">39.5.1</a> GPU allocation</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-tools.html">petsc-tools</a> > <a href="petsc-tools.html#Memorymanagement">Memory management</a> > <a href="petsc-tools.html#GPUallocation">GPU allocation</a>
</p>
<p name="switchToTextMode">

The memories of a CPU and GPU are not coherent.
This means that routines such as 
<tt>PetscMalloc1</tt>
can not immediately be used for GPU allocation.
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-gpu.html#Other">38.4</a>
 for details.
</div>
<a href="index.html">Back to Table of Contents</a>
