<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src=https://ccrs.cac.cornell.edu:8443/client.0.1.js></script>
<style>
</style>

<script type="application/javascript">
let fileRoot      = "hello";
let fileName      = fileRoot + ".c";
let compileCmd    = "mpicc " + fileName + " -o " + fileRoot;
let runCmd        = "mpirun --oversubscribe -np 8 " + fileRoot;
let compileRunCmd = [compileCmd, runCmd].join(" && ");

async function afterExecute(results) {
  document.getElementById('stdoutPre').textContent = results.stdout;
  document.getElementById('stderrPre').textContent = results.stderr;
}

async function initialize() {
  let editor = await MonacoEditorFileSource.create("editorDiv");
  editor.setTextFromFile("mpiHello.c");

  let job = await Job.create(JobType.MPI);
  let command = new CommandWithFiles(job, compileRunCmd);
  command.addFileSource(editor, fileName);
  let trigger = new ButtonTrigger(command, afterExecute, "executeBtn");

  document.getElementById("executeBtn").disabled = false;
}

initialize();
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>MPI topic: Communication modes</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


5.1 : <a href="mpi-persist.html#Persistentcommunicationrequests">Persistent communication requests</a><br>
5.1.1 : <a href="mpi-persist.html#Persistentpoint-to-pointcommunication">Persistent point-to-point communication</a><br>
5.1.2 : <a href="mpi-persist.html#Persistentcollectives">Persistent collectives</a><br>
5.1.3 : <a href="mpi-persist.html#Persistentneighborcommunications">Persistent neighbor communications</a><br>
5.2 : <a href="mpi-persist.html#Partitionedcommunication">Partitioned communication</a><br>
5.3 : <a href="mpi-persist.html#Synchronousandasynchronouscommunication">Synchronous and asynchronous communication</a><br>
5.3.1 : <a href="mpi-persist.html#Synchronoussendoperations">Synchronous send operations</a><br>
5.4 : <a href="mpi-persist.html#Localandnonlocaloperations">Local and nonlocal operations</a><br>
5.5 : <a href="mpi-persist.html#Bufferedcommunication">Buffered communication</a><br>
5.5.1 : <a href="mpi-persist.html#Buffertreatment">Buffer treatment</a><br>
5.5.2 : <a href="mpi-persist.html#Bufferendsendcalls">Bufferend send calls</a><br>
5.5.3 : <a href="mpi-persist.html#Persistentbufferedcommunication">Persistent buffered communication</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>5 MPI topic: Communication modes</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Persistentcommunicationrequests">5.1</a> Persistent communication requests</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Persistentcommunicationrequests">Persistent communication requests</a>
</p>
<!-- index -->

</p>

<p name="switchToTextMode">
Persistent communication is a mechanism for dealing
with a repeating communication transaction,
where the parameters of the transaction,
such as sender, receiver, tag, root, and buffer type and size,
stay the same.
Only the contents of the buffers involved changes between the transactions.
</p>

<p name="switchToTextMode">
You can imagine that setting up a communication
carries some overhead, and if the same communication structure
is repeated many times, this overhead may be avoided.
</p>

<!-- environment: enumerate start embedded generator -->
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
  For nonblocking communications 
<tt>MPI_Ixxx</tt>

  (both point-to-point and collective)
  there is a persistent variant 
<tt>MPI_Xxx_init</tt>

  with the same calling sequence.
  The `init' call produces
  an 
<tt>MPI_Request</tt>
 output parameter,
  which can be used to test for completion of the communication.
<li>
  The `init' routine does not start the actual communication:
  that is done in
<tt>MPI_Start</tt>
,
  or 
<tt>MPI_Startall</tt>
 for multiple requests.
<li>
Any of the MPI `wait' calls can then be used
  to conclude the communication.
<li>
The communication can then be restarted with another `start' call.
<li>
The wait call does not release the request object,
  since it can be used for repeat occurrences of this transaction.
  The request object is only freed with 
<tt>MPI_Request_free</tt>
.
  See section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Moreaboutrequests">4.2.4</a>
 for the non-persistent handling of requests.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Send_init( /* ... */ &request);
while ( /* ... */ ) {
  MPI_Start( request );
  MPI_Wait( request, &status );
}
MPI_Request_free( & request );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  MPL returns a 
<tt>prequest</tt>
  from persistent `init' routines, rather than an 
<tt>irequest</tt>
  (MPL note&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Requestcompletion:waitcalls">4.2.2</a>
):
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
template&lt;typename T &gt;
prequest send_init (const T &data, int dest, tag t=tag(0)) const;
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Likewise, there is a 
<tt>prequest_pool</tt>
instead of an 
<tt>irequest_pool</tt>
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Waitforanyrequests">4.2.2.3</a>
).
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Persistentpoint-to-pointcommunication">5.1.1</a> Persistent point-to-point communication</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Persistentcommunicationrequests">Persistent communication requests</a> > <a href="mpi-persist.html#Persistentpoint-to-pointcommunication">Persistent point-to-point communication</a>
</p>

<!-- index -->
</p>

<p name="switchToTextMode">
The main persistent point-to-point routines are
<tt>MPI_Send_init</tt>
, which has the same calling sequence as
<tt>MPI_Isend</tt>
, and 
<tt>MPI_Recv_init</tt>
, which has the same
calling sequence as 
<tt>MPI_Irecv</tt>
.
</p>

<p name="switchToTextMode">
In the following example a ping-pong is implemented with persistent communication.
Since we use persistent operations for both send and receive on the `ping' process,
we use 
<tt>MPI_Startall</tt>
 to start both at the same time,
and 
<tt>MPI_Waitall</tt>
 to test their completion.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#persist" aria-expanded="false" aria-controls="persist">
        C Code: persist
      </button>
    </h5>
  </div>
  <div id="persist" class="collapse">
  <pre>
// persist.c
if (procno==src) {
  MPI_Send_init(send,s,MPI_DOUBLE,tgt,0,comm,requests+0);
  MPI_Recv_init(recv,s,MPI_DOUBLE,tgt,0,comm,requests+1);
  printf("Size %d\n",s);
  for (int n=0; n&lt;NEXPERIMENTS; n++) {
	fill_buffer(send,s,n);
	MPI_Startall(2,requests);
	MPI_Waitall(2,requests,MPI_STATUSES_IGNORE);
	int r = chck_buffer(send,s,n);
	if (!r) printf("buffer problem %d\n",s);
  }
  MPI_Request_free(requests+0); MPI_Request_free(requests+1);
} else if (procno==tgt) {
  for (int n=0; n&lt;NEXPERIMENTS; n++) {
	MPI_Recv(recv,s,MPI_DOUBLE,src,0,comm,MPI_STATUS_IGNORE);
	MPI_Send(recv,s,MPI_DOUBLE,src,0,comm);
  }
}
</pre>
</div>
</div>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#persistp" aria-expanded="false" aria-controls="persistp">
        Python Code: persistp
      </button>
    </h5>
  </div>
  <div id="persistp" class="collapse">
  <pre>
## persist.py
sendbuf = np.ones(size,dtype=np.int)
recvbuf = np.ones(size,dtype=np.int)
if procid==src:
    print("Size:",size)
    times[isize] = MPI.Wtime()
    for n in range(nexperiments):
        requests[0] = comm.Isend(sendbuf[0:size],dest=tgt)
        requests[1] = comm.Irecv(recvbuf[0:size],source=tgt)
        MPI.Request.Waitall(requests)
        sendbuf[0] = sendbuf[0]+1
    times[isize] = MPI.Wtime()-times[isize]
elif procid==tgt:
    for n in range(nexperiments):
        comm.Recv(recvbuf[0:size],source=src)
        comm.Send(recvbuf[0:size],dest=src)
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
As with ordinary send commands, there are persistent variants
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>MPI_Bsend_init</tt>
 for buffered communication,
  section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Bufferedcommunication">5.5</a>
;
<li>
<tt>MPI_Ssend_init</tt>
 for synchronous communication,
  section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Synchronoussendoperations">5.3.1</a>
;
<li>
<tt>MPI_Rsend_init</tt>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
</p>

<h3><a id="Persistentcollectives">5.1.2</a> Persistent collectives</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Persistentcommunicationrequests">Persistent communication requests</a> > <a href="mpi-persist.html#Persistentcollectives">Persistent collectives</a>
</p>
<p name="switchToTextMode">

<!-- environment: mpifour start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mpifour ]] -->
<remark>
<b>MPI 4 Standard only</b>
<p name="remark">
<!-- TranslatingLineGenerator mpifour ['mpifour'] -->
<!-- index -->
For each collective call, there is a persistent variant.
As with persistent point-to-point calls (section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Persistentpoint-to-pointcommunication">5.1.1</a>
),
these have largely the same calling sequence as the nonpersistent variants,
except for:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
an 
<tt>MPI_Info</tt>
 parameter that can be used to pass
  system-dependent hints; and
<li>
  an added final 
<tt>MPI_Request</tt>
 parameter.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
(See for instance&nbsp;
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Allreduce_init" aria-expanded="false" aria-controls="MPI_Allreduce_init">
        Routine reference: MPI_Allreduce_init
      </button>
    </h5>
  </div>
  <div id="MPI_Allreduce_init" class="collapse">
  <pre>
</pre>
</div>
</div>
<i>MPI_Allreduce_init</i>
.)
This request (or an array of requests) can then be used by
<tt>MPI_Start</tt>
 (or 
<tt>MPI_Startall</tt>
)
to initiate the actual communication.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#powerreducepersist" aria-expanded="false" aria-controls="powerreducepersist">
        C Code: powerreducepersist
      </button>
    </h5>
  </div>
  <div id="powerreducepersist" class="collapse">
  <pre>
// powerpersist.c
double localnorm,globalnorm=1.;
MPI_Request reduce_request;
MPI_Allreduce_init
  ( &localnorm,&globalnorm,1,MPI_DOUBLE,MPI_SUM,
    comm,MPI_INFO_NULL,&reduce_request);
for (int it=0; it&lt;10; it++) {
  matmult(indata,outdata,buffersize);
  localnorm = localsum(outdata,buffersize);
  MPI_Start( &reduce_request );
  MPI_Wait( &reduce_request,MPI_STATUS_IGNORE );
  scale(outdata,indata,buffersize,1./sqrt(globalnorm));
}
MPI_Request_free( &reduce_request );
</pre>
</div>
</div>
<p name="switchToTextMode">

Some points.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
  Metadata arrays, such as of counts and datatypes,
  must not be altered until the 
<tt>MPI_Request_free</tt>
 call.
<li>
The initialization call is nonlocal, so it can block until all
  processes have performed it.
<li>
Multiple persistent collective can be initialized, in which case
  they satisfy the same restrictions as ordinary collectives, in particular
  on ordering. Thus, the following code is incorrect:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
// WRONG
if (procid==0) {
  MPI_Reduce_init( /* ... */ &req1);
  MPI_Bcast_init( /* ... */ &req2);
} else {
  MPI_Bcast_init( /* ... */ &req2);
  MPI_Reduce_init( /* ... */ &req1);
}
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
However, after initialization the start calls can be in arbitrary order,
and in different order among the processes.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

  Available persistent collectives are:
<tt>MPI_Barrier_init</tt>
<tt>MPI_Bcast_init</tt>
<tt>MPI_Reduce_init</tt>
<tt>MPI_Allreduce_init</tt>
<tt>MPI_Reduce_scatter_init</tt>
<tt>MPI_Reduce_scatter_block_init</tt>
<tt>MPI_Gather_init</tt>
<tt>MPI_Gatherv_init</tt>
<tt>MPI_Allgather_init</tt>
<tt>MPI_Allgatherv_init</tt>
<tt>MPI_Scatter_init</tt>
<tt>MPI_Scatterv_init</tt>
<tt>MPI_Alltoall_init</tt>
<tt>MPI_Alltoallv_init</tt>
<tt>MPI_Alltoallw_init</tt>
<tt>MPI_Scan_init</tt>
<tt>MPI_Exscan_init</tt>
</p>

<!-- index -->
<i>End of MPI 4 note</i>
</remark>
<!-- environment: mpifour end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Persistentneighborcommunications">5.1.3</a> Persistent neighbor communications</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Persistentcommunicationrequests">Persistent communication requests</a> > <a href="mpi-persist.html#Persistentneighborcommunications">Persistent neighbor communications</a>
</p>
</p>

<!-- environment: mpifour start embedded generator -->
<!-- environment block purpose: [[ environment=mpifour ]] -->
<remark>
<b>MPI 4 Standard only</b>
<p name="remark">
<!-- TranslatingLineGenerator mpifour ['mpifour'] -->
</p>

<tt>MPI_Neighbor_allgather_init</tt>
<p name="switchToTextMode">
,
<tt>MPI_Neighbor_allgatherv_init</tt>
,
<tt>MPI_Neighbor_alltoall_init</tt>
,
<tt>MPI_Neighbor_alltoallv_init</tt>
,
<tt>MPI_Neighbor_alltoallw_init</tt>
,
</p>

<i>End of MPI 4 note</i>
</remark>
<!-- environment: mpifour end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Partitionedcommunication">5.2</a> Partitioned communication</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Partitionedcommunication">Partitioned communication</a>
</p>
<!-- environment: mpifour start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mpifour ]] -->
<remark>
<b>MPI 4 Standard only</b>
<p name="remark">
<!-- TranslatingLineGenerator mpifour ['mpifour'] -->

<!-- index -->
<!-- index -->
</p>

<p name="switchToTextMode">
Partitioned communication is a variant
on 
<i>persistent communication</i>
,
where a message is constructed in partitions.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The normal 
<tt>MPI_Send_init</tt>
 is replaced
  by 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Psend_init" aria-expanded="false" aria-controls="MPI_Psend_init">
        Routine reference: MPI_Psend_init
      </button>
    </h5>
  </div>
  <div id="MPI_Psend_init" class="collapse">
  <pre>
</pre>
</div>
</div>
<i>MPI_Psend_init</i>
.
  Note the presence of an 
<tt>MPI_Info</tt>
 argument,
  as in persistent collectives, but unlike in persistent sends and receives.
<li>
After this, the 
<tt>MPI_Start</tt>
 does not
  actually start the transfer; instead:
<li>
Each partition of the message is separately
  declared as read-to-be-sent with 
<tt>MPI_Pready</tt>
.
<li>
An 
<tt>MPI_Wait</tt>
 call completes the operation,
  indicating that all partitions have been sent.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
A common scenario for this is in multi-threaded environments,
where each thread can construct its own part of a message.
Having partitioned messages means that partially constructed message buffers
can be sent off without having to wait for all threads to finish.
</p>

<p name="switchToTextMode">
Indicating that parts of a message are ready for sending
is done by one of the following calls:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Pready" aria-expanded="false" aria-controls="MPI_Pready">
        Routine reference: MPI_Pready
      </button>
    </h5>
  </div>
  <div id="MPI_Pready" class="collapse">
  <pre>
</pre>
</div>
</div>
<i>MPI_Pready</i>
 for a single partition;
<li>
<tt>MPI_Pready_range</tt>
 for a range of partitions; and
<li>
<tt>MPI_Pready_list</tt>
 for an explicitly enumerated list of partitions.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
The 
<tt>MPI_Psend_init</tt>
 call yields an 
<tt>MPI_Request</tt>
 object
that can be used to test for completion
(see sections 
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Requestcompletion:waitcalls">4.2.2</a>
 and&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Waitandtestcalls">4.2.3</a>
)
of the full operation.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#psendsend" aria-expanded="false" aria-controls="psendsend">
        C Code: psendsend
      </button>
    </h5>
  </div>
  <div id="psendsend" class="collapse">
  <pre>
// partition.c
double *sendbuffer = (double*)malloc(bufsize*sizeof(double));
fill_buffer(sendbuffer,bufsize,1);
double start = MPI_Wtime();
MPI_Request send_request;
MPI_Psend_init
  (sendbuffer,nparts,SIZE,MPI_DOUBLE,tgt,0,
   comm,MPI_INFO_NULL,&send_request);
for (int it=0; it&lt;ITERATIONS; it++) {
  MPI_Start(&send_request);
  for (int ip=0; ip&lt;nparts; ip++)
    MPI_Pready(ip,send_request);
  MPI_Wait(&send_request,MPI_STATUS_IGNORE);
}
MPI_Request_free(&send_request);
</pre>
</div>
</div>
<p name="switchToTextMode">

The receiving side is largely the mirror image of the sending side:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
a partitioned send can only be matched with a partitioned receive,
  so we start with an 
<tt>MPI_Precv_init</tt>
.
<li>
Arrival of a partition can be tested with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Parrived" aria-expanded="false" aria-controls="MPI_Parrived">
        Routine reference: MPI_Parrived
      </button>
    </h5>
  </div>
  <div id="MPI_Parrived" class="collapse">
  <pre>
</pre>
</div>
</div>
<i>MPI_Parrived</i>
.
<li>
A call to 
<tt>MPI_Wait</tt>
 completes the operation,
  indicating that all partitions have arrived.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Again, the 
<tt>MPI_Request</tt>
 object from the receive-init call can
be used to test for completion of the full receive operation.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#psendrecv" aria-expanded="false" aria-controls="psendrecv">
        C Code: psendrecv
      </button>
    </h5>
  </div>
  <div id="psendrecv" class="collapse">
  <pre>
double *recvbuffer = (double*)malloc(bufsize*sizeof(double));
MPI_Request recv_request;
MPI_Precv_init
  (recvbuffer,nparts,SIZE,MPI_DOUBLE,src,0,
   comm,MPI_INFO_NULL,&recv_request);
for (int it=0; it&lt;ITERATIONS; it++) {
  MPI_Start(&recv_request);
  MPI_Wait(&recv_request,MPI_STATUS_IGNORE);
  int r = chck_buffer(recvbuffer,bufsize,1);
}
MPI_Request_free(&recv_request);
</pre>
</div>
</div>
<p name="switchToTextMode">

<!-- index -->
</p name="remark">
<i>End of MPI 4 note</i>
</remark>
<!-- environment: mpifour end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Synchronousandasynchronouscommunication">5.3</a> Synchronous and asynchronous communication</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Synchronousandasynchronouscommunication">Synchronous and asynchronous communication</a>
</p>
<!-- index -->
<!-- index -->
</p>

<p name="switchToTextMode">
It is easiest to think of blocking as a form of synchronization with
the other process, but that is not quite true. Synchronization is a
concept in itself, and we talk about 
<i>synchronous</i>
 communication
if there is actual coordination going on with the other process,
and 
<i>asynchronous</i>
 communication if there is not. Blocking then
only refers to the program waiting until the user data is safe
to reuse; in the synchronous case a blocking call means that the data
is indeed transferred, in the asynchronous case it only means that the
data has been transferred to some system buffer.
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/block-vs-sync.jpeg" width=800></img>
<p name="caption">
FIGURE 5.1: Blocking and synchronicity
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
The four possible cases are illustrated in figure&nbsp;
5.1
.
</p>

<h3><a id="Synchronoussendoperations">5.3.1</a> Synchronous send operations</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Synchronousandasynchronouscommunication">Synchronous and asynchronous communication</a> > <a href="mpi-persist.html#Synchronoussendoperations">Synchronous send operations</a>
</p>

<p name="switchToTextMode">

MPI has a number of routines for synchronous communication,
such as 
<tt>MPI_Ssend</tt>
.
Driving home the point that nonblocking and asynchronous are
different concepts, there is a routine 
<tt>MPI_Issend</tt>
,
which is synchronous but nonblocking.
These routines have the same calling sequence as their not-explicitly
synchronous variants, and only differ in their semantics.
</p>

<p name="switchToTextMode">
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Eagervsrendezvousprotocol">4.1.4.2</a>
 for examples.
</p>

<!-- index -->
<!-- index -->
<p name="switchToTextMode">

<h2><a id="Localandnonlocaloperations">5.4</a> Local and nonlocal operations</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Localandnonlocaloperations">Local and nonlocal operations</a>
</p>


<!-- index -->
<!-- index -->
</p>

<p name="switchToTextMode">
The MPI standard does not dictate whether communication is buffered.
If a message is buffered, a send call can complete,
even if no corresponding send has been posted yet.
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-ptp.html#Eagervsrendezvousprotocol">4.1.4.2</a>
.
Thus, in the standard communication, a send operation
is 
<i>nonlocal</i>
: its completion may be depend on
whether the corresponding receive has been posted.
A 
</p>

<p name="switchToTextMode">
On the other hand, 
<i>buffered communication</i>
(routines 
<tt>MPI_Bsend</tt>
, 
<tt>MPI_Ibsend</tt>
,
<tt>MPI_Bsend_init</tt>
; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Bufferedcommunication">5.5</a>
)
is 
<i>local</i>
:
the presence of an explicit buffer means that a send operation
can complete no matter whether the receive has been posted.
</p>

<p name="switchToTextMode">
The 
<i>synchronous send</i>
(routines 
<tt>MPI_Ssend</tt>
, 
<tt>MPI_Issend</tt>
,
<tt>MPI_Ssend_init</tt>
; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi.html#Subtletieswithprocessorsynchronization">15.8</a>
)
is again nonlocal (even in the nonblocking variant)
since it will only complete when the receive call has completed.
</p>

<p name="switchToTextMode">
Finally, the 
<i>ready mode send</i>
(
<tt>MPI_Rsend</tt>
, 
<tt>MPI_Irsend</tt>
)
is nonlocal in the sense that its only correct use
is when the corresponding receive has been issued.
</p>

<!-- index -->
<!-- index -->
<p name="switchToTextMode">

<h2><a id="Bufferedcommunication">5.5</a> Buffered communication</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Bufferedcommunication">Buffered communication</a>
</p>

</p>

<!-- environment: figure start embedded generator -->
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/bufferattach.png" width=800></img>
<p name="caption">
FIGURE 5.2: User communication routed through an attached buffer
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

By now you have probably got the notion that managing buffer
space in MPI is important: data has to be somewhere, either in
user-allocated arrays or in system buffers. Using
<i>buffered communication</i>
 is yet another
way of managing buffer space.
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
You allocate your own buffer space, and you attach it to your
  process. This buffer is not a send buffer: it is a replacement for
  buffer space used inside the MPI library or on the network card;
  figure&nbsp;
5.2
. If high-bandwdith memory is available,
  you could create your buffer there.
<li>
You use the 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Bsend" aria-expanded="false" aria-controls="MPI_Bsend">
        Routine reference: MPI_Bsend
      </button>
    </h5>
  </div>
  <div id="MPI_Bsend" class="collapse">
  <pre>
C:
int MPI_Bsend
   (const void *buf, int count, MPI_Datatype datatype,
    int dest, int tag,MPI_Comm comm)

Input Parameters
buf : initial address of send buffer (choice)
count : number of elements in send buffer (nonnegative integer)
datatype : datatype of each send buffer element (handle)
dest : rank of destination (integer)
tag : message tag (integer)
comm : communicator (handle)
</pre>
</div>
</div>
<i>MPI_Bsend</i>
  (or its 
<i>local</i>

<!-- index -->
 variant 
<tt>MPI_Ibsend</tt>
)
  call for sending, using
  otherwise normal send and receive buffers;
<li>
You detach the buffer when you're done with the buffered sends.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

One advantage of buffered sends is that they are nonblocking:
since there is a guaranteed buffer long enough to contain the
message, it is not necessary to wait for the receiving process.
</p>

<p name="switchToTextMode">
We illustrate the use of buffered sends:
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bsendbuf" aria-expanded="false" aria-controls="bsendbuf">
        C Code: bsendbuf
      </button>
    </h5>
  </div>
  <div id="bsendbuf" class="collapse">
  <pre>
// bufring.c
int bsize = BUFLEN*sizeof(float);
float
  *sbuf = (float*) malloc( bsize ),
  *rbuf = (float*) malloc( bsize );
MPI_Pack_size( BUFLEN,MPI_FLOAT,comm,&bsize);
bsize += MPI_BSEND_OVERHEAD;
float
  *buffer = (float*) malloc( bsize );

MPI_Buffer_attach( buffer,bsize );
err = MPI_Bsend(sbuf,BUFLEN,MPI_FLOAT,next,0,comm);
MPI_Recv (rbuf,BUFLEN,MPI_FLOAT,prev,0,comm,MPI_STATUS_IGNORE);
MPI_Buffer_detach( &buffer,&bsize );
</pre>
</div>
</div>
<p name="switchToTextMode">

<h3><a id="Buffertreatment">5.5.1</a> Buffer treatment</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Bufferedcommunication">Buffered communication</a> > <a href="mpi-persist.html#Buffertreatment">Buffer treatment</a>
</p>
</p>

<p name="switchToTextMode">
There can be only one buffer per process, attached with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Buffer_attach" aria-expanded="false" aria-controls="MPI_Buffer_attach">
        Routine reference: MPI_Buffer_attach
      </button>
    </h5>
  </div>
  <div id="MPI_Buffer_attach" class="collapse">
  <pre>
int MPI_Buffer_attach( void *buffer, int size );

Input arguments:
buffer : initial buffer address (choice)
size : buffer size, in bytes (integer)
</pre>
</div>
</div>
<i>MPI_Buffer_attach</i>
.
Its size should be enough
for all 
<tt>MPI_Bsend</tt>
 calls that are simultaneously
outstanding.
You can compute the needed size of the buffer with 
<tt>MPI_Pack_size</tt>
;
see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Packing">6.8</a>
.
Additionally, a term of 
<tt>MPI_BSEND_OVERHEAD</tt>
 is needed.
See the above code fragment.
</p>

<p name="switchToTextMode">
The buffer is detached with 
<tt>MPI_Buffer_detach</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int MPI_Buffer_detach(
  void *buffer, int *size);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
This returns the address and size of the buffer; the call blocks
until all buffered messages have been delivered.
</p>

<p name="switchToTextMode">
Note that both
<tt>MPI_Buffer_attach</tt>
 and 
<tt>MPI_Buffer_detach</tt>
have a  <tt>void*</tt>  argument for the buffer, but
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
in the attach routine this is the address of the buffer,
<li>
while the detach routine it is the address of the buffer pointer.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
This is done so that the detach routine can zero the buffer pointer.
</p>

<p name="switchToTextMode">
While the buffered send is nonblocking like an 
<tt>MPI_Isend</tt>
,
there is no corresponding wait call.
You can force delivery by
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Buffer_detach( &b, &n );
MPI_Buffer_attach( b, n );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  Creating and attaching a buffer is done through 
<tt>bsend_buffer</tt>
  and a support routine 
<tt>bsend_size</tt>
  the buffer size:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bsendbufmpl" aria-expanded="false" aria-controls="bsendbufmpl">
        C++ Code: bsendbufmpl
      </button>
    </h5>
  </div>
  <div id="bsendbufmpl" class="collapse">
  <pre>
// bufring.cxx
vector&lt;float&gt; sbuf(BUFLEN), rbuf(BUFLEN);
int size{ comm_world.bsend_size&lt;float&gt;(mpl::contiguous_layout&lt;float&gt;(BUFLEN)) };
mpl::bsend_buffer buff(size);
comm_world.bsend(sbuf.data(),mpl::contiguous_layout&lt;float&gt;(BUFLEN), next);
</pre>
</div>
</div>
</p>

  Constant:  <tt>mpl::</tt> 
<tt>bsend_overhead</tt>
<p name="switchToTextMode">
  to the MPI constant 
<tt>MPI_BSEND_OVERHEAD</tt>
.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  There is a separate attach routine, but normally this is called
  by the constructor of the  <tt>bsend_buffer</tt> .
  Likewise, the detach routine is called in the buffer destructor.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
void mpl::environment::buffer_attach (void *buff, int size);
std::pair&lt; void *, int &gt; mpl::environment::buffer_detach ();
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Bufferendsendcalls">5.5.2</a> Bufferend send calls</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Bufferedcommunication">Buffered communication</a> > <a href="mpi-persist.html#Bufferendsendcalls">Bufferend send calls</a>
</p>
</p>

<p name="switchToTextMode">
The possible error codes are
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>MPI_SUCCESS</tt>
 the routine completed successfully.
<li>
<tt>MPI_ERR_BUFFER</tt>
 The buffer pointer is invalid;
  this typically means that you have supplied a null pointer.
<li>
<tt>MPI_ERR_INTERN</tt>
 An internal error in MPI has been detected.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

The asynchronous version is 
<tt>MPI_Ibsend</tt>
, the persistent
(see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Persistentcommunicationrequests">5.1</a>
) call is 
<tt>MPI_Bsend_init</tt>
.
</p>

<h3><a id="Persistentbufferedcommunication">5.5.3</a> Persistent buffered communication</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-persist.html">mpi-persist</a> > <a href="mpi-persist.html#Bufferedcommunication">Buffered communication</a> > <a href="mpi-persist.html#Persistentbufferedcommunication">Persistent buffered communication</a>
</p>
<p name="switchToTextMode">

There is a persistent variant
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Bsend_init" aria-expanded="false" aria-controls="MPI_Bsend_init">
        Routine reference: MPI_Bsend_init
      </button>
    </h5>
  </div>
  <div id="MPI_Bsend_init" class="collapse">
  <pre>
Synopsis
int MPI_Bsend_init
   (const void *buf, int count, MPI_Datatype datatype,
    int dest, int tag, MPI_Comm comm,
    MPI_Request *request)

Input Parameters
buf : initial address of send buffer (choice)
count : number of elements sent (integer)
datatype : type of each element (handle)
dest : rank of destination (integer)
tag : message tag (integer)
comm : communicator (handle)

Output Parameters
request : communication request (handle)
</pre>
</div>
</div>
<i>MPI_Bsend_init</i>
of buffered sends, as with regular
sends (section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-persist.html#Persistentcommunicationrequests">5.1</a>
).
</p>

</div>
<a href="index.html">Back to Table of Contents</a>
