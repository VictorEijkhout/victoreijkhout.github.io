<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="http://ccrs.cac.cornell.edu:8080/client.0.1.js"></script>
<style>
</style>

<script type="application/javascript">
let fileRoot      = "hello";
let fileName      = fileRoot + ".c";
let compileCmd    = "mpicc " + fileName + " -o " + fileRoot;
let runCmd        = "mpirun --oversubscribe -np 8 " + fileRoot;
let compileRunCmd = [compileCmd, runCmd].join(" && ");

async function afterExecute(results) {
  document.getElementById('stdoutPre').textContent = results.stdout;
  document.getElementById('stderrPre').textContent = results.stderr;
}

async function initialize() {
  let editor = await MonacoEditorFileSource.create("editorDiv");
  editor.setTextFromFile("mpiHello.c");

  let job = await Job.create(JobType.MPI);
  let command = new CommandWithFiles(job, compileRunCmd);
  command.addFileSource(editor, fileName);
  let trigger = new ButtonTrigger(command, afterExecute, "executeBtn");

  document.getElementById("executeBtn").disabled = false;
}

initialize();
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>PETSc solvers</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


36.1 : <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a><br>
36.1.1 : <a href="petsc-solver.html#Mathbackground">Math background</a><br>
36.1.2 : <a href="petsc-solver.html#Solverobjects">Solver objects</a><br>
36.1.3 : <a href="petsc-solver.html#Tolerances">Tolerances</a><br>
36.1.4 : <a href="petsc-solver.html#Whydidmysolverstop?Diditwork?">Why did my solver stop? Did it work?</a><br>
36.1.5 : <a href="petsc-solver.html#Choiceofiterator">Choice of iterator</a><br>
36.1.6 : <a href="petsc-solver.html#Multipleright-handsides">Multiple right-hand sides</a><br>
36.1.7 : <a href="petsc-solver.html#Preconditioners">Preconditioners</a><br>
36.1.7.1 : <a href="petsc-solver.html#Background">Background</a><br>
36.1.7.2 : <a href="petsc-solver.html#Usage">Usage</a><br>
36.1.7.3 : <a href="petsc-solver.html#Types">Types</a><br>
36.1.7.3.1 : <a href="petsc-solver.html#Sparseapproximateinverses">Sparse approximate inverses</a><br>
36.1.7.3.2 : <a href="petsc-solver.html#Incompletefactorizations">Incomplete factorizations</a><br>
36.1.7.3.3 : <a href="petsc-solver.html#Blockmethods">Block methods</a><br>
36.1.7.3.4 : <a href="petsc-solver.html#Multigridpreconditioners">Multigrid preconditioners</a><br>
36.1.7.3.5 : <a href="petsc-solver.html#Fieldsplitpreconditioners">Field split preconditioners</a><br>
36.1.8 : <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a><br>
36.1.8.1.1 : <a href="petsc-solver.html#Shellpreconditioners">Shell preconditioners</a><br>
36.1.8.1.2 : <a href="petsc-solver.html#Combiningpreconditioners">Combining preconditioners</a><br>
36.1.8.2 : <a href="petsc-solver.html#Convergencetests">Convergence tests</a><br>
36.1.8.3 : <a href="petsc-solver.html#Convergencemonitoring">Convergence monitoring</a><br>
36.1.8.4 : <a href="petsc-solver.html#Auxiliaryroutines">Auxiliary routines</a><br>
36.2 : <a href="petsc-solver.html#Directsolvers">Direct solvers</a><br>
36.3 : <a href="petsc-solver.html#Controlthroughcommandlineoptions">Control through command line options</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>36 PETSc solvers</h1>
<!-- TranslatingLineGenerator file ['file'] -->
</p>

<p name="switchToTextMode">
Probably the most important activity in PETSc is solving a linear
system. This is done through a solver object: an object of the class
<tt>KSP</tt>
. (This stands for Krylov SPace solver.) The solution routine

<tt>KSPSolve</tt>
 takes a matrix and a right-hand-side and gives a
solution; however, before you can call this some amount of setup is needed.
</p>

<p name="switchToTextMode">
There two very different ways of solving a
linear system: through a direct method, essentially a variant of
Gaussian elimination; or through an iterative method that makes
successive approximations to the solution. In PETSc there are only
iterative methods. We will show how to achieve direct methods later.
The default linear system solver in PETSc is fully parallel, and will
work on many linear systems, but there are many settings and
customizations to tailor the solver to your specific problem.
</p>

<h2><a id="KSP:linearsystemsolvers">36.1</a> KSP: linear system solvers</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a>
</p>

<p name="switchToTextMode">

<h3><a id="Mathbackground">36.1.1</a> Math background</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Mathbackground">Math background</a>
</p>

</p>

<p name="switchToTextMode">
Many scientific applications boil down to the solution of a system of
linear equations at some point:
\[
 ?_x\colon Ax=b 
\]
The elementary textbook way of solving this is through an
<i>LU factorization</i>
,
also known as 
<i>Gaussian elimination</i>
:
\[
 LU\leftarrow A,\qquad Lz=b,\qquad Ux=z. 
\]
While PETSc has support for this, its basic design is geared towards
so-called iterative solution methods.
Instead of directly computing
the solution to the system, they compute a sequence of approximations
that, with luck, converges to the true solution:
</p>

<!-- environment: quote start embedded generator -->
<!-- environment block purpose: [[ environment=quote ]] -->
<quote>

<p name="quote">
<!-- TranslatingLineGenerator quote ['quote'] -->
<!-- environment: tabbing start embedded generator -->
</p>
<p style="margin-left: 40px">
<!-- TranslatingLineGenerator tabbing ['tabbing'] --><br>
<p name="switchToTextMode"><br>
    while not converged<br>
&nbsp;         $x_{i+1}\leftarrow f(x_i)$<br>
</p>
<!-- environment: tabbing end embedded generator -->
</quote>
<!-- environment: quote end embedded generator -->
<p name="switchToTextMode">

The interesting thing about iterative methods is that the iterative step
only involves the 
<i>matrix-vector product</i>
:
</p>

<!-- environment: quote start embedded generator -->
<!-- environment block purpose: [[ environment=quote ]] -->
<quote>

<p name="quote">
<!-- TranslatingLineGenerator quote ['quote'] -->
<!-- environment: tabbing start embedded generator -->
</p>
<p style="margin-left: 40px">
<!-- TranslatingLineGenerator tabbing ['tabbing'] --><br>
<p name="switchToTextMode"><br>
    while not converged<br>
&nbsp;         $r_i = Ax_i-b$<br>
&nbsp;         $x_{i+1}\leftarrow f(r_i)$<br>
</p>
<!-- environment: tabbing end embedded generator -->
</quote>
<!-- environment: quote end embedded generator -->
<p name="switchToTextMode">

This 
<i>residual</i>
 is also crucial in determining whether to stop the iteration:
since we (clearly) can not measure the distance to the true solution, we use
the size of the residual as a proxy measurement.
</p>

<p name="switchToTextMode">
The remaining point to know is that iterative methods feature a 
<i>preconditioner</i>
.
Mathematically this is equivalent to transforming the linear system to
\[
 M\inv Ax=M\inv b 
\]
so conceivably we could iterate on the transformed matrix and right-hand side.
However, in practice we apply the preconditioner in each iteration:
</p>

<!-- environment: quote start embedded generator -->
<!-- environment block purpose: [[ environment=quote ]] -->
<quote>

<p name="quote">
<!-- TranslatingLineGenerator quote ['quote'] -->
<!-- environment: tabbing start embedded generator -->
</p>
<p style="margin-left: 40px">
<!-- TranslatingLineGenerator tabbing ['tabbing'] --><br>
<p name="switchToTextMode"><br>
    while not converged<br>
&nbsp;         $r_i = Ax_i-b$<br>
&nbsp;         $z_i = M\inv r_i$<br>
&nbsp;         $x_{i+1}\leftarrow f(z_i)$<br>
</p>
<!-- environment: tabbing end embedded generator -->
</quote>
<!-- environment: quote end embedded generator -->
<p name="switchToTextMode">

In this schematic presentation we have left the nature of the $f()$ update
function unspecified. Here, many possibilities exist; the primary
choice here is of the iterative method type, such as `conjugate gradients',
`generalized minimum residual', or `bi-conjugate gradients stabilized'.
(We will go into direct solvers in section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#Directsolvers">36.2</a>
.)
</p>

<h3><a id="Solverobjects">36.1.2</a> Solver objects</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Solverobjects">Solver objects</a>
</p>
<p name="switchToTextMode">

First we create a KSP object, which contains the coefficient matrix,
and various parameters such as the desired accuracy,
as well as method specific parameters:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPCreate" aria-expanded="false" aria-controls="KSPCreate">
        Routine reference: KSPCreate
      </button>
    </h5>
  </div>
  <div id="KSPCreate" class="collapse">
  <pre>
C:
PetscErrorCode KSPCreate(MPI_Comm comm,KSP *v);

Python:
ksp = PETSc.KSP()
ksp.create()
# or:
ksp = PETSc.KSP().create()

</pre>
</div>
</div>
<i>KSPCreate</i>
.
</p>

<p name="switchToTextMode">
After this, the basic scenario is:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Vec rhs,sol;
KSP solver;
KSPCreate(comm,&solver);
KSPSetOperators(solver,A,A);
KSPSetFromOptions(solver);
KSPSolve(solver,rhs,sol);
KSPDestroy(&solver);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
using various default settings. The vectors and the matrix have to be
conformly partitioned.
The 
<tt>KSPSetOperators</tt>
 call
takes two operators: one is the actual coefficient matrix, and the second
the one that the preconditioner is derived from.
In some cases it makes sense
to specify a different matrix here.
(You can retrieve the operators with 
<tt>KSPGetOperators</tt>
.)
The call 
<tt>KSPSetFromOptions</tt>
 can cover almost all of the
settings discussed next.
</p>

<p name="switchToTextMode">
KSP objects have many options to control them, so it is convenient
to call 
<tt>KSPView</tt>
(or use the commandline option 
<tt>ksp_view</tt>
)
to get a listing of all the settings.
</p>

<h3><a id="Tolerances">36.1.3</a> Tolerances</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Tolerances">Tolerances</a>
</p>
<p name="switchToTextMode">

Since neither
solution nor solution speed is guaranteed, an iterative solver is
subject to some tolerances:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
a relative tolerance for when the residual has been reduced
  enough;
<li>
an absolute tolerance for when the residual is objectively
  small;
<li>
a divergence tolerance that stops the iteration if the residual
  grows by too much; and
<li>
a bound on the number of iterations, regardless any progress the
  process may still be making.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

These tolerances are set with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPSetTolerances" aria-expanded="false" aria-controls="KSPSetTolerances">
        Routine reference: KSPSetTolerances
      </button>
    </h5>
  </div>
  <div id="KSPSetTolerances" class="collapse">
  <pre>
#include "petscksp.h"
PetscErrorCode  KSPSetTolerances
   (KSP ksp,PetscReal rtol,PetscReal abstol,PetscReal dtol,PetscInt maxits)

Logically Collective on ksp

Input Parameters:
ksp- the Krylov subspace context
rtol- the relative convergence tolerance, relative decrease in the
(possibly preconditioned) residual norm
abstol- the absolute convergence tolerance absolute size of the
(possibly preconditioned) residual norm
dtol- the divergence tolerance, amount (possibly preconditioned)
residual norm can increase before KSPConvergedDefault() concludes that
the method is diverging
maxits- maximum number of iterations to use

Options Database Keys
-ksp_atol <abstol>- Sets abstol
-ksp_rtol <rtol>- Sets rtol
-ksp_divtol <dtol>- Sets dtol
-ksp_max_it <maxits>- Sets maxits
</pre>
</div>
</div>
<i>KSPSetTolerances</i>
,
or options 
<tt>ksp_atol</tt>
, 
<tt>ksp_rtol</tt>
,
<tt>ksp_divtol</tt>
, 
<tt>ksp_max_it</tt>
.
Specify to 
<tt>PETSC_DEFAULT</tt>
 to leave a value unaltered.
</p>

<p name="switchToTextMode">
In the next section we will see how you can determine which of these tolerances
caused the solver to stop.
</p>

<h3><a id="Whydidmysolverstop?Diditwork?">36.1.4</a> Why did my solver stop? Did it work?</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Whydidmysolverstop?Diditwork?">Why did my solver stop? Did it work?</a>
</p>

<p name="switchToTextMode">

On return of the 
<tt>KSPSolve</tt>
 routine there is no guarantee
that the system was successfully solved.
Therefore, you need to invoke
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPGetConvergedReason" aria-expanded="false" aria-controls="KSPGetConvergedReason">
        Routine reference: KSPGetConvergedReason
      </button>
    </h5>
  </div>
  <div id="KSPGetConvergedReason" class="collapse">
  <pre>
C:
PetscErrorCode KSPGetConvergedReason
   (KSP ksp,KSPConvergedReason *reason)
Not Collective

Input Parameter
ksp -the KSP context

Output Parameter
reason -negative value indicates diverged, positive value converged,
see KSPConvergedReason

Python:
r = KSP.getConvergedReason(self)
where r in PETSc.KSP.ConvergedReason
</pre>
</div>
</div>
<i>KSPGetConvergedReason</i>
to get a 
<tt>KSPConvergedReason</tt>
 parameter that indicates
what state the solver stopped in:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The iteration can have successfully converged; this corresponds
  to 
<tt>reason</tt>
$&gt;0$;
<li>
the iteration can have diverged, or otherwise failed: 
<tt>reason</tt>
$&lt;0$;
<li>
or the iteration may have stopped at the maximum number of
  iterations while still making progress; 
<tt>reason</tt>
$=0$.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
For more detail,
<tt>KSPConvergedReasonView</tt>
(before version 3.14: 
can print out the
reason in readable form; for instance
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
KSPConvergedReasonView(solver,PETSC_VIEWER_STDOUT_WORLD);
// before 3.14:
KSPReasonView(solver,PETSC_VIEWER_STDOUT_WORLD);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
(This can also be activated with the 
<tt>ksp_converged_reason</tt>
commandline option.)
</p>

<p name="switchToTextMode">
In case of successful convergence, you can use 
<tt>KSPGetIterationNumber</tt>
to report how many
iterations were taken.
</p>

<p name="switchToTextMode">
The following snippet analyzes the status of a 
<tt>KSP</tt>
 object
that has stopped iterating:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#petscreasonreport" aria-expanded="false" aria-controls="petscreasonreport">
        C Code: petscreasonreport
      </button>
    </h5>
  </div>
  <div id="petscreasonreport" class="collapse">
  <pre>
// shellvector.c
PetscInt its; KSPConvergedReason reason;
Vec Res; PetscReal norm;
ierr = KSPGetConvergedReason(Solve,&reason); CHKERRQ(ierr);
ierr = KSPReasonView(Solve,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
if (reason&lt;0) {
  PetscPrintf(comm,"Failure to converge: reason=%d\n",reason);
} else {
  ierr = KSPGetIterationNumber(Solve,&its); CHKERRQ(ierr);
  PetscPrintf(comm,"Number of iterations: %d\n",its);
}
</pre>
</div>
</div>
</p>

<h3><a id="Choiceofiterator">36.1.5</a> Choice of iterator</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Choiceofiterator">Choice of iterator</a>
</p>
<p name="switchToTextMode">

There are many iterative methods, and it may take a few function calls
to fully specify them. The basic routine is 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPSetType" aria-expanded="false" aria-controls="KSPSetType">
        Routine reference: KSPSetType
      </button>
    </h5>
  </div>
  <div id="KSPSetType" class="collapse">
  <pre>
#include "petscksp.h"
PetscErrorCode  KSPSetType(KSP ksp, KSPType type)

Logically Collective on ksp

Input Parameters:
ksp : the Krylov space context
type : a known method

</pre>
</div>
</div>
<i>KSPSetType</i>
,
or use the option 
<tt>ksp_type</tt>
.
</p>

<p name="switchToTextMode">
Here are some values (the full list is in 
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>KSPCG</tt>
: only for symmetric positive definite systems.
  It has a cost of both work and storage that is constant in the number of iterations.
</p>

<p name="switchToTextMode">
  There are variants such as 
<tt>KSPPIPECG</tt>
 that are mathematically equivalent,
  but possibly higher performing at large scale.
<li>

<tt>KSPGMRES</tt>
: a minimization method that works for nonsymmetric
  and indefinite systems. However, to satisfy this theoretical property
  it needs to store the full residual history to orthogonalize each
  compute residual to, implying that storage
  is linear, and work quadratic, in the number of iterations.
  For this reason, GMRES is always used in a truncated variant, that regularly restarts
  the orthogonalization. The restart length can be set with the routine
<tt>KSPGMRESSetRestart</tt>
 or the option 
<tt>ksp_gmres_restart</tt>
.
<li>

<tt>KSPBCGS</tt>
: a quasi-minimization method; uses less memory than GMRES.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Depending on the iterative method, there can be several routines to tune its workings.
Especially if you're still experimenting with what method to choose,
it may be more convenient to specify these choices through commandline options,
rather than explicitly coded routines. In that case, a single call to
<tt>KSPSetFromOptions</tt>
 is enough to incorporate those.
</p>

<h3><a id="Multipleright-handsides">36.1.6</a> Multiple right-hand sides</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Multipleright-handsides">Multiple right-hand sides</a>
</p>
<p name="switchToTextMode">

For the case of multiple right-hand sides,
use 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPMatSolve" aria-expanded="false" aria-controls="KSPMatSolve">
        Routine reference: KSPMatSolve
      </button>
    </h5>
  </div>
  <div id="KSPMatSolve" class="collapse">
  <pre>
PetscErrorCode KSPMatSolve(KSP ksp, Mat B, Mat X)

Input Parameters
ksp - iterative context
B - block of right-hand sides

Output Parameter
X - block of solutions
</pre>
</div>
</div>
<i>KSPMatSolve</i>
.
</p>

<h3><a id="Preconditioners">36.1.7</a> Preconditioners</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a>
</p>
<p name="switchToTextMode">

Another part of an iterative solver is the 
<i>preconditioner</i>
.
The mathematical background of this
is given in section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#Mathbackground">36.1.1</a>
.
The preconditioner acts to make the coefficient matrix better conditioned,
which will improve the convergence speed; it can even be that without
a suitable preconditioner a solver will not converge at all.
</p>

<h4><a id="Background">36.1.7.1</a> Background</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Background">Background</a>
</p>
<p name="switchToTextMode">

The mathematical requirement that the preconditioner&nbsp;$M$
satisfy $M\approx A$ can take two forms:
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
We form an explicit approximation to&nbsp;$A\inv$; this is known as a
<i>sparse approximate inverse</i>
.
<li>
We form an operator&nbsp;$M$ (often given in factored or other
  implicit) form, such that $M\approx A$, and solving a system $Mx=y$
  for&nbsp;$x$ can be done relatively quickly.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

In deciding on a preconditioner, we now have to balance the following factors.
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
What is the cost of constructing the preconditioner? This should
  not be more than the gain in solution time of the iterative method.
<li>
What is the cost per iteration of applying the preconditioner?
  There is clearly no point in using a preconditioner that decreases
  the number of iterations by a certain amount, but increases the cost
  per iteration much more.
<li>
Many preconditioners have parameter settings that make these
  considerations even more complicated: low parameter values may give
  a preconditioner that is cheaply to apply but does not improve
  convergence much, while large parameter values make the application
  more costly but decrease the number of iterations.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Usage">36.1.7.2</a> Usage</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Usage">Usage</a>
</p>
</p>

<p name="switchToTextMode">
Unlike most of the other PETSc object types, a&nbsp;
<tt>PC</tt>
 object
is typically not explicitly created. Instead, it is created as part of
the 
<tt>KSP</tt>
 object, and can be retrieved from it.
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PC prec;
KSPGetPC(solver,&prec);
PCSetType(prec,PCILU);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Beyond setting the type of the preconditioner, there are various
type-specific routines for setting various parameters. Some of these
can get quite tedious, and it is more convenient to set them through
commandline options.
</p>

<h4><a id="Types">36.1.7.3</a> Types</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a>
</p>
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
\toprule
Method</td><td>PCType</td><td>Options Database Name</td></tr>
<tr><td>
\midrule
Jacobi</td><td>PCJACOBI</td><td>jacobi</td></tr>
<tr><td>
Block Jacobi</td><td>PCBJACOBI</td><td>bjacobi</td></tr>
<tr><td>
SOR (and SSOR)</td><td>PCSOR</td><td>sor</td></tr>
<tr><td>
SOR with Eisenstat trick</td><td>PCEISENSTAT</td><td>eisenstat</td></tr>
<tr><td>
Incomplete Cholesky</td><td>PCICC</td><td>icc</td></tr>
<tr><td>
Incomplete LU</td><td>PCILU</td><td>ilu</td></tr>
<tr><td>
Additive Schwarz</td><td>PCASM</td><td>asm</td></tr>
<tr><td>
Generalized Additive Schwarz</td><td>PCGASM</td><td>gasm</td></tr>
<tr><td>
Algebraic Multigrid</td><td>PCGAMG</td><td>gamg</td></tr>
<tr><td>
Balancing Domain Decomposition by Constraints Linear solver</td><td>PCBDDC</td><td>bddc</td></tr>
<tr><td>
Use iterative method</td><td>PCKSP</td><td>ksp</td></tr>
<tr><td>
Combination of preconditioners</td><td>PCCOMPOSITE</td><td>composite</td></tr>
<tr><td>
LU</td><td>PCLU</td><td>lu</td></tr>
<tr><td>
Cholesky</td><td>PCCHOLESKY</td><td>cholesky</td></tr>
<tr><td>
No preconditioning</td><td>PCNONE</td><td>none</td></tr>
<tr><td>
Shell for user-defined PC</td><td>PCSHELL</td><td>shell  </td></tr>
<tr><td>
\bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

Here are some of the available preconditioner types.
</p>

<p name="switchToTextMode">
The 
<i>Hypre</i>
 package
(which needs to be installed during configuration time)
contains itself several preconditioners.
In your code, you can set the preconditioner to 
<tt>PCHYPRE</tt>
,
and use 
<tt>PCHYPRESetType</tt>
 to one of:
euclid, pilut, parasails, boomeramg, ams, ads.
However, since these preconditioners themselves have options,
it is usually more convenient to use commandline options:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
-pc_type hypre -pc_hypre_type xxxx
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h5><a id="Sparseapproximateinverses">36.1.7.3.1</a> Sparse approximate inverses</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a> > <a href="petsc-solver.html#Sparseapproximateinverses">Sparse approximate inverses</a>
</p>
</p>

<p name="switchToTextMode">
The inverse of a sparse matrix (at least, those from 
<span title="acronym" ><i>PDEs</i></span>
) is typically dense.
Therefore, we aim to construct a 
<i>sparse approximate inverse</i>
.
</p>

<p name="switchToTextMode">
PETSc offers two such preconditioners, both of which require an external package.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>PCSPAI</tt>
. This is a preconditioner that can only be
  used in single-processor runs, or as local solver in a block
  preconditioner; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#Blockmethods">36.1.7.3.3</a>
.
<li>
As part of the 
<tt>PCHYPRE</tt>
 package, the parallel variant
<i>parasails</i>
 is available.
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
-pc_type hypre -pc_hypre_type parasails
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h5><a id="Incompletefactorizations">36.1.7.3.2</a> Incomplete factorizations</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a> > <a href="petsc-solver.html#Incompletefactorizations">Incomplete factorizations</a>
</p>
</p>

<p name="switchToTextMode">
The $LU$ factorization of a matrix stemming from 
<span title="acronym" ><i>PDEs</i></span>
 problems
has several practical problems:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
It takes (considerably) more storage space than the coefficient matrix, and
<li>
it correspondingly takes more time to apply.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
For instance, for a three-dimensional 
<span title="acronym" ><i>PDE</i></span>
 in $N$&nbsp;variables, the coefficient matrix
can take storage space&nbsp;$7N$, while the $LU$ factorization takes&nbsp;$O(N^{5/3})$.
</p>

<p name="switchToTextMode">
For this reason, often incompletely $LU$ factorizations are popular.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
PETSc has of itself a 
<tt>PCILU</tt>
 type, but this can only be used sequentially.
  This may sound like a limitation, but in parallel it can still be used as the
  subdomain solver in a block methods; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#Blockmethods">36.1.7.3.3</a>
.
<li>
As part of 
<i>Hypre</i>
, 
<i>pilut</i>

<!-- index -->
 is a parallel ILU.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

There are many options for the ILU type, such as
<tt>PCFactorSetLevels</tt>
(option 
<tt>pc_factor_levels</tt>
),
which sets the number of levels of fill-in allowed.
</p>

<h5><a id="Blockmethods">36.1.7.3.3</a> Block methods</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a> > <a href="petsc-solver.html#Blockmethods">Block methods</a>
</p>

<p name="switchToTextMode">

Certain preconditioners seem almost intrinsically sequential.
For instance, an ILU solution is sequential between the variables.
There is a modest amount of parallelism, but that is hard to explore.
</p>

<p name="switchToTextMode">
Taking a step back, one of the problems with parallel preconditioners
lies in the cross-process connections in the matrix. If only those were not present,
we could solve the linear system on each process independently.
Well, since a preconditioner is an approximate solution to begin with,
ignoring those connections only introduces an extra degree of approxomaticity.
</p>

<p name="switchToTextMode">
There are two preconditioners that operate on this notion:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>PCBJACOBI</tt>
: block Jacobi. Here each process solves locally the system
  consisting of the matrix coefficients that couple the local variables.
  In effect, each process solves an independent system on a subdomain.
</p>

<p name="switchToTextMode">
  The next question is then what solver is used on the subdomains.
  Here any preconditioner can be used, in particular the ones that only
  existed in a sequential version. Specifying all this in code gets tedious,
  and it is usually easier to specify such a complicated solver through
  commandline options:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
-pc_type jacobi -sub_ksp_type preonly \
    -sub_pc_type ilu -sub_pc_factor_levels 1
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
(Note that this also talks about a 
<tt>sub_ksp</tt>
: the subdomain solver is in fact
a 
<tt>KSP</tt>
 object. By setting its type to 
<tt>preonly</tt>
 we state that the
solver should consist of solely applying its preconditioner.)
</p>

<p name="switchToTextMode">
  The block Jacobi preconditioner can asympotically only speed up the
  system solution by a factor relating to the number of subdomains,
  but in practice it can be quite valuable.
<li>

<tt>PCASM</tt>
: additive Schwarz method. Here each process
  solves locally a slightly larger system, based on the local
  variables, and one (or a few) levels of connections to neighboring processes.
  In effect, the processes solve system on overlapping subdomains.
  This preconditioner can asympotically reduce the number of iterations to $O(1)$,
  but that requires exact solutions on the subdomains, and in practice it may
  not happen anyway.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/bjacobi.jpg" width=800></img>
<p name="switchToTextMode">
  \caption{Illustration of block Jacobi and Additive Schwarz preconditioners:
  left domains and subdomains, right the corresponding submatrices}

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
Figure&nbsp;
36.1
 illustrates these preconditioners both in
matrix and subdomain terms.
</p>

<h5><a id="Multigridpreconditioners">36.1.7.3.4</a> Multigrid preconditioners</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a> > <a href="petsc-solver.html#Multigridpreconditioners">Multigrid preconditioners</a>
</p>
<p name="switchToTextMode">

<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
There is a 
<span title="acronym" ><i>AMG</i></span>
 type built into PETSc: 
<tt>PCGAMG</tt>
;
<li>
the external packages 
<i>Hypre</i>
 and 
<i>ML</i>
 have
<span title="acronym" ><i>AMG</i></span>
 methods.
<li>
There is a general 
<span title="acronym" ><i>MG</i></span>
 type: 
<tt>PCMG</tt>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h5><a id="Fieldsplitpreconditioners">36.1.7.3.5</a> Field split preconditioners</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Preconditioners">Preconditioners</a> > <a href="petsc-solver.html#Types">Types</a> > <a href="petsc-solver.html#Fieldsplitpreconditioners">Field split preconditioners</a>
</p>

</p>

<p name="switchToTextMode">
For background refer to section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Multi-componentmatrices">33.4.7</a>
.
</p>

<h3><a id="Customization:monitoringandconvergencetests">36.1.8</a> Customization: monitoring and convergence tests</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a>
</p>
<p name="switchToTextMode">

PETSc solvers can do various 
<i>callback</i>
s to user functions.
</p>

<h5><a id="Shellpreconditioners">36.1.8.1.1</a> Shell preconditioners</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a>
</p>
<p name="switchToTextMode">

You already saw that,
in an iterative methods, the coefficient matrix can be given operationally
as a 
<i>shell matrix</i>
; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Shellmatrices">33.4.6</a>
.
Similarly, the preconditioner matrix can be specified operationally
by specifying type 
<tt>PCSHELL</tt>
.
</p>

<p name="switchToTextMode">
This needs specification of the application routine
through 
<tt>PCShellSetApply</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCShellSetApply(PC pc,PetscErrorCode (*apply)(PC,Vec,Vec));
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
and probably specification of a context pointer through
<tt>PCShellSetContext</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCShellSetContext(PC pc,void *ctx);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
The application function then retrieves this context with
<tt>PCShellGetContext</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCShellGetContext(PC pc,void **ctx);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

If the shell preconditioner requires setup, a&nbsp;routine for this can be specified with
<tt>PCShellSetSetUp</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCShellSetSetUp(PC pc,PetscErrorCode (*setup)(PC));
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h5><a id="Combiningpreconditioners">36.1.8.1.2</a> Combining preconditioners</h5>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a>
</p>
</p>

<p name="switchToTextMode">
It is possible to combine preconditioners with 
<tt>PCCOMPOSITE</tt>
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCSetType(pc,PCCOMPOSITE);
PCCompositeAddPC(pc,type1);
PCCompositeAddPC(pc,type2);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
By default, the preconditioners are applied additively;
for multiplicative application
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCCompositeSetType(PC pc,PCCompositeType PC_COMPOSITE_MULTIPLICATIVE);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Convergencetests">36.1.8.2</a> Convergence tests</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a> > <a href="petsc-solver.html#Convergencetests">Convergence tests</a>
</p>
</p>

<p name="switchToTextMode">
For instance, you can set your own convergence test with
<tt>KSPSetConvergenceTest</tt>
.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
KSPSetConvergenceTest
   (KSP ksp,
    PetscErrorCode (*test)(
        KSP ksp,PetscInt it,PetscReal rnorm,
        KSPConvergedReason *reason,void *ctx),
    void *ctx,PetscErrorCode (*destroy)(void *ctx));
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
This routines accepts
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
the custom stopping test function,
<li>
a `context' void pointer to pass information to the tester, and
<li>
optionally a custom destructor for the context information.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
By default, PETSc behaves as if this function has been called with
<tt>KSPConvergedDefault</tt>
 as argument.
</p>

<h4><a id="Convergencemonitoring">36.1.8.3</a> Convergence monitoring</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a> > <a href="petsc-solver.html#Convergencemonitoring">Convergence monitoring</a>
</p>
<p name="switchToTextMode">

There is also a callback for monitoring each iteration.
It can be set with 
<tt>KSPMonitorSet</tt>
.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
KSPMonitorSet
   (KSP ksp,
    PetscErrorCode (*mon)(
        KSP ksp,PetscInt it,PetscReal rnorm,void *ctx),
    void *ctx,PetscErrorCode (*mondestroy)(void**));
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
By default no monitor is set, meaning that the iteration process
runs without output.
The option 
<tt>ksp_monitor</tt>
 activates printing
a norm of the residual.
This corresponds to setting 
<tt>KSPMonitorDefault</tt>
as the monitor.
</p>

<p name="switchToTextMode">
This actually outputs the `preconditined norm' of the residual,
which is not the L2 norm, but the square root of&nbsp;$r^tM\inv r$,
a&nbsp;quantity that is computed in the course of the iteration process.
Specifying 
<tt>KSPMonitorTrueResidualNorm</tt>
(with corresponding option 
<tt>ksp_monitor_true_residual</tt>
)
as the monitor prints the actual norm&nbsp;$\sqrt{r^tr}$.
However, to compute this involves extra computation,
since this quantity is not normally computed.
</p>

<h4><a id="Auxiliaryroutines">36.1.8.4</a> Auxiliary routines</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#KSP:linearsystemsolvers">KSP: linear system solvers</a> > <a href="petsc-solver.html#Customization:monitoringandconvergencetests">Customization: monitoring and convergence tests</a> > <a href="petsc-solver.html#Auxiliaryroutines">Auxiliary routines</a>
</p>
<p name="switchToTextMode">

<tt>KSPGetSolution</tt>
<tt>KSPGetRhs</tt>
<tt>KSPBuildSolution</tt>
<tt>KSPBuildResidual</tt>
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
KSPGetSolution(KSP ksp,Vec *x);
KSPGetRhs(KSP ksp,Vec *rhs);
KSPBuildSolution(KSP ksp,Vec w,Vec *v);
KSPBuildResidual(KSP ksp,Vec t,Vec w,Vec *v);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Directsolvers">36.2</a> Direct solvers</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#Directsolvers">Direct solvers</a>
</p>

</p>

<p name="switchToTextMode">
PETSc has some support for direct solvers, that is, variants of LU
decomposition. In a sequential context, the 
<tt>PCLU</tt>

preconditioner can be use for this: a direct solver is equivalent to
an iterative method that stops after one preconditioner
application. This can be forced by specifying a KSP type of

<tt>KSPPREONLY</tt>
.
</p>

<p name="switchToTextMode">
Distributed direct solvers are more complicated. PETSc does not have
this implemented in its basic code, but it becomes available by
configuring PETSc with the
<i>scalapack</i>
 library.
</p>

<p name="switchToTextMode">
You need to specify which package provides the LU factorization:
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PCFactorSetMatSolverType(pc, MatSolverType solver )
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

where the solver variable is of type 
<tt>MatSolverType</tt>
,
and can be 
<tt>MATSOLVERMUMS</tt>
 and such when specified in source:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#petscmumps" aria-expanded="false" aria-controls="petscmumps">
        C Code: petscmumps
      </button>
    </h5>
  </div>
  <div id="petscmumps" class="collapse">
  <pre>
// direct.c
ierr = KSPCreate(comm,&Solver);
ierr = KSPSetOperators(Solver,A,A); CHKERRQ(ierr);
ierr = KSPSetType(Solver,KSPPREONLY); CHKERRQ(ierr);
{
  PC Prec;
  ierr = KSPGetPC(Solver,&Prec); CHKERRQ(ierr);
  ierr = PCSetType(Prec,PCLU); CHKERRQ(ierr);
  ierr = PCFactorSetMatSolverType(Prec,MATSOLVERMUMPS); CHKERRQ(ierr);
}
</pre>
</div>
</div>
As specified on the commandline
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
yourprog -ksp_type preonly -pc_type lu -pc_factor_mat_solver_type mumps
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
the choices are mumps, superlu, umfpack, or a number of
others.
Note that availability of these packages depends on how PETSc
was installed on your system.
</p>

<h2><a id="Controlthroughcommandlineoptions">36.3</a> Control through command line options</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-solver.html">petsc-solver</a> > <a href="petsc-solver.html#Controlthroughcommandlineoptions">Control through command line options</a>
</p>
<p name="switchToTextMode">

From the above you may get the impression that there are lots of calls
to be made to set up a PETSc linear system and solver. And what if you
want to experiment with different solvers, does that mean that you
have to edit a whole bunch of code? Fortunately, there is an easier
way to do things. If you call the routine
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#KSPSetFromOptions" aria-expanded="false" aria-controls="KSPSetFromOptions">
        Routine reference: KSPSetFromOptions
      </button>
    </h5>
  </div>
  <div id="KSPSetFromOptions" class="collapse">
  <pre>
Synopsis

#include "petscksp.h"
PetscErrorCode  KSPSetFromOptions(KSP ksp)

Collective on ksp

Input Parameters
ksp - the Krylov space context
</pre>
</div>
</div>
<i>KSPSetFromOptions</i>
with the 
<tt>solver</tt>
 as argument,
PETSc will look at your command line options and take those into
account in defining the solver. Thus, you can either omit setting
options in your source code, or use this as a way of quickly
experimenting with different possibilities. Example:
</p>

<!-- environment: verbatim start embedded generator -->
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
myprogram -ksp_max_it 200 \
    -ksp_type gmres -ksp_type_gmres_restart 20  \
    -pc_type ilu -pc_type_ilu_levels 3
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

</div>
<a href="index.html">Back to Table of Contents</a>
