<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src=https://ccrs.cac.cornell.edu:8443/client.0.2.js></script>
<script id="script">
class Example {
  constructor(buttonID, editorID, outputID, sourceFile, fileName, commandStr) {
    this.buttonID = buttonID;
    this.editorID = editorID;
    this.outputID = outputID;
    this.sourceFile = sourceFile;
    this.fileName = fileName;
    this.commandStr = commandStr;
  }
    
  async display(results, object) {
    if (results.stdout.length > 0)
      document.getElementById(object.outputID).textContent = results.stdout;
    else
      document.getElementById(object.outputID).textContent = results.stderr;
  }

  async initialize() {
    this.editor = await MonacoEditorFileSource.create(this.editorID);
    this.editor.setTextFromFile(this.sourceFile);
    this.job = await Job.create(JobType.MPI);
    this.command = new CommandWithFiles(this.job, this.commandStr);
    this.command.addFileSource(this.editor, this.fileName);
    this.trigger = new ButtonTrigger(this.command, this.display, this.buttonID, this);
    document.getElementById(this.buttonID).disabled = false;
  }
}
</script>
<style></style>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>PETSc objects</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


33.1 : <a href="petsc-objects.html#Distributedobjects">Distributed objects</a><br>
33.1.1 : <a href="petsc-objects.html#Supportfordistributions">Support for distributions</a><br>
33.2 : <a href="petsc-objects.html#Scalars">Scalars</a><br>
33.2.1 : <a href="petsc-objects.html#Integers">Integers</a><br>
33.2.2 : <a href="petsc-objects.html#Complex">Complex</a><br>
33.2.3 : <a href="petsc-objects.html#MPIScalars">MPI Scalars</a><br>
33.2.4 : <a href="petsc-objects.html#Booleans">Booleans</a><br>
33.3 : <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a><br>
33.3.1 : <a href="petsc-objects.html#Vectorconstruction">Vector construction</a><br>
33.3.2 : <a href="petsc-objects.html#Vectorlayout">Vector layout</a><br>
33.3.3 : <a href="petsc-objects.html#Vectoroperations">Vector operations</a><br>
33.3.3.1 : <a href="petsc-objects.html#Splitcollectives">Split collectives</a><br>
33.3.4 : <a href="petsc-objects.html#Vectorelements">Vector elements</a><br>
33.3.4.1 : <a href="petsc-objects.html#Explicitelementaccess">Explicit element access</a><br>
33.3.5 : <a href="petsc-objects.html#FileIO">File I/O</a><br>
33.4 : <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a><br>
33.4.1 : <a href="petsc-objects.html#Matrixcreation">Matrix creation</a><br>
33.4.2 : <a href="petsc-objects.html#Nonzerostructure">Nonzero structure</a><br>
33.4.3 : <a href="petsc-objects.html#Matrixelements">Matrix elements</a><br>
33.4.3.1 : <a href="petsc-objects.html#Elementaccess">Element access</a><br>
33.4.4 : <a href="petsc-objects.html#Matrixoperations">Matrix operations</a><br>
33.4.4.1 : <a href="petsc-objects.html#Matrix-vectoroperations">Matrix-vector operations</a><br>
33.4.4.2 : <a href="petsc-objects.html#Matrix-matrixoperations">Matrix-matrix operations</a><br>
33.4.5 : <a href="petsc-objects.html#Submatrices">Submatrices</a><br>
33.4.6 : <a href="petsc-objects.html#Shellmatrices">Shell matrices</a><br>
33.4.6.1 : <a href="petsc-objects.html#Shelloperations">Shell operations</a><br>
33.4.6.2 : <a href="petsc-objects.html#Shellcontext">Shell context</a><br>
33.4.7 : <a href="petsc-objects.html#Multi-componentmatrices">Multi-component matrices</a><br>
33.4.8 : <a href="petsc-objects.html#Fouriertransform">Fourier transform</a><br>
33.5 : <a href="petsc-objects.html#IndexsetsandVectorScatters">Index sets and Vector Scatters</a><br>
33.5.1 : <a href="petsc-objects.html#IS:indexsets">IS: index sets</a><br>
33.5.2 : <a href="petsc-objects.html#VecScatter:all-to-alloperations">VecScatter: all-to-all operations</a><br>
33.5.2.1 : <a href="petsc-objects.html#MoreVecScattermodes">More VecScatter modes</a><br>
33.6 : <a href="petsc-objects.html#AO:ApplicationOrderings">AO: Application Orderings</a><br>
33.7 : <a href="petsc-objects.html#Partitionings">Partitionings</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>33 PETSc objects</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Distributedobjects">33.1</a> Distributed objects</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Distributedobjects">Distributed objects</a>
</p>
</p>

<p name="switchToTextMode">
PETSc is based on the 
<span title="acronym" ><i>SPMD</i></span>
 model, and all its objects act like
they exist in parallel, spread out over all the processes.  Therefore,
prior to discussing specific objects in detail, we briefly discuss how
PETSc treats distributed objects.
</p>

<p name="switchToTextMode">
For a matrix or vector you need to specify the size. This can be done two ways:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
you specify the global size and PETSc distributes the object over the processes, or
<li>
you specify on each process the local size
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
If you specify both the global size and the local sizes, PETSc will check for consistency.
</p>

<p name="switchToTextMode">
For example, if you have a vector of $N$ components, or a matrix of $N$
rows, and you have $P$ processes, each process will receive $N/P$
components or rows if $P$ divides evenly in~$N$. If $P$ does not divide
evenly, the excess is spread over the processes.
</p>

<img src="graphics/veclayout.jpg" width=800></img>
<p name="switchToTextMode">

The way the distribution is done is by contiguous blocks: with 10
processes and 1000 components in a vector, process 0 gets the range
$0\cdots99$, process 1 gets $1\cdots199$, et cetera. This simple scheme suffices for
many cases, but PETSc has facilities for more sophisticated load
balancing.
</p>

<h3><a id="Supportfordistributions">33.1.1</a> Support for distributions</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Distributedobjects">Distributed objects</a> > <a href="petsc-objects.html#Supportfordistributions">Support for distributions</a>
</p>
<p name="switchToTextMode">

Once an object has been created and distributed, you do not need to
remember the size or the distribution yourself: you can query these
with calls such as \clstinline{VecGetSize},
\clstinline{VecGetLocalSize}.
</p>

<p name="switchToTextMode">
The
corresponding matrix routines \clstinline{MatGetSize},
\clstinline{MatGetLocalSize} give both information for the
distributions in $i$ and~$j$ direction, which can be
independent. Since a matrix is distributed by rows,
\clstinline{MatGetOwnershipRange} only gives a row range.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#splitownersnip" aria-expanded="false" aria-controls="splitownersnip">
        C Code: splitownersnip
      </button>
    </h5>
  </div>
  <div id="splitownersnip" class="collapse">
  <pre>
// split.c
N = 100; n = PETSC_DECIDE;
PetscSplitOwnership(comm,&n,&N);
PetscPrintf(comm,"Global %d, local %d\n",N,n);

N = PETSC_DECIDE; n = 10;
PetscSplitOwnership(comm,&n,&N);
PetscPrintf(comm,"Global %d, local %d\n",N,n);
</pre>
</div>
</div>
<p name="switchToTextMode">

While PETSc objects are implemented using local memory on each
process, conceptually they act like global objects, with a global
indexing scheme. Thus, each process can query which elements out of
the global object are stored locally.
For vectors, the relevant routine is \clstinline{VecGetOwnershipRange},
which returns two parameters, \clstinline{low} and~\clstinline{high},
respectively the first element index stored, and
one-more-than-the-last index stored.
</p>

<p name="switchToTextMode">
This gives the idiom:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecGetOwnershipRange(myvector,&low,&high);
for (int myidx=low; myidx&lt;high; myidx++)
  // do something at index myidx
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

These conversions between local and global size can also be done
explicitly, using the 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#PetscSplitOwnership" aria-expanded="false" aria-controls="PetscSplitOwnership">
        Routine reference: PetscSplitOwnership
      </button>
    </h5>
  </div>
  <div id="PetscSplitOwnership" class="collapse">
  <pre>
PetscSplitOwnership

Synopsis
#include "petscsys.h"
PetscErrorCode  PetscSplitOwnership
   (MPI_Comm comm,PetscInt *n,PetscInt *N)

Collective (if n or N is PETSC_DECIDE)

Input Parameters
comm - MPI communicator that shares the object being divided
n - local length (or PETSC_DECIDE to have it set)
N - global length (or PETSC_DECIDE)
</pre>
</div>
</div>
<i>PetscSplitOwnership</i>
 routine.
This routine takes two parameter, for the local and global size, and
whichever one is initialized to 
<tt>PETSC_DECIDE</tt>
 gets
computed from the other.
</p>

<h2><a id="Scalars">33.2</a> Scalars</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Scalars">Scalars</a>
</p>

<p name="switchToTextMode">

Unlike programming languages that explicitly distinguish between
single and double precision numbers, PETSc has only a single scalar
type: 
<tt>PetscScalar</tt>
. The precision of this is determined
at installation time. In fact, a \clstinline{PetscScalar} can even be a
complex number if the installation specified that the scalar type is
complex.
</p>

<p name="switchToTextMode">
Even in applications that use complex numbers there can be quantities
that are real: for instance, the norm of a complex vector is a real
number. For that reason, PETSc also has the type
<tt>PetscReal</tt>
. There is also an explicit 
<tt>PetscComplex</tt>
.
</p>

<p name="switchToTextMode">
Furthermore, there is
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
#define PETSC_BINARY_INT_SIZE    (32/8)
#define PETSC_BINARY_FLOAT_SIZE  (32/8)
#define PETSC_BINARY_CHAR_SIZE   (8/8)
#define PETSC_BINARY_SHORT_SIZE  (16/8)
#define PETSC_BINARY_DOUBLE_SIZE (64/8)
#define PETSC_BINARY_SCALAR_SIZE sizeof(PetscScalar)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Integers">33.2.1</a> Integers</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Scalars">Scalars</a> > <a href="petsc-objects.html#Integers">Integers</a>
</p>
</p>

<p name="switchToTextMode">
Integers in PETSc are likewise of a size determined at installation
time: 
<tt>PetscInt</tt>
 can be 32 or 64 bits.
The latter possibility is useful for indexing into large vectors and matrices.
Furthermore,
there is a 
<tt>PetscErrorCode</tt>
 type for catching the return
code of PETSc routines; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-tools.html#Errorcodes">39.1.2</a>
.
</p>

<p name="switchToTextMode">
For compatibility with other packages there are two more integer types:
<!-- index -->
<!-- index -->
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>PetscBLASInt</tt>
 is the integer type used by the
<i>BLAS</i>
&nbsp;/ 
<i>LAPACK</i>
 library. This is 32-bits if the
<tt>-download-blas-lapack</tt>
 option is used, but it can be 64-bit if
<i>MKL</i>
 is used.
  The routine 
<tt>PetscBLASIntCast</tt>
 casts a
<tt>PetscInt</tt>
 to 
<tt>PetscBLASInt</tt>
, or returns
<tt>PETSC_ERR_ARG_OUTOFRANGE</tt>
 if it is too large.
<li>
<tt>PetscMPIInt</tt>
 is the integer type of the MPI library, which is
  always 32-bits.
  The routine 
<tt>PetscMPIIntCast</tt>
 casts a
<tt>PetscInt</tt>
 to 
<tt>PetscMPIInt</tt>
, or returns
<tt>PETSC_ERR_ARG_OUTOFRANGE</tt>
 if it is too large.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Many external packages do not support 64-bit integers.
</p>

<h3><a id="Complex">33.2.2</a> Complex</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Scalars">Scalars</a> > <a href="petsc-objects.html#Complex">Complex</a>
</p>
<p name="switchToTextMode">

Numbers of type 
<tt>PetscComplex</tt>
 have a precision
matching 
<tt>PetscReal</tt>
.
</p>

<p name="switchToTextMode">
Form a complex number using 
<tt>PETSC_i</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscComplex x = 1.0 + 2.0 * PETSC_i;
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

The real and imaginary part can be extract with the functions
<tt>PetscRealPart</tt>
 and 
<tt>PetscImaginaryPart</tt>
which return a 
<tt>PetscReal</tt>
.
</p>

<p name="switchToTextMode">
There are also routines 
<tt>VecRealPart</tt>
and 
<tt>VecImaginaryPart</tt>
 that replace a vector
with its real or imaginary part respectively.
Likewise 
<tt>MatRealPart</tt>
 and 
<tt>MatImaginaryPart</tt>
.
</p>

<h3><a id="MPIScalars">33.2.3</a> MPI Scalars</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Scalars">Scalars</a> > <a href="petsc-objects.html#MPIScalars">MPI Scalars</a>
</p>
<p name="switchToTextMode">

For MPI calls, 
<tt>MPIU_REAL</tt>
 is the MPI type
corresponding to the current 
<tt>PetscReal</tt>
.
</p>

<p name="switchToTextMode">
For MPI calls, 
<tt>MPIU_SCALAR</tt>
 is the MPI type
corresponding to the current 
<tt>PetscScalar</tt>
.
</p>

<p name="switchToTextMode">
For MPI calls, 
<tt>MPIU_COMPLEX</tt>
 is the MPI type
corresponding to the current 
<tt>PetscComplex</tt>
.
</p>

<h3><a id="Booleans">33.2.4</a> Booleans</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Scalars">Scalars</a> > <a href="petsc-objects.html#Booleans">Booleans</a>
</p>
<p name="switchToTextMode">

There is a 
<tt>PetscBool</tt>
 datatype
with values 
<tt>PETSC_TRUE</tt>
 and 
<tt>PETSC_FALSE</tt>
.
</p>

<h2><a id="Vec:Vectors">33.3</a> Vec: Vectors</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a>
</p>
<p name="switchToTextMode">

Vectors are objects with a linear index. The elements of a vector are
floating point numbers or complex numbers (see
section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Scalars">33.2</a>
), but not integers: for that see
section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#IS:indexsets">33.5.1</a>
.
</p>

<h3><a id="Vectorconstruction">33.3.1</a> Vector construction</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectorconstruction">Vector construction</a>
</p>
<p name="switchToTextMode">

Constructing a vector takes a number of steps. First of all, the
vector object needs
to be created on a communicator with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecCreate" aria-expanded="false" aria-controls="VecCreate">
        Routine reference: VecCreate
      </button>
    </h5>
  </div>
  <div id="VecCreate" class="collapse">
  <pre>
C:
PetscErrorCode VecCreate(MPI_Comm comm,Vec *v);

F:
VecCreate( comm,v,ierr )
MPI_Comm :: comm
Vec      :: v
PetscErrorCode :: ierr

Python:
vec = PETSc.Vec()
vec.create()
# or:
vec = PETSc.Vec().create()

</pre>
</div>
</div>
<i>VecCreate</i>
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  In python, \plstinline{PETSc.Vec()} creates an object with null handle, so a
  subsequent \plstinline{create()} call is needed.
  In C and Fortran, the vector type is a keyword; in Python it is a
  member of 
<tt>PETSc.Vec.Type</tt>
.
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

The corresponding routine 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecDestroy" aria-expanded="false" aria-controls="VecDestroy">
        Routine reference: VecDestroy
      </button>
    </h5>
  </div>
  <div id="VecDestroy" class="collapse">
  <pre>
Synopsis
#include "petscvec.h"
PetscErrorCode  VecDestroy(Vec *v)

Collective on Vec

Input Parameters:
v -the vector
</pre>
</div>
</div>
<i>VecDestroy</i>
 deallocates data and zeros
the pointer.
(This and all other Destroy routines are collective because of underlying
MPI technicalities.)
</p>

<p name="switchToTextMode">
The vector type needs to be set with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecSetType" aria-expanded="false" aria-controls="VecSetType">
        Routine reference: VecSetType
      </button>
    </h5>
  </div>
  <div id="VecSetType" class="collapse">
  <pre>
Synopsis:
#include "petscvec.h"
PetscErrorCode VecSetType(Vec vec, VecType method)

Collective on Vec

Input Parameters:
vec- The vector object
method- The name of the vector type

Options Database Key
-vec_type <type> -Sets the vector type; use -help for a list of available types
</pre>
</div>
</div>
<i>VecSetType</i>
.
</p>

<p name="switchToTextMode">
The most common vector types are:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>VECSEQ</tt>
 for sequential vectors, that is, living on a single process;
  This is typically created on the 
<tt>MPI_COMM_SELF</tt>
 or
<tt>PETSC_COMM_SELF</tt>
 communicator.
<li>
<tt>VECMPI</tt>
 for a vector distributed over the communicator.
  This is typically created on the 
<tt>MPI_COMM_WORLD</tt>
 or
<tt>PETSC_COMM_WORLD</tt>
 communicator, or one derived from it.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Once you have created one vector, you can make more like it by
<tt>VecDuplicate</tt>
,
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecDuplicate(Vec old,Vec *new);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
or 
<tt>VecDuplicateVecs</tt>
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecDuplicateVecs(Vec old,PetscInt n,Vec **new);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
for multiple vectors.
For the latter, there is a joint destroy call
<tt>VecDestroyVecs</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecDestroyVecs(PetscInt n,Vec **vecs);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
(which is different in Fortran).
</p>

<h3><a id="Vectorlayout">33.3.2</a> Vector layout</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectorlayout">Vector layout</a>
</p>
<p name="switchToTextMode">

Next in the creation process the vector size is set with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecSetSizes" aria-expanded="false" aria-controls="VecSetSizes">
        Routine reference: VecSetSizes
      </button>
    </h5>
  </div>
  <div id="VecSetSizes" class="collapse">
  <pre>
C:
#include "petscvec.h"
PetscErrorCode  VecSetSizes(Vec v, PetscInt n, PetscInt N)
Collective on Vec

Input Parameters
v :the vector
n : the local size (or PETSC_DECIDE to have it set)
N : the global size (or PETSC_DECIDE)

Python:
PETSc.Vec.setSizes(self, size, bsize=None)
size is a tuple of local/global
</pre>
</div>
</div>
<i>VecSetSizes</i>
.
Since a
vector is typically distributed, this involves the global size and the
sizes on the processors. Setting both is redundant, so it is possible
to specify one and let the other be computed by the library. This is
indicated by setting it to 
<tt>PETSC_DECIDE</tt>
(\plstinline{PETSc.DECIDE} in python).
</p>

<p name="switchToTextMode">
The size is queried with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecGetSize" aria-expanded="false" aria-controls="VecGetSize">
        Routine reference: VecGetSize
      </button>
    </h5>
  </div>
  <div id="VecGetSize" class="collapse">
  <pre>
VecGetSize / VecGetLocalSize

C:
#include "petscvec.h"
PetscErrorCode  VecGetSize(Vec x,PetscInt *gsize)
PetscErrorCode  VecGetLocalSize(Vec x,PetscInt *lsize)

Input Parameter
x -the vector

Output Parameters
gsize - the global length of the vector
lsize - the local length of the vector

Python:
PETSc.Vec.getLocalSize(self)
PETSc.Vec.getSize(self)
PETSc.Vec.getSizes(self)
</pre>
</div>
</div>
<i>VecGetSize</i>
 for the global size
and 
</p>

<p name="switchToTextMode">
Each processor gets a contiguous part of the vector. Use
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecGetOwnershipRange" aria-expanded="false" aria-controls="VecGetOwnershipRange">
        Routine reference: VecGetOwnershipRange
      </button>
    </h5>
  </div>
  <div id="VecGetOwnershipRange" class="collapse">
  <pre>
#include "petscvec.h"
PetscErrorCode  VecGetOwnershipRange(Vec x,PetscInt *low,PetscInt *high)

Input parameter:
x - the vector

Output parameters:
low  - the first local element, pass in NULL if not interested
high - one more than the last local element, pass in NULL if not interested

Fortran note:
use PETSC_NULL_INTEGER for NULL.
</pre>
</div>
</div>
<i>VecGetOwnershipRange</i>
 to query the first index on this
process, and the first one of the next process.
</p>

<p name="switchToTextMode">
In general it is best to let PETSc take care of memory management of
matrix and vector objects, including allocating and freeing the memory.
However, in cases where PETSc interfaces to other applications it maybe desirable
to create a \clstinline{Vec} object from an already
allocated array: 
<tt>VecCreateSeqWithArray</tt>
 and
<tt>VecCreateMPIWithArray</tt>
.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecCreateSeqWithArray
   (MPI_Comm comm,PetscInt bs,
    PetscInt n,PetscScalar *array,Vec *V);
VecCreateMPIWithArray
   (MPI_Comm comm,PetscInt bs,
    PetscInt n,PetscInt N,PetscScalar *array,Vec *vv);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

As you will see in section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Matrixcreation">33.4.1</a>
,
you can also create vectors based on the layout of a matrix,
using 
<tt>MatCreateVecs</tt>
.
</p>

<h3><a id="Vectoroperations">33.3.3</a> Vector operations</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectoroperations">Vector operations</a>
</p>
<p name="switchToTextMode">

There are many routines operating on vectors that you need
to write scientific applications. Examples are: norms, vector addition
(including 
<span title="acronym" ><i>BLAS</i></span>
-type `AXPY' routines: 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecAXPY" aria-expanded="false" aria-controls="VecAXPY">
        Routine reference: VecAXPY
      </button>
    </h5>
  </div>
  <div id="VecAXPY" class="collapse">
  <pre>
Synopsis:
#include "petscvec.h"
PetscErrorCode  VecAXPY(Vec y,PetscScalar alpha,Vec x)

Not collective on Vec

Input Parameters:
alpha - the scalar
x, y  - the vectors

Output Parameter:
y - output vector
</pre>
</div>
</div>
<i>VecAXPY</i>
),
pointwise scaling, inner products.
A&nbsp;large number of such operations are available in PETSc through
single function calls to {VecXYZ} routines.
</p>

<p name="switchToTextMode">
For debugging purpoases,
the 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecView" aria-expanded="false" aria-controls="VecView">
        Routine reference: VecView
      </button>
    </h5>
  </div>
  <div id="VecView" class="collapse">
  <pre>
C:
#include "petscvec.h"
PetscErrorCode  VecView(Vec vec,PetscViewer viewer)

for ascii output use:
PETSC_VIEWER_STDOUT_WORLD

Python:
PETSc.Vec.view(self, Viewer viewer=None)

ascii output is default or use:
PETSc.Viewer.STDOUT(type cls, comm=None)
</pre>
</div>
</div>
<i>VecView</i>
 routine can be used to display vectors on screen as
ascii output,
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vecviewbeforeafter" aria-expanded="false" aria-controls="vecviewbeforeafter">
        C Code: vecviewbeforeafter
      </button>
    </h5>
  </div>
  <div id="vecviewbeforeafter" class="collapse">
  <pre>
// fftsine.c
ierr = VecView(signal,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
ierr = MatMult(transform,signal,frequencies); CHKERRQ(ierr);
ierr = VecScale(frequencies,1./Nglobal); CHKERRQ(ierr);
ierr = VecView(frequencies,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
</pre>
</div>
</div>
but the routine call also use more general \clstinline{PetscViewer} objects, for
instance to dump a vector to file.
</p>

<p name="switchToTextMode">
Here are a couple of representative vector routines:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscReal lambda;
ierr = VecNorm(y,NORM_2,&lambda); CHKERRQ(ierr);
ierr = VecScale(y,1./lambda); CHKERRQ(ierr);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Create a vector where the values are a single sine wave.
  using 
<tt>VecGetSize</tt>
, 
<tt>VecGetLocalSize</tt>
,
<tt>VecGetOwnershipRange</tt>
.
  Quick visual inspection:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
ibrun vec -n 12 -vec_view
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<!-- skeleton start: vec -->
<button id="runBtnvec">Compile and run vec</button>
<div id="editorDivvec" 
     style="height:125px;border:1px solid black; 
     resize:vertical; overflow: hidden;"></div>
<pre id="outputPrevec"></pre>
<script name="defSkeletonvec">
let examplevec = new Example("runBtnvec",
    "editorDivvec", "outputPrevec", 
    "skeletons/vec.c", "vec.c",
    "mpicc vec.c && mpiexec -n 4 ./a.out" );
examplevec.initialize();
</script>
<!-- skeleton end: vec -->
</exercise>
<!-- environment: exercise end embedded generator -->
<!-- environment: answer start embedded generator -->
<!-- environment block purpose: [[ environment=answer ]] -->
<answer>


</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
Use the routines 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecDot" aria-expanded="false" aria-controls="VecDot">
        Routine reference: VecDot
      </button>
    </h5>
  </div>
  <div id="VecDot" class="collapse">
  <pre>
Synopsis:
#include "petscvec.h"
PetscErrorCode VecDot(Vec x,Vec y,PetscScalar *val)

Collective on Vec

Input Parameters:
x, y - the vectors

Output Parameter:
val - the dot product
</pre>
</div>
</div>
<i>VecDot</i>
, 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecScale" aria-expanded="false" aria-controls="VecScale">
        Routine reference: VecScale
      </button>
    </h5>
  </div>
  <div id="VecScale" class="collapse">
  <pre>
Synopsis:
#include "petscvec.h"
PetscErrorCode VecScale(Vec x, PetscScalar alpha)

Not collective on Vec

Input Parameters:
x     - the vector
alpha - the scalar

Output Parameter:
x - the scaled vector
</pre>
</div>
</div>
<i>VecScale</i>
and 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecNorm" aria-expanded="false" aria-controls="VecNorm">
        Routine reference: VecNorm
      </button>
    </h5>
  </div>
  <div id="VecNorm" class="collapse">
  <pre>
C:
#include "petscvec.h"
PetscErrorCode  VecNorm(Vec x,NormType type,PetscReal *val)
where type is
    NORM_1, NORM_2, NORM_FROBENIUS, NORM_INFINITY

Python:
PETSc.Vec.norm(self, norm_type=None)

where norm is variable in PETSc.NormType:
    NORM_1, NORM_2, NORM_FROBENIUS, NORM_INFINITY or
    N1, N2, FRB, INF
</pre>
</div>
</div>
<i>VecNorm</i>
 to compute the inner product of vectors

<tt>x,y</tt>
, scale the vector&nbsp;
<tt>x</tt>
, and check its norm:
\[
\begin{array}{l}
p \leftarrow x^ty\\
x \leftarrow x/p\\
n \leftarrow \|x\|_2\\
\end{array}
\]
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- environment: pythonnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  The plus operator is overloaded so that
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
    x+y
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
  is defined.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
    x.sum() # max,min,....
    x.dot(y)
    x.norm(PETSc.NormType.NORM_INFINITY)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Splitcollectives">33.3.3.1</a> Split collectives</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectoroperations">Vector operations</a> > <a href="petsc-objects.html#Splitcollectives">Split collectives</a>
</p>
</p>

<p name="switchToTextMode">
MPI is capable (in principle) of `overlapping computation and communication',
or 
<i>latency hiding</i>
. PETSc supports this
by splitting norms and inner products into two phases.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Start inner product&nbsp;/ norm with 
<tt>VecDotBegin</tt>
&nbsp;/
<tt>VecNormBegin</tt>
;
<li>
Conclude inner product&nbsp;/ norm with 
<tt>VecDotEnd</tt>
&nbsp;/
<tt>VecNormEnd</tt>
;
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Even if you achieve no overlap, it is possible to use these calls to
combine a number of `collectives': do the 
<tt>Begin</tt>
 calls of one inner
product and one norm; then do (in the same sequence) the 
<tt>End</tt>
 calls.
This means that only a single reduction is performed on a two-word
package, rather than two separate reductions on a single word.
</p>

<h3><a id="Vectorelements">33.3.4</a> Vector elements</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectorelements">Vector elements</a>
</p>
<p name="switchToTextMode">

Setting elements of a traditional array is simple. Setting elements of
a distributed array is harder.
First of all, 
<tt>VecSet</tt>
 sets the vector to a constant value:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
ierr = VecSet(x,1.); CHKERRQ(ierr);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

In the general case, setting elements in a PETSc vector is done
through a
function 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecSetValue" aria-expanded="false" aria-controls="VecSetValue">
        Routine reference: VecSetValue
      </button>
    </h5>
  </div>
  <div id="VecSetValue" class="collapse">
  <pre>
Synopsis
#include <petscvec.h>
PetscErrorCode VecSetValue
   (Vec v,PetscInt row,PetscScalar value,InsertMode mode);

Not Collective

Input Parameters
v- the vector
row- the row location of the entry
value- the value to insert
mode- either INSERT_VALUES or ADD_VALUES
</pre>
</div>
</div>
<i>VecSetValue</i>
 for setting elements that uses global numbering; any
process can set any elements in the vector.
There is also a routine 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecSetValues" aria-expanded="false" aria-controls="VecSetValues">
        Routine reference: VecSetValues
      </button>
    </h5>
  </div>
  <div id="VecSetValues" class="collapse">
  <pre>
Synopsis
#include "petscvec.h"
PetscErrorCode  VecSetValues
   (Vec x,PetscInt ni,const PetscInt
    ix[],const PetscScalar y[],InsertMode iora)

Not Collective

Input Parameters:
x - vector to insert in
ni - number of elements to add
ix - indices where to add
y - array of values
iora - either INSERT_VALUES or ADD_VALUES, where
    ADD_VALUES adds values to any existing entries, and
    INSERT_VALUES replaces existing entries with new values
</pre>
</div>
</div>
<i>VecSetValues</i>
 for setting
multiple elements. This is mostly useful for setting dense subblocks
of a block matrix.
</p>

<p name="switchToTextMode">
We illustrate both routines by setting a single element with 
<tt>VecSetValue</tt>
,
and two elements with 
<tt>VecSetValues</tt>
. In the latter case
we need an array of length two for both the indices and values. The indices need
not be successive.
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
i = 1; v = 3.14;
VecSetValue(x,i,v,INSERT_VALUES);
ii[0] = 1; ii[1] = 2; vv[0] = 2.7; vv[1] = 3.1;
VecSetValues(x,2,ii,vv,INSERT_VALUES);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
call VecSetValue(x,i,v,INSERT_VALUES,ierr)
ii(1) = 1; ii(2) = 2; vv(1) = 2.7; vv(2) = 3.1
call VecSetValues(x,2,ii,vv,INSERT_VALUES,ierr)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Using \clstinline{VecSetValue} for specifying a local vector element
corresponds to simple insertion in the local array. However,
an element that belongs to another process needs to be
transferred. This done in two calls: 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecAssemblyBegin" aria-expanded="false" aria-controls="VecAssemblyBegin">
        Routine reference: VecAssemblyBegin
      </button>
    </h5>
  </div>
  <div id="VecAssemblyBegin" class="collapse">
  <pre>
#include "petscvec.h"
PetscErrorCode  VecAssemblyBegin(Vec vec)
PetscErrorCode  VecAssemblyEnd(Vec vec)

Collective on Vec

Input Parameter
vec -the vector

</pre>
</div>
</div>
<i>VecAssemblyBegin</i>
and 
<tt>VecAssemblyEnd</tt>
.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vecsetfrom0" aria-expanded="false" aria-controls="vecsetfrom0">
        Fortran Code: vecsetfrom0
      </button>
    </h5>
  </div>
  <div id="vecsetfrom0" class="collapse">
  <pre>
if (myrank==0) then
   do vecidx=0,globalsize-1
      vecelt = vecidx
      call VecSetValue(vector,vecidx,vecelt,INSERT_VALUES,ierr)
   end do
end if
call VecAssemblyBegin(vector,ierr)
call VecAssemblyEnd(vector,ierr)
</pre>
</div>
</div>
<p name="switchToTextMode">

(If you know the MPI library, you'll recognize that the first call corresponds to
posting nonblocking send and receive calls; the second then contains
the wait calls. Thus, the existence of these separate calls make
<i>latency hiding</i>
 possible.)
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
VecAssemblyBegin(myvec);
// do work that does not need the vector myvec
VecAssemblyEnd(myvec);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Elements can either be inserted
with 
<tt>INSERT_VALUES</tt>
,
or added with 
<tt>ADD_VALUES</tt>
 in the
<tt>VecSetValue</tt>
&nbsp;/ 
<tt>VecSetValues</tt>
 call.
You can not immediately mix these modes; to do so you need to call
<tt>VecAssemblyBegin</tt>
&nbsp;/ 
<tt>VecAssemblyEnd</tt>
in between add/insert phases.
</p>

<h4><a id="Explicitelementaccess">33.3.4.1</a> Explicit element access</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#Vectorelements">Vector elements</a> > <a href="petsc-objects.html#Explicitelementaccess">Explicit element access</a>
</p>
<p name="switchToTextMode">

Since the vector routines cover a large repertoire of operations, you
hardly ever need to access the actual elements. Should you still need
those elements, you can use 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecGetArray" aria-expanded="false" aria-controls="VecGetArray">
        Routine reference: VecGetArray
      </button>
    </h5>
  </div>
  <div id="VecGetArray" class="collapse">
  <pre>
C:
#include "petscvec.h"
PetscErrorCode VecGetArray(Vec x,PetscScalar **a)
PetscErrorCode VecGetArrayRead(Vec x,const PetscScalar **a)

Input Parameter
x : the vector

Output Parameter
a : location to put pointer to the array

PetscErrorCode VecRestoreArray(Vec x,PetscScalar **a)
PetscErrorCode VecRestoreArrayRead(Vec x,const PetscScalar **a)

Input Parameters
x : the vector
a : location of pointer to array obtained from VecGetArray()

Fortran90:
#include <petsc/finclude/petscvec.h>
use petscvec
VecGetArrayF90(Vec x,{Scalar, pointer :: xx_v(:)},integer ierr)
(there is a Fortran77 version)
VecRestoreArrayF90(Vec x,{Scalar, pointer :: xx_v(:)},integer ierr)

Python:
PETSc.Vec.getArray(self, readonly=False)
?? PETSc.Vec.resetArray(self, force=False)
</pre>
</div>
</div>
<i>VecGetArray</i>
 for general
access or 
</p>

<p name="switchToTextMode">
PETSc insists that you properly release this pointer again with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecRestoreArray" aria-expanded="false" aria-controls="VecRestoreArray">
        Routine reference: VecRestoreArray
      </button>
    </h5>
  </div>
  <div id="VecRestoreArray" class="collapse">
  <pre>
C:
#include "petscvec.h"
PetscErrorCode VecRestoreArray(Vec x,PetscScalar **a)

Logically Collective on Vec

Input Parameters:
x- the vector
a- location of pointer to array obtained from VecGetArray()

Fortran90:
#include <petsc/finclude/petscvec.h>
use petscvec
VecRestoreArrayF90(Vec x,{Scalar, pointer :: xx_v(:)},integer ierr)

Input Parameters:
x- vector
xx_v- the Fortran90 pointer to the array
</pre>
</div>
</div>
<i>VecRestoreArray</i>
 or
</p>

<p name="switchToTextMode">
Note that in a distributed running context you can only get the array
of local elements. Accessing the elements from another process
requires explicit communication; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#VecScatter:all-to-alloperations">33.5.2</a>
.
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscScalar *in_array,*out_array;
VecGetArrayRead(in,&in_array);
VecGetArray(out,&out_array);
VecGetLocalSize(in,&localsize);
for (int i=0; i&lt;localsize; i++)
  out_array[i] = 2*in_array[i];
VecRestoreArrayRead(in,&in_array);
VecRestoreArray(out,&out_array);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

There are some variants to the \clstinline{VecGetArray} operation:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
  \clstinline{Vec} object, and replaces it with a different array. That
  latter array needs to be allocated with
<tt>PetscMalloc</tt>
.
<li>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecPlaceArray" aria-expanded="false" aria-controls="VecPlaceArray">
        Routine reference: VecPlaceArray
      </button>
    </h5>
  </div>
  <div id="VecPlaceArray" class="collapse">
  <pre>
Replace the storage of a vector by another array
Synopsis

#include "petscvec.h"
PetscErrorCode  VecPlaceArray(Vec vec,const PetscScalar array[])
PetscErrorCode  VecReplaceArray(Vec vec,const PetscScalar array[])

Input Parameters
vec   - the vector
array - the array
</pre>
</div>
</div>
<i>VecPlaceArray</i>
 also installs a new array in the
  vector, but it keeps the original array; this can be restored with
<tt>VecResetArray</tt>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Putting the array of one vector into another has a common application,
where you have a distributed vector, but want to apply PETSc operations
to its local section as if it were a sequential vector. In that case
you would create a sequential vector, and
<tt>VecPlaceArray</tt>
 the contents of the distributed vector
into it.
</p>

<!-- environment: fortrannote start embedded generator -->
<!-- environment block purpose: [[ environment=fortrannote ]] -->
<remark>
<b>Fortran note</b>
<p name="remark">
<!-- TranslatingLineGenerator fortrannote ['fortrannote'] -->
  There are routines such as 
<tt>VecGetArrayF90</tt>
  (with corresponding 
<tt>VecRestoreArrayF90</tt>
)
  that
  return a (Fortran) pointer to a one-dimensional array.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vecinspect90" aria-expanded="false" aria-controls="vecinspect90">
        Fortran Code: vecinspect90
      </button>
    </h5>
  </div>
  <div id="vecinspect90" class="collapse">
  <pre>
!! vecset.F90
  Vec            :: vector
  PetscScalar,dimension(:),pointer :: elements
  call VecGetArrayF90(vector,elements,ierr)
  write (msg,10) myrank,elements(1)
10 format("First element on process",i3,":",f7.4,"\n")
  call PetscSynchronizedPrintf(comm,msg,ierr)
  call PetscSynchronizedFlush(comm,PETSC_STDOUT,ierr)
  call VecRestoreArrayF90(vector,elements,ierr)
</pre>
</div>
</div>
</p name="remark">
</remark>
<!-- environment: fortrannote end embedded generator -->
<p name="switchToTextMode">
{F90 array access through pointer}
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
    x.getArray()
    x.getValues(3)
    x.getValues([1, 2])
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<h3><a id="FileIO">33.3.5</a> File I/O</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Vec:Vectors">Vec: Vectors</a> > <a href="petsc-objects.html#FileIO">File I/O</a>
</p>

</p>

<p name="switchToTextMode">
As mentioned above, 
<tt>VecView</tt>
 can be used for
displaying a vector on the terminal screen.
However, viewers are actually much more general.
As explained in section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-tools.html#Exportinginternaldatastructures">39.2.2</a>
,
they can also be used to export vector data, for instance to file.
</p>

<p name="switchToTextMode">
The converse operation, to load a vector that was exported in this manner,
is 
<tt>VecLoad</tt>
.
</p>

<p name="switchToTextMode">
Since these operations are each other's inverses,
usually you don't need to know the file format.
But just in case:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
PetscInt    VEC_FILE_CLASSID
PetscInt    number of rows
PetscScalar *values of all entries
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
That is, the file starts with a magic number, then the number of vector elements,
and subsequently all scalar values.
</p>

<h2><a id="Mat:Matrices">33.4</a> Mat: Matrices</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a>
</p>
<p name="switchToTextMode">

PETSc matrices come in a number of types, sparse and dense being the
most important ones. Another possibility is to have the matrix in
operation form, where only the action $y\leftarrow Ax$ is defined.
</p>

<h3><a id="Matrixcreation">33.4.1</a> Matrix creation</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixcreation">Matrix creation</a>
</p>

<p name="switchToTextMode">

Creating a matrix also starts by specifying a communicator on which
the matrix lives collectively:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatCreate" aria-expanded="false" aria-controls="MatCreate">
        Routine reference: MatCreate
      </button>
    </h5>
  </div>
  <div id="MatCreate" class="collapse">
  <pre>
C:
PetscErrorCode MatCreate(MPI_Comm comm,Mat *v);

Python:
mat = PETSc.Mat()
mat.create()
# or:
mat = PETSc.Mat().create()

</pre>
</div>
</div>
<i>MatCreate</i>
</p>

<p name="switchToTextMode">
Set the matrix type with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatSetType" aria-expanded="false" aria-controls="MatSetType">
        Routine reference: MatSetType
      </button>
    </h5>
  </div>
  <div id="MatSetType" class="collapse">
  <pre>
#include "petscmat.h"
PetscErrorCode  MatSetType(Mat mat, MatType matype)

Collective on Mat

Input Parameters:
mat- the matrix object
matype- matrix type

Options Database Key
-mat_type <method> -Sets the type; use -help for a list of available methods (for instance, seqaij)
</pre>
</div>
</div>
<i>MatSetType</i>
.  The main choices
are between sequential versus distributed and dense versus sparse,
giving types: 
<tt>MATMPIDENSE</tt>
, 
<tt>MATMPIAIJ</tt>
,
<tt>MATSEQDENSE</tt>
, 
<tt>MATSEQAIJ</tt>
.
</p>

<p name="switchToTextMode">
Distributed matrices are partitioned by block rows: each process
stores a 
<i>block row</i>
, that is, a contiguous set of matrix
rows. It stores all elements in that block row.
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/parallel-matrix.jpg" width=800></img>
<p name="caption">
FIGURE 33.1: Matrix partitioning by block rows
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
In order for a matrix-vector product to be executable, both the input
and output vector need to be partitioned conforming to the matrix.
</p>

<p name="switchToTextMode">
While for dense matrices the block row scheme is not scalable, for
matrices from 
<span title="acronym" ><i>PDEs</i></span>
 it makes sense. There, a subdivision by matrix
blocks would lead to many empty blocks.
</p>

<p name="switchToTextMode">
Just as with vectors, there is a local and global size; except that
that now applies to rows and columns.
Set sizes with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatSetSizes" aria-expanded="false" aria-controls="MatSetSizes">
        Routine reference: MatSetSizes
      </button>
    </h5>
  </div>
  <div id="MatSetSizes" class="collapse">
  <pre>
C:
#include "petscmat.h"
PetscErrorCode MatSetSizes(Mat A,
    PetscInt m, PetscInt n, PetscInt M, PetscInt N)

Input Parameters
A : the matrix
m : number of local rows (or PETSC_DECIDE)
n : number of local columns (or PETSC_DECIDE)
M : number of global rows (or PETSC_DETERMINE)
N : number of global columns (or PETSC_DETERMINE)

Python:
PETSc.Mat.setSizes(self, size, bsize=None)
where 'size' is a tuple of 2 global sizes
or a tuple of 2 local/global pairs
</pre>
</div>
</div>
<i>MatSetSizes</i>
and subsequently query them with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatSizes" aria-expanded="false" aria-controls="MatSizes">
        Routine reference: MatSizes
      </button>
    </h5>
  </div>
  <div id="MatSizes" class="collapse">
  <pre>
C:
#include "petscmat.h"
PetscErrorCode MatGetSize(Mat mat,PetscInt *m,PetscInt *n)
PetscErrorCode MatGetLocalSize(Mat mat,PetscInt *m,PetscInt *n)

Python:
PETSc.Mat.getSize(self) # tuple of global sizes
PETSc.Mat.getLocalSize(self) # tuple of local sizes
PETSc.Mat.getSizes(self) # tuple of local/global size tuples
</pre>
</div>
</div>
<i>MatSizes</i>
.
The concept of local column size is tricky:
since a process stores a full block row you may expect the local column size
to be the full matrix size, but that is not true.
The exact definition will be discussed later, but for square matrices it is a safe
strategy to let the local row and column size to be equal.
</p>

<p name="switchToTextMode">
Instead of querying a matrix size and creating vectors accordingly,
the routine 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatCreateVecs" aria-expanded="false" aria-controls="MatCreateVecs">
        Routine reference: MatCreateVecs
      </button>
    </h5>
  </div>
  <div id="MatCreateVecs" class="collapse">
  <pre>
Synopsis
Get vector(s) compatible with the matrix, i.e. with the same parallel layout

#include "petscmat.h"
PetscErrorCode MatCreateVecs(Mat mat,Vec *right,Vec *left)

Collective on Mat

Input Parameter
mat - the matrix

Output Parameter;
right 	- (optional) vector that the matrix can be multiplied against
left 	- (optional) vector that the matrix vector product can be stored in
</pre>
</div>
</div>
<i>MatCreateVecs</i>
 can be used.
(Sometimes this is even required; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Fouriertransform">33.4.8</a>
.)
</p>

<h3><a id="Nonzerostructure">33.4.2</a> Nonzero structure</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Nonzerostructure">Nonzero structure</a>
</p>
<p name="switchToTextMode">

In case of a dense matrix, once you have specified the size and the
number of MPI processes, it is simple to determine how much space PETSc
needs to allocate for the matrix. For a sparse matrix this is more
complicated, since the matrix can be anywhere between completely empty
and completely filled in. It would be possible to have a dynamic
approach where, as elements are specified, the space grows; however,
repeated allocations and re-allocations are inefficient. For this
reason PETSc puts a small burden on the programmer: you need to
specify a bound on how many elements the matrix will contain.
</p>

<p name="switchToTextMode">
We explain this by looking at some cases. First we consider a matrix
that only lives on a single process. You would then use
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatSeqAIJSetPreallocation" aria-expanded="false" aria-controls="MatSeqAIJSetPreallocation">
        Routine reference: MatSeqAIJSetPreallocation
      </button>
    </h5>
  </div>
  <div id="MatSeqAIJSetPreallocation" class="collapse">
  <pre>
#include "petscmat.h"
PetscErrorCode  MatSeqAIJSetPreallocation
  (Mat B,PetscInt nz,const PetscInt nnz[])
PetscErrorCode  MatMPIAIJSetPreallocation
  (Mat B,PetscInt d_nz,const PetscInt d_nnz[],
   PetscInt o_nz,const PetscInt o_nnz[])

Input Parameters

B - the matrix
nz/d_nz/o_nz - number of nonzeros per row in matrix or
    diagonal/off-diagonal portion of local submatrix
nnz/d_nnz/o_nnz - array containing the number of nonzeros in the various rows of
    the sequential matrix / diagonal / offdiagonal part of the local submatrix
    or NULL (PETSC_NULL_INTEGER in Fortran) if nz/d_nz/o_nz is used.

Python:
PETSc.Mat.setPreallocationNNZ(self, [nnz_d,nnz_o] )
PETSc.Mat.setPreallocationCSR(self, csr)
PETSc.Mat.setPreallocationDense(self, array)
</pre>
</div>
</div>
<i>MatSeqAIJSetPreallocation</i>
.  In
the case of a tridiagonal matrix you would specify that each row has
three elements:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatSeqAIJSetPreallocation(A,3, NULL);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

If the matrix is less regular you can use the third argument to give
an array of explicit row lengths:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int *rowlengths;
// allocate, and then:
for (int row=0; row&lt;nrows; row++)
  rowlengths[row] = // calculation of row length
MatSeqAIJSetPreallocation(A,NULL,rowlengths);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

In case of a distributed matrix you need to specify this bound with
respect to the block structure of the matrix. As illustrated in figure&nbsp;
33.2
,
a&nbsp;matrix has a diagonal part and an off-diagonal part.
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<iframe src="graphics/petscmat.pdf" width=800></iframe>
<p name="caption">
FIGURE 33.2: The diagonal and off-diagonal parts of a matrix
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
The diagonal part describes the matrix elements that couple elements of the
input and output vector that live on this process. The off-diagonal part contains the
matrix elements that are multiplied with elements not on this process, in order to compute
elements that do live on this process.
</p>

<p name="switchToTextMode">
The preallocation specification now has separate parameters for
these diagonal and off-diagonal parts:
with
you specify for both either a global upper bound on the number of nonzeros,
or a detailed listing of row lengths.
For the matrix of the 
<i>Laplace equation</i>
, this specification
would seem to be:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatMPIAIJSetPreallocation(A, 3, NULL, 2, NULL);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
However, this is only correct if the block structure from the parallel division
equals that from the lines in the domain.
In general it may be necessary to use values that are an overestimate.
It is then possible to contract the storage by copying the matrix.
</p>

<p name="switchToTextMode">
Specifying bounds on the number of nonzeros is often enough, and not too wasteful. However,
if many rows have fewer nonzeros than these bounds, a lot of space is
wasted. In that case you can replace the NULL arguments by an array
that lists for each row the number of nonzeros in that row.
</p>

<h3><a id="Matrixelements">33.4.3</a> Matrix elements</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixelements">Matrix elements</a>
</p>
<p name="switchToTextMode">

You can set a single matrix element with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatSetValue" aria-expanded="false" aria-controls="MatSetValue">
        Routine reference: MatSetValue
      </button>
    </h5>
  </div>
  <div id="MatSetValue" class="collapse">
  <pre>
C:
#include <petscmat.h>
PetscErrorCode MatSetValue(
    Mat m,PetscInt row,PetscInt col,PetscScalar value,InsertMode mode)

Input Parameters
m : the matrix
row : the row location of the entry
col : the column location of the entry
value : the value to insert
mode : either INSERT_VALUES or ADD_VALUES

Python:
PETSc.Mat.setValue(self, row, col, value, addv=None)
also supported:
A[row,col] = value
</pre>
</div>
</div>
<i>MatSetValue</i>
or a block of them, where you
supply a set of $i$&nbsp;and&nbsp;$j$ indices, using
<tt>MatSetValues</tt>
.
</p>

<p name="switchToTextMode">
After setting matrix elements, the matrix needs to be assembled. This
is where PETSc moves matrix elements to the right processor, if they
were specified elsewhere. As with vectors this takes two calls:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatAssemblyBegin" aria-expanded="false" aria-controls="MatAssemblyBegin">
        Routine reference: MatAssemblyBegin
      </button>
    </h5>
  </div>
  <div id="MatAssemblyBegin" class="collapse">
  <pre>
C:
#include "petscmat.h"
PetscErrorCode MatAssemblyBegin(Mat mat,MatAssemblyType type)
PetscErrorCode MatAssemblyEnd(Mat mat,MatAssemblyType type)

Input Parameters
mat- the matrix
type- type of assembly, either MAT_FLUSH_ASSEMBLY
    or MAT_FINAL_ASSEMBLY

Python:
assemble(self, assembly=None)
assemblyBegin(self, assembly=None)
assemblyEnd(self, assembly=None)

there is a class PETSc.Mat.AssemblyType:
FINAL = FINAL_ASSEMBLY = 0
FLUSH = FLUSH_ASSEMBLY = 1
</pre>
</div>
</div>
<i>MatAssemblyBegin</i>
and
which can be used to achieve 
<i>latency hiding</i>
.
</p>

<p name="switchToTextMode">
Elements can either be inserted
(
<tt>INSERT_VALUES</tt>
) or added
(
<tt>ADD_VALUES</tt>
).
You can not immediately mix these modes; to do so you need to call
<tt>MatAssemblyBegin</tt>
&nbsp;/ 
<tt>MatAssemblyEnd</tt>
with a value of 
<tt>MAT_FLUSH_ASSEMBLY</tt>
.
</p>

<p name="switchToTextMode">
PETSc sparse matrices are very flexible: you can create them empty and
then start adding elements. However, this is very inefficient in
execution since the 
<span title="acronym" ><i>OS</i></span>
 needs to reallocate the matrix every time
it grows a little. Therefore, PETSc has calls for the user to indicate
how many elements the matrix will ultimately contain.
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatSetOption(A, MAT_NEW_NONZERO_ALLOCATION_ERR, PETSC_FALSE)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Elementaccess">33.4.3.1</a> Element access</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixelements">Matrix elements</a> > <a href="petsc-objects.html#Elementaccess">Element access</a>
</p>
</p>

<p name="switchToTextMode">
If you absolutely need access to the matrix elements, there are
routines such as
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatGetRow" aria-expanded="false" aria-controls="MatGetRow">
        Routine reference: MatGetRow
      </button>
    </h5>
  </div>
  <div id="MatGetRow" class="collapse">
  <pre>
Synopsis:

#include "petscmat.h"
PetscErrorCode MatGetRow
   (Mat mat,PetscInt row,
    PetscInt *ncols,const PetscInt *cols[],const PetscScalar *vals[])
PetscErrorCode MatRestoreRow
   (Mat mat,PetscInt row,
    PetscInt *ncols,const PetscInt *cols[],const PetscScalar *vals[])

Input Parameters:
mat - the matrix
row - the row to get

Output Parameters
ncols - if not NULL, the number of nonzeros in the row
cols - if not NULL, the column numbers
vals - if not NULL, the values
</pre>
</div>
</div>
<i>MatGetRow</i>
.
With this, any process can request, using global row numbering,
the contents of a row that it owns.
(Requesting elements that are not local requires the
different mechanism of taking submatrices; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Submatrices">33.4.5</a>
.)
</p>

<p name="switchToTextMode">
Since PETSc is geared towards
<i>sparse matrices</i>
<!-- index -->
,
this returns not only the element values, but also the column numbers,
as well as the mere number of stored columns.
If any of these three return values are not needed, they can be
unrequested by setting the parameter passed to \clstinline{NULL}.
</p>

<p name="switchToTextMode">
PETSc insists that you properly release the row again with
</p>

<p name="switchToTextMode">
It is also possible to retrieve the full 
<span title="acronym" ><i>CRS</i></span>
 contents
of the local matrix with
<tt>MatDenseGetArray</tt>
,
<tt>MatDenseRestoreArray</tt>
,
<tt>MatSeqAIJGetArray</tt>
,
<tt>MatSeqAIJRestoreArray</tt>
.
(Routines 
are deprecated.)
</p>

<h3><a id="Matrixoperations">33.4.4</a> Matrix operations</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixoperations">Matrix operations</a>
</p>
<p name="switchToTextMode">

<h4><a id="Matrix-vectoroperations">33.4.4.1</a> Matrix-vector operations</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixoperations">Matrix operations</a> > <a href="petsc-objects.html#Matrix-vectoroperations">Matrix-vector operations</a>
</p>
</p>

<p name="switchToTextMode">
In the typical application of PETSc, solving large sparse linear
systems of equations with iterative methods, matrix-vector operations
are most important. Foremost there is the matrix-vector product
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatMult" aria-expanded="false" aria-controls="MatMult">
        Routine reference: MatMult
      </button>
    </h5>
  </div>
  <div id="MatMult" class="collapse">
  <pre>
Synopsis
#include "petscmat.h"
PetscErrorCode MatMult(Mat mat,Vec x,Vec y)
PetscErrorCode MatMultTranspose(Mat mat,Vec x,Vec y)

Neighbor-wise Collective on Mat

Input Parameters
mat - the matrix
x - the vector to be multiplied

Output Parameters
y - the result
</pre>
</div>
</div>
<i>MatMult</i>
 and the transpose product
(In the complex case, the transpose product is not the Hermitian
matrix product; for that use 
<tt>MatMultHermitianTranspose</tt>
.)
</p>

<p name="switchToTextMode">
For the 
<span title="acronym" ><i>BLAS</i></span>
<tt>gemv</tt>
 semantics
$y\leftarrow \alpha Ax + \beta y$,
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatMultAdd" aria-expanded="false" aria-controls="MatMultAdd">
        Routine reference: MatMultAdd
      </button>
    </h5>
  </div>
  <div id="MatMultAdd" class="collapse">
  <pre>
Synopsis
#include "petscmat.h"
PetscErrorCode MatMultAdd(Mat mat,Vec x,Vec y,Vec z)

Neighbor-wise Collective on Mat

Input Parameters
mat 	- the matrix
x, y 	- the vectors

Output Parameters
z -the result

Notes
The vectors x and z cannot be the same.
</pre>
</div>
</div>
<i>MatMultAdd</i>
 computes
$z\leftarrow Ax +y $.
</p>

<h4><a id="Matrix-matrixoperations">33.4.4.2</a> Matrix-matrix operations</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Matrixoperations">Matrix operations</a> > <a href="petsc-objects.html#Matrix-matrixoperations">Matrix-matrix operations</a>
</p>
<p name="switchToTextMode">

There is a number of matrix-matrix routines such as
<tt>MatMatMult</tt>
.
</p>

<h3><a id="Submatrices">33.4.5</a> Submatrices</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Submatrices">Submatrices</a>
</p>

<p name="switchToTextMode">

Given a parallel matrix, there are two routines for extracting submatrices:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>MatCreateSubMatrix</tt>
 creates a single parallel
  submatrix.
<li>
<tt>MatCreateSubMatrices</tt>
 creates a sequential
  submatrix on each process.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Shellmatrices">33.4.6</a> Shell matrices</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Shellmatrices">Shell matrices</a>
</p>

</p>

<p name="switchToTextMode">
In many scientific applications, a matrix stands for some operator,
and we are not intrinsically interested in the matrix elements, but
only in the action of the matrix on a vector. In fact, under certain
circumstances it is more convenient to implement a routine that
computes the matrix action than to construct the matrix explicitly.
</p>

<p name="switchToTextMode">
Maybe surprisingly, solving a linear system of equations can be
handled this way. The reason is that PETSc's iterative solvers
(section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#KSP:linearsystemsolvers">36.1</a>
) only need the matrix-times-vector (and perhaps
the matrix-transpose-times-vector) product.
</p>

<p name="switchToTextMode">
PETSc supports this mode of working. The routine 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatCreateShell" aria-expanded="false" aria-controls="MatCreateShell">
        Routine reference: MatCreateShell
      </button>
    </h5>
  </div>
  <div id="MatCreateShell" class="collapse">
  <pre>
#include "petscmat.h"
PetscErrorCode  MatCreateShell
   (MPI_Comm comm,
    PetscInt m,PetscInt n,PetscInt M,PetscInt N,
    void *ctx,Mat *A)

Collective

Input Parameters:
comm- MPI communicator
m- number of local rows (must be given)
n- number of local columns (must be given)
M- number of global rows (may be PETSC_DETERMINE)
N- number of global columns (may be PETSC_DETERMINE)
ctx- pointer to data needed by the shell matrix routines

Output Parameter:
A -the matrix
</pre>
</div>
</div>
<i>MatCreateShell</i>
declares the argument to be a matrix given in operator form.
</p>

<h4><a id="Shelloperations">33.4.6.1</a> Shell operations</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Shellmatrices">Shell matrices</a> > <a href="petsc-objects.html#Shelloperations">Shell operations</a>
</p>
<p name="switchToTextMode">

The next step is then to add the custom multiplication routine, which
will be invoked by 
<tt>MatMult</tt>
:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatShellSetOperation" aria-expanded="false" aria-controls="MatShellSetOperation">
        Routine reference: MatShellSetOperation
      </button>
    </h5>
  </div>
  <div id="MatShellSetOperation" class="collapse">
  <pre>
#include "petscmat.h"
PetscErrorCode MatShellSetOperation
   (Mat mat,MatOperation op,void (*g)(void))

Logically Collective on Mat

Input Parameters:
mat- the shell matrix
op- the name of the operation
g- the function that provides the operation.
</pre>
</div>
</div>
<i>MatShellSetOperation</i>
</p>

<p name="switchToTextMode">
The routine that implements the actual product should have the same
signature as 
<tt>MatMult</tt>
, accepting a matrix and two
vectors. The key to realizing your own product routine lies in the
`context' argument to the create routine. With
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatShellSetContext" aria-expanded="false" aria-controls="MatShellSetContext">
        Routine reference: MatShellSetContext
      </button>
    </h5>
  </div>
  <div id="MatShellSetContext" class="collapse">
  <pre>
Synopsis
#include "petscmat.h"
PetscErrorCode  MatShellSetContext(Mat mat,void *ctx)

Input Parameters
mat - the shell matrix
ctx - the context
</pre>
</div>
</div>
<i>MatShellSetContext</i>
 you pass a pointer to some
structure that contains all contextual information you need. In your
multiplication routine you then retrieve this with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MatShellGetContext" aria-expanded="false" aria-controls="MatShellGetContext">
        Routine reference: MatShellGetContext
      </button>
    </h5>
  </div>
  <div id="MatShellGetContext" class="collapse">
  <pre>
#include "petscmat.h"
PetscErrorCode  MatShellGetContext(Mat mat,void *ctx)

Not Collective

Input Parameter:
mat -the matrix, should have been created with MatCreateShell()

Output Parameter:
ctx -the user provided context
</pre>
</div>
</div>
<i>MatShellGetContext</i>
.
</p>

What operation is specified is determined by a keyword  <tt>MATOP_&lt;OP&gt;</tt> 
<p name="switchToTextMode">
where 
<tt>OP</tt>
 is the name of the matrix routine, minus the 
<tt>Mat</tt>
 part,
in all caps.
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatCreate(comm,&A);
MatSetSizes(A,localsize,localsize,matrix_size,matrix_size);
MatSetType(A,MATSHELL);
MatSetFromOptions(A);
MatShellSetOperation(A,MATOP_MULT,(void*)&mymatmult);
MatShellSetContext(A,(void*)Diag);
MatSetUp(A);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
(The call to 
<tt>MatSetSizes</tt>
 needs to come before 
<tt>MatSetType</tt>
.)
</p>

<h4><a id="Shellcontext">33.4.6.2</a> Shell context</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Shellmatrices">Shell matrices</a> > <a href="petsc-objects.html#Shellcontext">Shell context</a>
</p>
<p name="switchToTextMode">

Setting the context means passing a pointer (really: an address) to
some allocated structure
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
struct matrix_data mystruct;
MatShellSetContext( A, &mystruct );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

The routine signature
has this argument as a \clstinline{void*} but it's not necessary to
cast it to that. Getting the context means that a pointer to your
structure needs to be set
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
struct matrix_data *mystruct;
MatShellGetContext( A, &mystruct );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Somewhat confusingly, the Get routine also has a \clstinline{void*}
argument, even though it's really a pointer variable.
</p>

<h3><a id="Multi-componentmatrices">33.4.7</a> Multi-component matrices</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Multi-componentmatrices">Multi-component matrices</a>
</p>

<p name="switchToTextMode">

For multi-component physics problems there are essentially
two ways of storing the linear system
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
Grouping the physics equations together, or
<li>
grouping the domain nodes together.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">
In both cases this corresponds to a block matrix, but
for a problem of $N$ nodes and $3$ equations, the
respective structures are:
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
$3\times 3 $ blocks of size&nbsp;$N$, versus
<li>
$N\times N$&nbsp;blocks of size&nbsp;$3$.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">
The first case can be pictured as
\[
\begin{pmatrix}
  A_{00}&A_{01}&A_{02}\\ A_{10}&A_{11}&A_{12}\\ A_{20}&A_{21}&A_{22}\\
\end{pmatrix}
\]
and while it looks natural, there is a computational problem with it.
Preconditioners for such problems often look like
\[
\begin{pmatrix}
  A_{00}&\\ &A_{11}&\\ &&A_{22}\\
\end{pmatrix}
\quad\hbox{or}\quad
\begin{pmatrix}
  A_{00}&&\\ A_{10}&A_{11}&\\ A_{20}&A_{21}&A_{22}\\
\end{pmatrix}
\]
With the block-row partitioning of PETSc's matrices, this means
at most a 50\% efficiency for the preconditioner solve.
</p>

<p name="switchToTextMode">
It is better to use the second scheme, which requires the
<tt>MATMPIBIJ</tt>
 format,
and use so-called 
<i>field-split preconditioner</i>
s;
see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-solver.html#Fieldsplitpreconditioners">36.1.7.3.5</a>
.
</p>

<h3><a id="Fouriertransform">33.4.8</a> Fourier transform</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Mat:Matrices">Mat: Matrices</a> > <a href="petsc-objects.html#Fouriertransform">Fourier transform</a>
</p>

<p name="switchToTextMode">

The 
<i>FFT</i>
 can be considered a matrix-vector multiplication.
PETSc supports this by letting you create a matrix with 
<tt>MatCreateFFT</tt>
.
This requires that you add an FFT library, such as 
<i>fftw</i>
,
at configuration time; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-design.html#Externalpackages">32.3.4</a>
.
</p>

<p name="switchToTextMode">
FFT libraries may use padding, so vectors should be created with
<tt>MatCreateVecsFFTW</tt>
,
not with an independent 
<tt>VecSetSizes</tt>
.
</p>

<p name="switchToTextMode">
The 
<i>fftw</i>
 library does not scale the output vector,
so a forward followed by a backward pass gives a result that is too large
by the vector size.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vecviewbeforeafter" aria-expanded="false" aria-controls="vecviewbeforeafter">
        C Code: vecviewbeforeafter
      </button>
    </h5>
  </div>
  <div id="vecviewbeforeafter" class="collapse">
  <pre>
// fftsine.c
ierr = VecView(signal,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
ierr = MatMult(transform,signal,frequencies); CHKERRQ(ierr);
ierr = VecScale(frequencies,1./Nglobal); CHKERRQ(ierr);
ierr = VecView(frequencies,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
</pre>
</div>
</div>
<p name="switchToTextMode">

<!-- environment: multicols start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=multicols ]] -->
<multicols>

<p name="multicols">
<!-- TranslatingLineGenerator multicols ['multicols'] -->
One full cosine wave:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
1.
0.809017 + 0.587785 i
0.309017 + 0.951057 i
-0.309017 + 0.951057 i
-0.809017 + 0.587785 i
-1. + 1.22465e-16 i
-0.809017 - 0.587785 i
-0.309017 - 0.951057 i
0.309017 - 0.951057 i
0.809017 - 0.587785 i
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Frequency $n=1$ amplitude&nbsp;$\equiv1$:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
-2.22045e-17 + 2.33487e-17 i
1. - 9.23587e-17 i
2.85226e-17 + 1.56772e-17 i
-4.44089e-17 + 1.75641e-17 i
-3.35828e-19 + 3.26458e-18 i
0. - 1.22465e-17 i
-1.33873e-17 + 3.26458e-18 i
-4.44089e-17 + 7.59366e-18 i
7.40494e-18 + 1.56772e-17 i
0. + 1.8215e-17 i
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</multicols>
<!-- environment: multicols end embedded generator -->
<p name="switchToTextMode">

Strangely enough, the backward pass does not need to be scaled:
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#fftaccuracy" aria-expanded="false" aria-controls="fftaccuracy">
        C Code: fftaccuracy
      </button>
    </h5>
  </div>
  <div id="fftaccuracy" class="collapse">
  <pre>
Vec confirm;
ierr = VecDuplicate(signal,&confirm); CHKERRQ(ierr);
ierr = MatMultTranspose(transform,frequencies,confirm); CHKERRQ(ierr);
ierr = VecAXPY(confirm,-1,signal); CHKERRQ(ierr);
PetscReal nrm;
ierr = VecNorm(confirm,NORM_2,&nrm); CHKERRQ(ierr);
PetscPrintf(MPI_COMM_WORLD,"FFT accuracy %e\n",nrm);
ierr = VecDestroy(&confirm); CHKERRQ(ierr);
</pre>
</div>
</div>
<p name="switchToTextMode">

<h2><a id="IndexsetsandVectorScatters">33.5</a> Index sets and Vector Scatters</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#IndexsetsandVectorScatters">Index sets and Vector Scatters</a>
</p>
</p>

<p name="switchToTextMode">
In the 
<span title="acronym" ><i>PDE</i></span>
 type of applications that PETSc was originally intended for,
vector data can only be real or complex: there are no vector of integers.
On the other hand, integers are used for indexing into vector,
for instance for gathering boundary elements into a 
<i>halo region</i>
,
or for doing the 
<i>data transpose</i>
 of an 
<i>FFT</i>
 operation.
</p>

<p name="switchToTextMode">
To support this, PETSc has the following object types:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
An \clstinline{IS} object describes a set of integer indices;
<li>
a \clstinline{VecScatter} object describes the correspondence between
  a group of indices in an input vector and a group of indices in an output vector.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h3><a id="IS:indexsets">33.5.1</a> IS: index sets</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#IndexsetsandVectorScatters">Index sets and Vector Scatters</a> > <a href="petsc-objects.html#IS:indexsets">IS: index sets</a>
</p>

</p>

<p name="switchToTextMode">
An \clstinline{IS} object contains a set of 
<tt>PetscInt</tt>
 values.
It can be created with
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>ISCreate</tt>
 for creating an empty set;
<li>
<tt>ISCreateStride</tt>
 for a strided set;
<li>
<tt>ISCreateBlock</tt>
 for a set of contiguous blocks,
  placed at an explicitly given list of starting indices.
<li>
<tt>ISCreateGeneral</tt>
 for an explicitly given list of indices.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

For example, to describe odd and even indices (on two processes):
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#isoddeven" aria-expanded="false" aria-controls="isoddeven">
        C Code: isoddeven
      </button>
    </h5>
  </div>
  <div id="isoddeven" class="collapse">
  <pre>
// oddeven.c
IS oddeven;
if (procid==0) {
  ierr = ISCreateStride(comm,Nglobal/2,0,2,&oddeven); CHKERRQ(ierr);
} else {
  ierr = ISCreateStride(comm,Nglobal/2,1,2,&oddeven); CHKERRQ(ierr);
}
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
After this, there are various query and set operations on index sets.
</p>

<p name="switchToTextMode">
You can read out the indices of a set by 
<tt>ISGetIndices</tt>
and 
<tt>ISRestoreIndices</tt>
.
</p>

<h3><a id="VecScatter:all-to-alloperations">33.5.2</a> VecScatter: all-to-all operations</h3>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#IndexsetsandVectorScatters">Index sets and Vector Scatters</a> > <a href="petsc-objects.html#VecScatter:all-to-alloperations">VecScatter: all-to-all operations</a>
</p>

<p name="switchToTextMode">

A 
<tt>VecScatter</tt>
 object is a generalization of an
all-to-all operation. However, unlike MPI 
<tt>MPI_Alltoall</tt>
,
which formulates everything in terms of local buffers, a
\clstinline{VecScatter} is more implicit in only describing indices in
the input and output vectors.
</p>

<p name="switchToTextMode">
The 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#VecScatterCreate" aria-expanded="false" aria-controls="VecScatterCreate">
        Routine reference: VecScatterCreate
      </button>
    </h5>
  </div>
  <div id="VecScatterCreate" class="collapse">
  <pre>
Synopsis
Creates a vector scatter context. Collective on Vec

#include "petscvec.h"
PetscErrorCode VecScatterCreate(Vec xin,IS ix,Vec yin,IS iy,VecScatter *newctx)

Input Parameters:
xin : a vector that defines the layout of vectors from which we scatter
yin : a vector that defines the layout of vectors to which we scatter
ix : the indices of xin to scatter (if NULL scatters all values)
iy : the indices of yin to hold results (if NULL fills entire vector yin)

Output Parameter
newctx : location to store the new scatter context
</pre>
</div>
</div>
<i>VecScatterCreate</i>
 call has as arguments:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
An input vector. From this, the parallel layout is used; any
  vector being scattered from should have this same layout.
<li>
An \clstinline{IS} object describing what indices are being
  scattered; if the whole vector is rearranged, \clstinline{NULL}
  (Fortran: 
<li>
An output vector. From this, the parallel layout is used; any
  vector being scattered into should have this same layout.
<li>
An \clstinline{IS} object describing what indices are being
  scattered into; if the whole vector is a target, \clstinline{NULL} can
  be given.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

As a simple example, the odd/even sets defined above can be used to
move all components with even index to process zero, and the ones with
odd index to process one:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vsoddeven" aria-expanded="false" aria-controls="vsoddeven">
        C Code: vsoddeven
      </button>
    </h5>
  </div>
  <div id="vsoddeven" class="collapse">
  <pre>
VecScatter separate;
ierr = VecScatterCreate
  (in,oddeven,out,NULL,&separate); CHKERRQ(ierr);
ierr = VecScatterBegin
  (separate,in,out,INSERT_VALUES,SCATTER_FORWARD); CHKERRQ(ierr);
ierr = VecScatterEnd
  (separate,in,out,INSERT_VALUES,SCATTER_FORWARD); CHKERRQ(ierr);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
Note that the index set is applied to the input vector, since it
describes the components to be moved. The output vector uses
\clstinline{NULL} since these components are placed in sequence.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Modify this example so that the components are still separated
  odd/even, but now placed in descending order on each process.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Can you extend this example so that process&nbsp;$p$ receives
  all indices that are multiples of&nbsp;$p$? Is your solution correct if
  \clstinline{Nglobal} is not a multiple of \clstinline{nprocs}?
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<h4><a id="MoreVecScattermodes">33.5.2.1</a> More VecScatter modes</h4>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#IndexsetsandVectorScatters">Index sets and Vector Scatters</a> > <a href="petsc-objects.html#VecScatter:all-to-alloperations">VecScatter: all-to-all operations</a> > <a href="petsc-objects.html#MoreVecScattermodes">More VecScatter modes</a>
</p>
</p>

<p name="switchToTextMode">
There is an added complication, in that a \clstinline{VecScatter} can
have both sequential and parallel input or output vectors.
Scattering onto process zero is also a popular option.
</p>

<h2><a id="AO:ApplicationOrderings">33.6</a> AO: Application Orderings</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#AO:ApplicationOrderings">AO: Application Orderings</a>
</p>
<p name="switchToTextMode">

PETSc's decision to partition a matrix by contiguous block rows
may be a limitation in the sense an application can have a natural
ordering that is different. For such cases the 
<tt>AO</tt>
 type
can translate between the two schemes.
</p>

<h2><a id="Partitionings">33.7</a> Partitionings</h2>
<p name=crumbs>
crumb trail:  > <a href="petsc-objects.html">petsc-objects</a> > <a href="petsc-objects.html#Partitionings">Partitionings</a>
</p>
<p name="switchToTextMode">

By default, PETSc uses partitioning of matrices and vectors based on
consecutive blocks of variables.
In regular cases that is not a bad strategy.
However, for some matrices a permutation and re-division can
be advantageous.
For instance, one could look at the 
<i>adjacency graph</i>
,
and minimize the number of 
<i>edge cuts</i>
or the sum of the 
<i>edge weight</i>
s.
</p>

<p name="switchToTextMode">
This functionality is not built into PETSc, but can be provided by
<i>graph partitioning packages</i>
<!-- index -->
such as 
<i>ParMetis</i>
 or 
<i>Zoltan</i>
.
The basic object is the 
<tt>MatPartitioning</tt>
,
with routines for
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Create and destroy: 
<tt>MatPartitioningCreate</tt>
,
<tt>MatPartitioningDestroy</tt>
;
<li>
Setting the type 
<tt>MatPartitioningSetType</tt>
  to an explicit partitioner, or something generated
  as the dual or a refinement of the current matrix;
<li>
Apply with 
<tt>MatPartitioningApply</tt>
,
  giving a distribued 
<tt>IS</tt>
 object,
  which can then be used in 
<tt>MatCreateSubMatrix</tt>
  to repartition.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Illustrative example:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatPartitioning part;
MatPartitioningCreate(comm,&part);
MatPartitioningSetType(part,MATPARTITIONINGPARMETIS);
MatPartitioningApply(part,&is);
/* get new global number of each old global number */
ISPartitioningToNumbering(is,&isn);
ISBuildTwoSided(is,NULL,&isrows);
MatCreateSubMatrix(A,isrows,isrows,MAT_INITIAL_MATRIX,&perA);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Other scenario:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MatPartitioningSetAdjacency(part,A);
MatPartitioningSetType(part,MATPARTITIONINGHIERARCH);
MatPartitioningHierarchicalSetNcoarseparts(part,2);
MatPartitioningHierarchicalSetNfineparts(part,2);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
</div>
<a href="index.html">Back to Table of Contents</a>
