<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src=https://ccrs.cac.cornell.edu:8443/client.0.2.js></script>
<script id="script">
class Example {
  constructor(buttonID, editorID, outputID, sourceFile, fileName, commandStr) {
    this.buttonID = buttonID;
    this.editorID = editorID;
    this.outputID = outputID;
    this.sourceFile = sourceFile;
    this.fileName = fileName;
    this.commandStr = commandStr;
  }
    
  async display(results, object) {
    if (results.stdout.length > 0)
      document.getElementById(object.outputID).textContent = results.stdout;
    else
      document.getElementById(object.outputID).textContent = results.stderr;
  }

  async initialize() {
    this.editor = await MonacoEditorFileSource.create(this.editorID);
    this.editor.setTextFromFile(this.sourceFile);
    this.job = await Job.create(JobType.MPI);
    this.command = new CommandWithFiles(this.job, this.commandStr);
    this.command.addFileSource(this.editor, this.fileName);
    this.trigger = new ButtonTrigger(this.command, this.display, this.buttonID, this);
    document.getElementById(this.buttonID).disabled = false;
  }
}
</script>
<style></style>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>MPI topic: Data types</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


6.1 : <a href="mpi-data.html#Datatypehandling">Data type handling</a><br>
6.2 : <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a><br>
6.2.1 : <a href="mpi-data.html#CC++">C/C++</a><br>
6.2.2 : <a href="mpi-data.html#Fortran">Fortran</a><br>
6.2.2.1 : <a href="mpi-data.html#Bigdatatypes">Big data types</a><br>
6.2.2.2 : <a href="mpi-data.html#Bytecountingtypes">Byte counting types</a><br>
6.2.2.3 : <a href="mpi-data.html#Fortran90kind-definedtypes">Fortran90 kind-defined types</a><br>
6.2.3 : <a href="mpi-data.html#Python">Python</a><br>
6.2.3.1 : <a href="mpi-data.html#TypecorrespondencesMPIPython">Type correspondences MPI / Python</a><br>
6.2.4 : <a href="mpi-data.html#Byteaddressingtype">Byte addressing type</a><br>
6.2.4.1 : <a href="mpi-data.html#Fortran">Fortran</a><br>
6.2.4.2 : <a href="mpi-data.html#Python">Python</a><br>
6.2.5 : <a href="mpi-data.html#MatchinglanguagetypetoMPItype">Matching language type to MPI type</a><br>
6.2.5.1 : <a href="mpi-data.html#TypematchinginC">Type matching in C</a><br>
6.2.5.2 : <a href="mpi-data.html#TypematchinginFortran">Type matching in Fortran</a><br>
6.3 : <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a><br>
6.3.1 : <a href="mpi-data.html#Basiccalls">Basic calls</a><br>
6.3.1.1 : <a href="mpi-data.html#Createcalls">Create calls</a><br>
6.3.1.2 : <a href="mpi-data.html#Commitandfree">Commit and free</a><br>
6.3.2 : <a href="mpi-data.html#Contiguoustype">Contiguous type</a><br>
6.3.3 : <a href="mpi-data.html#Vectortype">Vector type</a><br>
6.3.3.1 : <a href="mpi-data.html#Two-dimensionalarrays">Two-dimensional arrays</a><br>
6.3.4 : <a href="mpi-data.html#Subarraytype">Subarray type</a><br>
6.3.5 : <a href="mpi-data.html#Indexedtype">Indexed type</a><br>
6.3.6 : <a href="mpi-data.html#Structtype">Struct type</a><br>
6.4 : <a href="mpi-data.html#Bigdatatypes">Big data types</a><br>
6.4.1 : <a href="mpi-data.html#C">C</a><br>
6.4.2 : <a href="mpi-data.html#Fortran">Fortran</a><br>
6.4.3 : <a href="mpi-data.html#Countdatatype">Count datatype</a><br>
6.4.4 : <a href="mpi-data.html#MPI3temporarysolution">MPI 3 temporary solution</a><br>
6.5 : <a href="mpi-data.html#Typemapsandtypematching">Type maps and type matching</a><br>
6.6 : <a href="mpi-data.html#Typeextent">Type extent</a><br>
6.6.1 : <a href="mpi-data.html#Extentandtrueextent">Extent and true extent</a><br>
6.6.2 : <a href="mpi-data.html#Extentresizing">Extent resizing</a><br>
6.6.2.1 : <a href="mpi-data.html#Example1">Example 1</a><br>
6.6.2.2 : <a href="mpi-data.html#Example2">Example 2</a><br>
6.6.2.3 : <a href="mpi-data.html#Example:dynamicvectors">Example: dynamic vectors</a><br>
6.6.2.4 : <a href="mpi-data.html#Example:transpose">Example: transpose</a><br>
6.7 : <a href="mpi-data.html#Reconstructingtypes">Reconstructing types</a><br>
6.8 : <a href="mpi-data.html#Packing">Packing</a><br>
6.9 : <a href="mpi-data.html#Reviewquestions">Review questions</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>6 MPI topic: Data types</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<!-- index -->
</p>

<p name="switchToTextMode">
In the examples you have seen so far, every time data was sent,
it was as a contiguous buffer with elements of a single type.
In practice you may want to send heterogeneous data, or
noncontiguous data.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Communicating the real parts of an array of complex numbers
  means specifying every other number.
<li>
Communicating a C~structure or Fortran type with more than one
  type of element is not equivalent to sending an array of elements of
  a single type.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
The datatypes you have dealt with so far are known as
<i>elementary datatype</i>
s; irregular objects
are known as 
<i>derived datatype</i>
s.
</p>

<h2><a id="Datatypehandling">6.1</a> Data type handling</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Datatypehandling">Data type handling</a>
</p>

<p name="switchToTextMode">

Datatypes such as 
<tt>MPI_INT</tt>
 are values
of the type 
<tt>MPI_Datatype</tt>
.
This type is handled differently in different languages.
</p>

<!-- environment: fortrannote start embedded generator -->
<!-- environment block purpose: [[ environment=fortrannote ]] -->
<remark>
<b>Fortran note</b>
<p name="remark">
<!-- TranslatingLineGenerator fortrannote ['fortrannote'] -->
  In Fortran before 2008, datatypes variables are stored in
  
<tt>Integer</tt>
 variables.
  With the 2008 standard, datatypes are Fortran derived types:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Type(Datatype),bind(C) :: mytype
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
</remark>
<!-- environment: fortrannote end embedded generator -->
<p name="switchToTextMode">
{Derived types for handles}
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  There is a class
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
mpi4py.MPI.Datatype
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
  with predefined values such as
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
mpi4py.MPI.Datatype.DOUBLE
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
  which are themselves objects with methods
  for creating derived types;
  see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Basiccalls">6.3.1</a>
.
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#mplsendlong" aria-expanded="false" aria-controls="mplsendlong">
        C++ Code: mplsendlong
      </button>
    </h5>
  </div>
  <div id="mplsendlong" class="collapse">
  <pre>
// sendlong.cxx
mpl::contiguous_layout&lt;long long&gt; v_layout(v.size());
  comm.send(v.data(), v_layout, 1); // send to rank 1
</pre>
</div>
</div>
<p name="switchToTextMode">
  Also works with complex of float and double.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  MPL routines are templated over the data type.  The data types,
  where MPL can infer their internal representation, are enumeration
  types, C&nbsp;arrays of constant size and the template classes
   <tt>std::array</tt> ,
   <tt>std::pair</tt>  and
   <tt>std::tuple</tt> 
  of the C++ Standard Template
  Library. The only limitation is, that the C&nbsp;array and the mentioned
  template classes hold data elements of types that can be sent or
  received by MPL.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- TranslatingLineGenerator file ['file'] -->
</p>

<h2><a id="Elementarydatatypes">6.2</a> Elementary data types</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a>
</p>

<!-- index -->
<p name="switchToTextMode">

MPI has a number of elementary data types, corresponding to the
simple data types of programming languages.
The names are made to resemble the types of C and~Fortran,
for instance 
<tt>MPI_FLOAT</tt>
 and 
<tt>MPI_DOUBLE</tt>
 in~C,
versus
<tt>MPI_REAL</tt>
 and 
<tt>MPI_DOUBLE_PRECISION</tt>
 in~Fortran.
</p>

<!-- environment: comment start embedded generator -->
<!-- environment block purpose: [[ environment=comment ]] -->
<comment>


</comment>
<!-- environment: comment end embedded generator -->
<p name="switchToTextMode">

<h3><a id="CC++">6.2.1</a> C/C++</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#CC++">C/C++</a>
</p>
<!-- index -->
</p>

<p name="switchToTextMode">
Here we illustrate the correspondence between a type used to declare a variable,
and how this type appears in MPI communication routines:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
long int i;
MPI_Send(&i,1,MPI_LONG_INT,target,tag,comm);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  C type</td><td>MPI type</td></tr>
<tr><td>
  </td></tr>
<tr><td>
 <tt>char</tt> </td><td>
<tt>MPI_CHAR</tt>
</td></tr>
<tr><td>
 <tt>unsigned char</tt> </td><td>
<tt>MPI_UNSIGNED_CHAR</tt>
</td></tr>
<tr><td>
 <tt>char</tt> </td><td>
<tt>MPI_SIGNED_CHAR</tt>
</td></tr>
<tr><td>
 <tt>short</tt> </td><td>
<tt>MPI_SHORT</tt>
</td></tr>
<tr><td>
 <tt>unsigned short</tt> </td><td>
<tt>MPI_UNSIGNED_SHORT</tt>
</td></tr>
<tr><td>
 <tt>int</tt> </td><td>
<tt>MPI_INT</tt>
</td></tr>
<tr><td>
 <tt>unsigned int</tt> </td><td>
<tt>MPI_UNSIGNED</tt>
</td></tr>
<tr><td>
 <tt>long int</tt> </td><td>
<tt>MPI_LONG</tt>
</td></tr>
<tr><td>
 <tt>unsigned long int</tt> </td><td>
<tt>MPI_UNSIGNED_LONG</tt>
</td></tr>
<tr><td>
 <tt>long long int</tt> </td><td>
<tt>MPI_LONG_LONG_INT</tt>
</td></tr>
<tr><td>
 <tt>float</tt> </td><td>
<tt>MPI_FLOAT</tt>
</td></tr>
<tr><td>
 <tt>double</tt> </td><td>
<tt>MPI_DOUBLE</tt>
</td></tr>
<tr><td>
 <tt>long double</tt> </td><td>
<tt>MPI_LONG_DOUBLE</tt>
</td></tr>
<tr><td>
 <tt>unsigned char</tt> </td><td>
<tt>MPI_BYTE</tt>
</td></tr>
<tr><td>
(does not correspond to a C type)</td><td>
<tt>MPI_PACKED</tt>
</td></tr>
<tr><td>
 <tt>MPI_Aint</tt> </td><td>
<tt>MPI_AINT</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

There is some, but not complete, support for 
<i>C99</i>
 types.
</p>

<p name="switchToTextMode">
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Byteaddressingtype">6.2.4</a>
 for 
<tt>MPI_Aint</tt>
and more about byte counting.
</p>

<h3><a id="Fortran">6.2.2</a> Fortran</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Fortran">Fortran</a>
</p>
<!-- index -->
<p name="switchToTextMode">

<!-- environment: table start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=table ]] -->
<table>
<table><tbody>
<!-- TranslatingLineGenerator table ['table'] -->
<p name="switchToTextMode">
\hbox{
<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
<tt>MPI_CHARACTER</tt>
</td><td>Character(Len=1)</td></tr>
<tr><td>
<tt>MPI_INTEGER</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_REAL</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_DOUBLE_PRECISION</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_COMPLEX</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_LOGICAL</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_BYTE</tt>
</td><td></td></tr>
<tr><td>
<tt>MPI_PACKED</tt>
</td><td></td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
<tt>MPI_INTEGER1</tt>
</td></tr>
<tr><td>
<tt>MPI_INTEGER2</tt>
</td></tr>
<tr><td>
<tt>MPI_INTEGER4</tt>
</td></tr>
<tr><td>
<tt>MPI_INTEGER8</tt>
</td></tr>
<tr><td>
<tt>MPI_INTEGER16</tt>
</td></tr>
<tr><td>
<tt>MPI_REAL2</tt>
</td></tr>
<tr><td>
<tt>MPI_REAL4</tt>
</td></tr>
<tr><td>
<tt>MPI_REAL8</tt>
</td></tr>
<tr><td>
<tt>MPI_DOUBLE_COMPLEX</tt>
\ \kern20pt Complex(Kind=Kind(0.d0))</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">
}
<p name="caption">
TABLE: Standard Fortran types (left) and common extension (right)
</p>

</tbody></table>
</table>
<!-- environment: table end embedded generator -->
<p name="switchToTextMode">

Not all these types need be supported, for instance
<tt>MPI_INTEGER16</tt>
 may not exist, in which case it will be
equivalent to 
<tt>MPI_DATATYPE_NULL</tt>
.
</p>

<p name="switchToTextMode">
The default integer type 
<tt>MPI_INTEGER</tt>
 is equivalent to

<tt>INTEGER(KIND=MPI_INTEGER_KIND)</tt>
.
</p>

<h4><a id="Bigdatatypes">6.2.2.1</a> Big data types</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Fortran">Fortran</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a>
</p>
<p name="switchToTextMode">

The C type 
<tt>MPI_Count</tt>
 corresponds to an integer of type
<tt>MPI_COUNT_KIND</tt>
, used most prominently in `big data'
routines such as 
<tt>MPI_Type_size_x</tt>
(section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Typeextent">6.6</a>
):
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Integer(kind=MPI_COUNT_KIND) :: count
call MPI_Type_size_x(my_type, count)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

\begin{mpifournote}
{Count type}
  For every routine 
<tt>MPI_Something</tt>

  with an 
<tt>int</tt>
 count parameter,
  there is a corresponding routine 
<tt>MPI_Something_c</tt>

  with an 
<tt>MPI_Count</tt>
 parameter.
</p>

<p name="switchToTextMode">
  The above 
<tt>MPI_Something_x</tt>
 routines
  will probably be deprecated in the \mpistandard{4.1} standard.
\end{mpifournote}
</p>

<h4><a id="Bytecountingtypes">6.2.2.2</a> Byte counting types</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Fortran">Fortran</a> > <a href="mpi-data.html#Bytecountingtypes">Byte counting types</a>
</p>

<p name="switchToTextMode">

Kind 
<tt>MPI_ADDRESS_KIND</tt>
 is used for 
<tt>MPI_Aint</tt>
quantities, used in 
<span title="acronym" ><i>RMA</i></span>
 windows; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-onesided.html#Put">9.3.1</a>
.
</p>

<p name="switchToTextMode">
The 
<tt>MPI_OFFSET_KIND</tt>
is used to define 
<tt>MPI_Offset</tt>
 quantities,
used in file I/O; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-io.html#Individualfilepointers,contiguouswrites">10.2.2</a>
.
</p>

<h4><a id="Fortran90kind-definedtypes">6.2.2.3</a> Fortran90 kind-defined types</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Fortran">Fortran</a> > <a href="mpi-data.html#Fortran90kind-definedtypes">Fortran90 kind-defined types</a>
</p>

<p name="switchToTextMode">

If your \fstandard{90} code uses 
<tt>KIND</tt>
 to define scalar types with
specified precision, these do not in general correspond to any
predefined MPI datatypes. Hence the following routines exist to make
<i>MPI equivalences of Fortran scalar types</i>
<!-- index -->
:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_f90_integer" aria-expanded="false" aria-controls="MPI_Type_create_f90_integer">
        Routine reference: MPI_Type_create_f90_integer
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_f90_integer" class="collapse">
  <pre>
C:
int MPI_Type_create_f90_integer(int r, MPI_Datatype *newtype);

Input Parameter
r : Precision, in decimal digits (integer).

Output Parameters
newtype : New data type (handle).
IERROR : Fortran only: Error status (integer).
Fortran:
MPI_TYPE_CREATE_F90_INTEGER( R, NEWTYPE, IERROR)
Integer :: R,Newtype,ierror
</pre>
</div>
</div>
<i>MPI_Type_create_f90_integer</i>
<li>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_f90_real" aria-expanded="false" aria-controls="MPI_Type_create_f90_real">
        Routine reference: MPI_Type_create_f90_real
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_f90_real" class="collapse">
  <pre>
C:
int MPI_Type_create_f90_real(int p, int r, MPI_Datatype *newtype)

Fortran:
MPI_TYPE_CREATE_F90_REAL (P, R, NEWTYPE, IERROR)

Input Parameters
p : Precision, in decimal digits (integer).
r : Decimal exponent range (integer).

Output Parameters
newtype : New data type (handle).
IERROR : Fortran only: Error status (integer).

Either p or r, but not both, may be omitted from calls to
SELECTED_REAL_KIND. Similarly, either argument to
MPI_Type_create_f90_real may be set to MPI_UNDEFINED.
</pre>
</div>
</div>
<i>MPI_Type_create_f90_real</i>
<li>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_f90_complex" aria-expanded="false" aria-controls="MPI_Type_create_f90_complex">
        Routine reference: MPI_Type_create_f90_complex
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_f90_complex" class="collapse">
  <pre>
C:
int MPI_Type_create_f90_real(int p, int r, MPI_Datatype *newtype)

Fortran:
MPI_TYPE_CREATE_F90_REAL (P, R, NEWTYPE, IERROR)

Input Parameters
p : Precision, in decimal digits (integer).
r : Decimal exponent range (integer).

Output Parameters
newtype : New data type (handle).
IERROR : Fortran only: Error status (integer).

Either p or r, but not both, may be omitted from calls to
SELECTED_REAL_KIND. Similarly, either argument to
MPI_Type_create_f90_complex may be set to MPI_UNDEFINED.
</pre>
</div>
</div>
<i>MPI_Type_create_f90_complex</i>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Examples:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
INTEGER ( KIND = SELECTED_INTEGER_KIND(15) ) , &
 DIMENSION(100) :: array INTEGER :: root , integertype , error


CALL MPI_Type_create_f90_integer( 15 , integertype , error )
CALL MPI_Bcast ( array , 100 , &
 integertype , root , MPI_COMM_WORLD , error )


REAL ( KIND = SELECTED_REAL_KIND(15 ,300) ) , &
 DIMENSION(100) :: array
CALL MPI_Type_create_f90_real( 15 , 300 , realtype , error )


COMPLEX ( KIND = SELECTED_REAL_KIND(15 ,300) ) , &
 DIMENSION(100) :: array
CALL MPI_Type_create_f90_complex( 15 , 300 , complextype , error )
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Python">6.2.3</a> Python</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Python">Python</a>
</p>
<!-- index -->
</p>

<p name="switchToTextMode">
In python, all buffer data comes from 
<i>Numpy</i>
.
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  mpi4py type</td><td>NumPy type</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>MPI.INT</tt>
</td><td>
<tt>np.intc</tt>
</td></tr>
<tr><td>
             </td><td>
<tt>np.int32</tt>
</td></tr>
<tr><td>
  
<tt>MPI.LONG</tt>
</td><td>
<tt>np.int64</tt>
</td></tr>
<tr><td>
  
<tt>MPI.FLOAT</tt>
</td><td>
<tt>np.float32</tt>
</td></tr>
<tr><td>
  
<tt>MPI.DOUBLE</tt>
</td><td>
<tt>np.float64</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

In this table we see that
Numpy has three integer types,
one corresponding to C&nbsp;
<tt>int</tt>
s,
and two with the number of bits explicitly indicated.
There used to be a 
<tt>np.int</tt>
 type,
but this is deprecated as of 
<i>Numpy 1.20</i>
</p>

<p name="switchToTextMode">
Examples:
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#npintc" aria-expanded="false" aria-controls="npintc">
        Python Code: npintc
      </button>
    </h5>
  </div>
  <div id="npintc" class="collapse">
  <pre>
## inttype.py
sizeofint = np.dtype('int32').itemsize
print("Size of numpy int32: {}".format(sizeofint))
sizeofint = np.dtype('intc').itemsize
print("Size of C int: {}".format(sizeofint))
</pre>
</div>
</div>
<p name="switchToTextMode">

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bufallocp" aria-expanded="false" aria-controls="bufallocp">
        Python Code: bufallocp
      </button>
    </h5>
  </div>
  <div id="bufallocp" class="collapse">
  <pre>
## allgatherv.py
mycount = procid+1
my_array = np.empty(mycount,dtype=np.float64)
</pre>
</div>
</div>
</p>

<h4><a id="TypecorrespondencesMPIPython">6.2.3.1</a> Type correspondences MPI / Python</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Python">Python</a> > <a href="mpi-data.html#TypecorrespondencesMPIPython">Type correspondences MPI / Python</a>
</p>
<p name="switchToTextMode">

Above we saw that the number of bytes of a Numpy type can be deduced from
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
sizeofint = np.dtype('intc').itemsize
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

It is possible to derive the Numpy type corresponding to an MPI type:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#mpityp2numpy" aria-expanded="false" aria-controls="mpityp2numpy">
        Python Code: mpityp2numpy
      </button>
    </h5>
  </div>
  <div id="mpityp2numpy" class="collapse">
  <pre>
// typesize.py
datatype = MPI.FLOAT
typecode = MPI._typecode(datatype)
assert typecode is not None # check MPI datatype is built-in
dtype = np.dtype(typecode)
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">

<h3><a id="Byteaddressingtype">6.2.4</a> Byte addressing type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Byteaddressingtype">Byte addressing type</a>
</p>

</p>

<p name="switchToTextMode">
So far we have mostly been taking about datatypes in the context of
sending them. The 
<tt>MPI_Aint</tt>
 type is not so much for
sending, as it is for describing the size of objects, such as the size
of an 
<tt>MPI_Win</tt>
 object; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-onesided.html#Windows">9.1</a>
.
</p>

<p name="switchToTextMode">
Addresses have type 
<tt>MPI_Aint</tt>
 The start of the address range is
given in 
<tt>MPI_BOTTOM</tt>
.
</p>

<p name="switchToTextMode">
Variables of type 
<tt>MPI_Aint</tt>
 can be sent as 
<tt>MPI_AINT</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Aint address;
MPI_Send( address,1,MPI_AINT, ... );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-onesided.html#Dynamicallyattachedmemory">9.5.2</a>
 for an example.
</p>

<p name="switchToTextMode">
In order to prevent overflow errors in byte calculations
there are support routines 
<tt>MPI_Aint_add</tt>
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Aint MPI_Aint_add(MPI_Aint base, MPI_Aint disp)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
and similarly 
<tt>MPI_Aint_diff</tt>
.
</p>

<p name="switchToTextMode">
See also the 
<tt>MPI_Sizeof</tt>
(section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#MatchinglanguagetypetoMPItype">6.2.5</a>
)
and
<tt>MPI_Get_address</tt>
 routines.
</p>

<h4><a id="Fortran">6.2.4.1</a> Fortran</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Byteaddressingtype">Byte addressing type</a> > <a href="mpi-data.html#Fortran">Fortran</a>
</p>
<p name="switchToTextMode">

The equivalent of
<i>MPI_Aint in Fortran</i>
is an integer of kind 
<tt>MPI_ADDRESS_KIND</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
integer(kind=MPI_ADDRESS_KIND) :: winsize
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Fortran lacks a 
<tt>sizeof</tt>
 operator to query the sizes of datatypes.
Since sometimes exact byte counts are necessary,
for instance in one-sided communication,
Fortran can use the (deprecated) 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Sizeof" aria-expanded="false" aria-controls="MPI_Sizeof">
        Routine reference: MPI_Sizeof
      </button>
    </h5>
  </div>
  <div id="MPI_Sizeof" class="collapse">
  <pre>
Synopsis:

MPI_Sizeof(v,size) - Returns the size, in bytes, of the given type

Fortran:
MPI_SIZEOF(V, SIZE, IERROR)
<type>    V
INTEGER    SIZE, IERROR

Input parameter:
V : A Fortran variable of numeric intrinsic type (choice).

Output parameter:
size : Size of machine representation of that type (integer).
ierror (Fortran) : Error status (integer); NOTE: NOT OPTIONAL!


</pre>
</div>
</div>
<i>MPI_Sizeof</i>
 routine.
See section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#MatchinglanguagetypetoMPItype">6.2.5</a>
 for details.
</p>

<p name="switchToTextMode">
Example usage in 
<tt>MPI_Win_create</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
call MPI_Sizeof(windowdata,window_element_size,ierr)
window_size = window_element_size*500
call MPI_Win_create( windowdata,window_size,window_element_size,... )
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Python">6.2.4.2</a> Python</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#Byteaddressingtype">Byte addressing type</a> > <a href="mpi-data.html#Python">Python</a>
</p>
</p>

<p name="switchToTextMode">
Here is a good way for finding the size of 
<i>numpy</i>
 datatypes
in bytes:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#windispp" aria-expanded="false" aria-controls="windispp">
        Python Code: windispp
      </button>
    </h5>
  </div>
  <div id="windispp" class="collapse">
  <pre>
## putfence.py
intsize = np.dtype('int').itemsize
window_data = np.zeros(2,dtype=np.int)
win = MPI.Win.Create(window_data,intsize,comm=comm)
</pre>
</div>
</div>
</p>

<h3><a id="MatchinglanguagetypetoMPItype">6.2.5</a> Matching language type to MPI type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#MatchinglanguagetypetoMPItype">Matching language type to MPI type</a>
</p>

<p name="switchToTextMode">

In some circumstances you may want to find the MPI type
that corresponds to a type in your programming language.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
In C++ functions and classes can be templated,
  meaning that the type is not fully known:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
template&lt;typename T&gt; {
class something&lt;T&gt; {
public:
  void dosend(T input) {
    MPI_Send( &input,1,/* ????? */ );
  };
};
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
(Note that in 
<span title="acronym" ><i>MPL</i></span>
 this is hardly ever needed
because MPI calls are templated there.)
<li>
Petsc installations use a generic identifier 
<tt>PetscScalar</tt>
  (or 
<tt>PetscReal</tt>
)
  with a configuration-dependent realization.
<li>
The size of a datatype is not always statically known, for instance if
the Fortran 
<tt>KIND</tt>
 keyword is used.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Here are some MPI mechanisms that address this problem.
</p>

<h4><a id="TypematchinginC">6.2.5.1</a> Type matching in C</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#MatchinglanguagetypetoMPItype">Matching language type to MPI type</a> > <a href="mpi-data.html#TypematchinginC">Type matching in C</a>
</p>

<p name="switchToTextMode">

Datatypes in&nbsp;C can be translated to MPI types with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_match_size" aria-expanded="false" aria-controls="MPI_Type_match_size">
        Routine reference: MPI_Type_match_size
      </button>
    </h5>
  </div>
  <div id="MPI_Type_match_size" class="collapse">
  <pre>
Synopsis:
int MPI_Type_match_size
   (int typeclass, int size, MPI_Datatype *datatype)

Input Parameters
typeclass : generic type specifier (integer)
size : size, in bytes, of representation (integer)

Output Parameters
datatype : datatype with correct type, size (handle)

Notes
typeclass is one of:
- MPI_TYPECLASS_REAL,
- MPI_TYPECLASS_INTEGER and
- MPI_TYPECLASS_COMPLEX.
</pre>
</div>
</div>
<i>MPI_Type_match_size</i>
where the 
<tt>typeclass</tt>
 argument is one of
<tt>MPI_TYPECLASS_REAL</tt>
,
<tt>MPI_TYPECLASS_INTEGER</tt>
,
<tt>MPI_TYPECLASS_COMPLEX</tt>
.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#typematchc" aria-expanded="false" aria-controls="typematchc">
        C Code: typematchc
      </button>
    </h5>
  </div>
  <div id="typematchc" class="collapse">
  <pre>
// typematch.c
float x5;
double x10;
int s5,s10;
MPI_Datatype mpi_x5,mpi_x10;

MPI_Type_match_size(MPI_TYPECLASS_REAL,sizeof(x5),&mpi_x5);
MPI_Type_match_size(MPI_TYPECLASS_REAL,sizeof(x10),&mpi_x10);
MPI_Type_size(mpi_x5,&s5);
MPI_Type_size(mpi_x10,&s10);
</pre>
</div>
</div>
<p name="switchToTextMode">

The space that MPI takes for a structure type can be queried in a
variety of ways. First of all 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_size" aria-expanded="false" aria-controls="MPI_Type_size">
        Routine reference: MPI_Type_size
      </button>
    </h5>
  </div>
  <div id="MPI_Type_size" class="collapse">
  <pre>
Semantics:

int MPI_Type_size(
    MPI_Datatype datatype,
    int *size
    );

datatype: [in] datatype to get information on (handle)
size: [out] datatype size in bytes

</pre>
</div>
</div>
<i>MPI_Type_size</i>
 counts the
<i>datatype size</i>
<!-- index -->
 as the
number of bytes occupied by the data in a type. That means that in an
<i>MPI vector datatype</i>
<!-- index -->
 it does not
count the gaps.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vectortypesize" aria-expanded="false" aria-controls="vectortypesize">
        C Code: vectortypesize
      </button>
    </h5>
  </div>
  <div id="vectortypesize" class="collapse">
  <pre>
// typesize.c
MPI_Type_vector(count,bs,stride,MPI_DOUBLE,&newtype);
MPI_Type_commit(&newtype);
MPI_Type_size(newtype,&size);
ASSERT( size==(count*bs)*sizeof(double) );
</pre>
</div>
</div>
</p>

<!-- environment: comment start embedded generator -->
<!-- environment block purpose: [[ environment=comment ]] -->
<comment>


</comment>
<!-- environment: comment end embedded generator -->
<p name="switchToTextMode">

<h4><a id="TypematchinginFortran">6.2.5.2</a> Type matching in Fortran</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Elementarydatatypes">Elementary data types</a> > <a href="mpi-data.html#MatchinglanguagetypetoMPItype">Matching language type to MPI type</a> > <a href="mpi-data.html#TypematchinginFortran">Type matching in Fortran</a>
</p>

</p>

<p name="switchToTextMode">
In Fortran, the size of the datatype in the language can be obtained with
<tt>MPI_Sizeof</tt>
 (note the nonoptional error parameter!).
This routine is deprecated in \mpistandard{4}: use of
<tt>storage_size</tt>
 and/or 
<tt>c_sizeof</tt>
 is recommended.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#typematchf" aria-expanded="false" aria-controls="typematchf">
        Fortran Code: typematchf
      </button>
    </h5>
  </div>
  <div id="typematchf" class="collapse">
  <pre>
!! matchkind.F90
     call MPI_Sizeof(x10,s10,ierr)
     call MPI_Type_match_size(MPI_TYPECLASS_REAL,s10,mpi_x10)
     call MPI_Type_size(mpi_x10,s10)
     print *,"10 positions supported, MPI type size is",s10
</pre>
</div>
</div>
<p name="switchToTextMode">

Petsc has its own translation mechanism; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/petsc-objects.html#Scalars">33.2</a>
.
</p>

<!-- index -->
<p name="switchToTextMode">

</p>

<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Deriveddatatypes">6.3</a> Derived datatypes</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a>
</p>

<!-- index -->
</p>

<p name="switchToTextMode">
MPI allows you to create your own data types, somewhat (but not completely\ldots)
analogous to defining
structures in a programming language. MPI data types are mostly of use
if you want to send multiple items in one message.
</p>

<p name="switchToTextMode">
There are two problems with using only elementary datatypes
as you have seen so far.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
MPI communication routines can only send multiples of a
  single data type: it is not possible to send items of different
  types, even if they are contiguous in memory. It would be possible
  to use the 
<tt>MPI_BYTE</tt>
 data type, but this is not advisable.
<li>
It is also ordinarily not possible to send items of one type if they are
  not contiguous in memory. You could of course send a contiguous memory area
  that contains the items you want to send, but that is wasteful of
  bandwidth.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
With MPI data types you can solve these problems in several ways.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
You can create a new 
<i>contiguous data type</i>
  consisting of an array of elements of another data type. There is no
  essential difference between sending one element of such a type
  and multiple elements of the
  component type.
<li>
You can create a 
<i>vector data type</i>
 consisting of
  regularly spaced blocks of elements of a component type. This is a first
  solution to the problem of sending noncontiguous data.
<li>
For not regularly spaced data, there is the
<i>indexed data type</i>
, where you specify an array of
  index locations for blocks of elements of a component type.
  The blocks can each be of a different size.
<li>
The 
<i>struct data type</i>
 can accomodate multiple
  data types.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
And you can combine these mechanisms to get irregularly spaced
heterogeneous data, et cetera.
</p>

<h3><a id="Basiccalls">6.3.1</a> Basic calls</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Basiccalls">Basic calls</a>
</p>

<p name="switchToTextMode">

The typical sequence of calls for creating a new datatype is as follows:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
You need a variable for the datatype;
<li>
There is a create call, followed by a `commit' call where MPI
  performs internal bookkeeping and optimizations;
<li>
The datatype is used, possibly multiple times;
<li>
When the datatype is no longer needed, it must be freed to prevent memory leaks.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
In code:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Datatype newtype;
MPI_Type_something( &lt; oldtype specifications &gt;, &newtype );
MPI_Type_commit( &newtype );
/* code that uses your new type */
MPI_Type_free( &newtype );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

In \fstandard{2008}:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Type(MPI_Datatype) :: newvectortype
call MPI_Type_something( &lt;oldtype specification&gt;, &
          newvectortype)
call MPI_Type_commit(newvectortype)
!! code that uses your type
call MPI_Type_free(newvectortype)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: pythonnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  The various type creation routines are methods
  of the datatype classes, after which commit and free are
  methods on the new type.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vectorp" aria-expanded="false" aria-controls="vectorp">
        Python Code: vectorp
      </button>
    </h5>
  </div>
  <div id="vectorp" class="collapse">
  <pre>
## vector.py
source = np.empty(stride*count,dtype=np.float64)
target = np.empty(count,dtype=np.float64)
if procid==sender:
    newvectortype = MPI.DOUBLE.Create_vector(count,1,stride)
    newvectortype.Commit()
    comm.Send([source,1,newvectortype],dest=the_other)
    newvectortype.Free()
elif procid==receiver:
    comm.Recv([target,count,MPI.DOUBLE],source=the_other)
</pre>
</div>
</div>
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->

<p name="switchToTextMode">
  In 
<span title="acronym" ><i>MPL</i></span>
 type creation routines are in the main namespace,
  templated over the datatypes.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#mplstatuscreate" aria-expanded="false" aria-controls="mplstatuscreate">
        C++ Code: mplstatuscreate
      </button>
    </h5>
  </div>
  <div id="mplstatuscreate" class="collapse">
  <pre>
mpl::contiguous_layout&lt;double&gt; target_layout(count);
mpl::status_t recv_status =
  comm_world.recv(target.data(),target_layout, the_other);
recv_count = recv_status.get_count&lt;double&gt;();
</pre>
</div>
</div>
  The commit call is part of the type creation,
  and freeing is done in the destructor.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Createcalls">6.3.1.1</a> Create calls</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Basiccalls">Basic calls</a> > <a href="mpi-data.html#Createcalls">Create calls</a>
</p>
</p>

<p name="switchToTextMode">
The 
<tt>MPI_Datatype</tt>
 varriable gets its value by a call to
one of the following routines:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<tt>MPI_Type_contiguous</tt>
 for contiguous blocks of
  data; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Contiguoustype">6.3.2</a>
;
<li>
<tt>MPI_Type_vector</tt>
 for regularly strided data;
  section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Vectortype">6.3.3</a>
;
<li>
<tt>MPI_Type_create_subarray</tt>
 for subsets out higher
  dimensional block; section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Subarraytype">6.3.4</a>
;
<li>
<tt>MPI_Type_create_struct</tt>
 for heterogeneous irregular data;
  section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Structtype">6.3.6</a>
;
<li>
<tt>MPI_Type_indexed</tt>
 and
<tt>MPI_Type_hindexed</tt>
 for irregularly strided data;
  section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Indexedtype">6.3.5</a>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
These calls take an existing type, whether elementary or also derived,
and produce a new type.
</p>

<h4><a id="Commitandfree">6.3.1.2</a> Commit and free</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Basiccalls">Basic calls</a> > <a href="mpi-data.html#Commitandfree">Commit and free</a>
</p>
<p name="switchToTextMode">

It is necessary to call 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_commit" aria-expanded="false" aria-controls="MPI_Type_commit">
        Routine reference: MPI_Type_commit
      </button>
    </h5>
  </div>
  <div id="MPI_Type_commit" class="collapse">
  <pre>
C:
int MPI_Type_commit(MPI_Datatype *datatype)

Fortran:
MPI_Type_commit(datatype, ierror)
TYPE(MPI_Datatype), INTENT(INOUT) :: datatype
INTEGER, OPTIONAL, INTENT(OUT) :: ierror
</pre>
</div>
</div>
<i>MPI_Type_commit</i>
 on a new data
type, which makes MPI do the indexing calculations for the data type.
</p>

<p name="switchToTextMode">
When you no longer
need the data type, you call 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_free" aria-expanded="false" aria-controls="MPI_Type_free">
        Routine reference: MPI_Type_free
      </button>
    </h5>
  </div>
  <div id="MPI_Type_free" class="collapse">
  <pre>
int MPI_Type_free (MPI_Datatype *datatype)
</pre>
</div>
</div>
<i>MPI_Type_free</i>
.
(This is typically not needed in 
<span title="acronym" ><i>OO</i></span>
<span title="acronym" ><i>APIs</i></span>
.)
This has the following effects:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The definition of the datatype identifier will be changed to
<tt>MPI_DATATYPE_NULL</tt>
.
<li>
Any communication using this data type, that was already
  started, will be completed succesfully.
<li>
Datatypes that are defined in terms of this data type will still
  be usable.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Contiguoustype">6.3.2</a> Contiguous type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Contiguoustype">Contiguous type</a>
</p>

</p>

<p name="switchToTextMode">
The simplest derived type is the `contiguous' type,
constructed with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_contiguous" aria-expanded="false" aria-controls="MPI_Type_contiguous">
        Routine reference: MPI_Type_contiguous
      </button>
    </h5>
  </div>
  <div id="MPI_Type_contiguous" class="collapse">
  <pre>
Semantics:
MPI_TYPE_CONTIGUOUS
   (count, oldtype, newtype)
IN count: replication count (non-negative integer)
IN oldtype: old datatype (handle)
OUT newtype: new datatype (handle)

C:
int MPI_Type_contiguous
   (int count, MPI_Datatype oldtype, MPI_Datatype *newtype)

Fortran:
MPI_Type_contiguous
   (count, oldtype, newtype, ierror)
INTEGER, INTENT(IN) :: count
TYPE(MPI_Datatype), INTENT(IN) :: oldtype
TYPE(MPI_Datatype), INTENT(OUT) :: newtype
INTEGER, OPTIONAL, INTENT(OUT) :: ierror

Python:
Create_contiguous(self, int count)
</pre>
</div>
</div>
<i>MPI_Type_contiguous</i>
.
</p>

<p name="switchToTextMode">
A&nbsp;contigous type describes an array of items
of an elementary or earlier defined type. There is no difference between sending
one item of a contiguous type and multiple items of the constituent type.
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/data-contiguous.jpeg" width=800></img>
<p name="caption">
FIGURE 6.1: A contiguous datatype is built up out of elements of a constituent type
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
This is illustrated in figure&nbsp;
6.1
.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#contiguous" aria-expanded="false" aria-controls="contiguous">
        C Code: contiguous
      </button>
    </h5>
  </div>
  <div id="contiguous" class="collapse">
  <pre>
// contiguous.c
MPI_Datatype newvectortype;
if (procno==sender) {
  MPI_Type_contiguous(count,MPI_DOUBLE,&newvectortype);
  MPI_Type_commit(&newvectortype);
  MPI_Send(source,1,newvectortype,receiver,0,comm);
  MPI_Type_free(&newvectortype);
} else if (procno==receiver) {
  MPI_Status recv_status;
  int recv_count;
  MPI_Recv(target,count,MPI_DOUBLE,sender,0,comm,
    &recv_status);
  MPI_Get_count(&recv_status,MPI_DOUBLE,&recv_count);
  ASSERT(count==recv_count);
}
</pre>
</div>
</div>
<p name="switchToTextMode">

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#contiguous-f" aria-expanded="false" aria-controls="contiguous-f">
        Fortran Code: contiguous-f
      </button>
    </h5>
  </div>
  <div id="contiguous-f" class="collapse">
  <pre>
!! contiguous.F90
  integer :: newvectortype
  if (mytid==sender) then
     call MPI_Type_contiguous(count,MPI_DOUBLE_PRECISION,newvectortype,err)
     call MPI_Type_commit(newvectortype,err)
     call MPI_Send(source,1,newvectortype,receiver,0,comm,err)
     call MPI_Type_free(newvectortype,err)
  else if (mytid==receiver) then
     call MPI_Recv(target,count,MPI_DOUBLE_PRECISION,sender,0,comm,&
          recv_status,err)
     call MPI_Get_count(recv_status,MPI_DOUBLE_PRECISION,recv_count,err)
     !ASSERT(count==recv_count);
  end if
</pre>
</div>
</div>
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#contiguousp" aria-expanded="false" aria-controls="contiguousp">
        Python Code: contiguousp
      </button>
    </h5>
  </div>
  <div id="contiguousp" class="collapse">
  <pre>
## contiguous.py
source = np.empty(count,dtype=np.float64)
target = np.empty(count,dtype=np.float64)
if procid==sender:
    newcontiguoustype = MPI.DOUBLE.Create_contiguous(count)
    newcontiguoustype.Commit()
    comm.Send([source,1,newcontiguoustype],dest=the_other)
    newcontiguoustype.Free()
elif procid==receiver:
    comm.Recv([target,count,MPI.DOUBLE],source=the_other)
</pre>
</div>
</div>
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  The 
<span title="acronym" ><i>MPL</i></span>
 interface makes extensive use of
<tt>contiguous_layout</tt>
  as it is the main way to declare a nonscalar buffer;
  see note&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-collective.html#Databuffers">3.2.4</a>
.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->

<p name="switchToTextMode">
  Contiguous layouts can only use elementary types or other contiguous layouts
  as their `old' type.
  To make a contiguous type for other layouts, use 
<tt>vector_layout</tt>
:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#mplcontvector" aria-expanded="false" aria-controls="mplcontvector">
        C++ Code: mplcontvector
      </button>
    </h5>
  </div>
  <div id="mplcontvector" class="collapse">
  <pre>
// contiguous.cxx
mpl::contiguous_layout&lt;int&gt; type1(7);
mpl::vector_layout&lt;int&gt; type2(8,type1);
</pre>
</div>
</div>
  (Contrast this with 
<tt>strided_vector_layout</tt>
6.3
.)
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Vectortype">6.3.3</a> Vector type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Vectortype">Vector type</a>
</p>

</p>

<p name="switchToTextMode">
The simplest noncontiguous datatype is the `vector' type, constructed with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_vector" aria-expanded="false" aria-controls="MPI_Type_vector">
        Routine reference: MPI_Type_vector
      </button>
    </h5>
  </div>
  <div id="MPI_Type_vector" class="collapse">
  <pre>
Semantics:
MPI_TYPE_VECTOR(count, blocklength, stride, oldtype, newtype)
IN count: number of blocks (non-negative integer)
IN blocklength: number of elements in each block (non-negative integer)
IN stride: number of elements between start of each block (integer)
IN oldtype: old datatype (handle)
OUT newtype: new datatype (handle)

C:
int MPI_Type_vector
   (int count, int blocklength, int stride,
    MPI_Datatype oldtype, MPI_Datatype *newtype)

Fortran:
MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror)
INTEGER, INTENT(IN) :: count, blocklength, stride
TYPE(MPI_Datatype), INTENT(IN) :: oldtype
TYPE(MPI_Datatype), INTENT(OUT) :: newtype
INTEGER, OPTIONAL, INTENT(OUT) :: ierror

Python:
MPI.Datatype.Create_vector(self, int count, int blocklength, int stride)
</pre>
</div>
</div>
<i>MPI_Type_vector</i>
.
</p>

<p name="switchToTextMode">
A&nbsp;vector type describes a series of blocks, all
of equal size, spaced with a constant stride.
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/data-vector.jpeg" width=800></img>
<p name="caption">
FIGURE 6.2: A vector datatype is built up out of strided blocks of elements of a constituent type
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
This is illustrated in figure&nbsp;
6.2
.
</p>

<p name="switchToTextMode">
The vector datatype gives the first nontrivial illustration that
datatypes can be 
<i>different on the sender and   receiver</i>

<!-- index -->
. If the
sender sends 
<tt>b</tt>
&nbsp;blocks of length&nbsp;
<tt>l</tt>
 each, the receiver can
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/data-vector-to-contiguous.jpeg" width=800></img>
<p name="switchToTextMode">
  \caption{Sending a vector datatype and receiving it as elementary or
    contiguous}

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
receive them as 
<tt>bl</tt>
 contiguous elements, either as a contiguous
datatype, or as a contiguous buffer of an elementary type; see
figure&nbsp;
6.3
. In this case, the receiver
has no knowledge of the stride of the datatype on the sender.
</p>

<p name="switchToTextMode">
In this example a vector type is created only on the sender, in order to send
a strided subset of an array; the receiver receives the data as a contiguous block.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vector" aria-expanded="false" aria-controls="vector">
        C Code: vector
      </button>
    </h5>
  </div>
  <div id="vector" class="collapse">
  <pre>
// vector.c
source = (double*) malloc(stride*count*sizeof(double));
target = (double*) malloc(count*sizeof(double));
MPI_Datatype newvectortype;
if (procno==sender) {
  MPI_Type_vector(count,1,stride,MPI_DOUBLE,&newvectortype);
  MPI_Type_commit(&newvectortype);
  MPI_Send(source,1,newvectortype,the_other,0,comm);
  MPI_Type_free(&newvectortype);
} else if (procno==receiver) {
  MPI_Status recv_status;
  int recv_count;
  MPI_Recv(target,count,MPI_DOUBLE,the_other,0,comm,
    &recv_status);
  MPI_Get_count(&recv_status,MPI_DOUBLE,&recv_count);
  ASSERT(recv_count==count);
}
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
We illustrate \fstandard{2008}:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vector-f08" aria-expanded="false" aria-controls="vector-f08">
        Fortran Code: vector-f08
      </button>
    </h5>
  </div>
  <div id="vector-f08" class="collapse">
  <pre>
!! vector.F90
  Type(MPI_Datatype) :: newvectortype
  if (mytid==sender) then
     call MPI_Type_vector(count,1,stride,MPI_DOUBLE_PRECISION,&
          newvectortype)
     call MPI_Type_commit(newvectortype)
     call MPI_Send(source,1,newvectortype,receiver,0,comm)
     call MPI_Type_free(newvectortype)
     if ( .not. newvectortype==MPI_DATATYPE_NULL) then
        print *,"Trouble freeing datatype"
     else
        print *,"Datatype successfully freed"
     end if
  else if (mytid==receiver) then
     call MPI_Recv(target,count,MPI_DOUBLE_PRECISION,sender,0,comm,&
          recv_status)
     call MPI_Get_count(recv_status,MPI_DOUBLE_PRECISION,recv_count)
  end if
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
In legacy mode \fstandard{90}, code stays the same except that the type is
declared as 
<tt>Integer</tt>
:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vector-f" aria-expanded="false" aria-controls="vector-f">
        Fortran Code: vector-f
      </button>
    </h5>
  </div>
  <div id="vector-f" class="collapse">
  <pre>
!! vector.F90
  integer :: newvectortype
  integer :: recv_status(MPI_STATUS_SIZE),recv_count
     call MPI_Type_vector(count,1,stride,MPI_DOUBLE_PRECISION,&
          newvectortype,err)
     call MPI_Type_commit(newvectortype,err)
</pre>
</div>
</div>
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  The vector creation routine is a method of the
   <tt>MPI.Datatype</tt>   class.
  For the general discussion, see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Basiccalls">6.3.1</a>
.
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vectorp" aria-expanded="false" aria-controls="vectorp">
        Python Code: vectorp
      </button>
    </h5>
  </div>
  <div id="vectorp" class="collapse">
  <pre>
## vector.py
source = np.empty(stride*count,dtype=np.float64)
target = np.empty(count,dtype=np.float64)
if procid==sender:
    newvectortype = MPI.DOUBLE.Create_vector(count,1,stride)
    newvectortype.Commit()
    comm.Send([source,1,newvectortype],dest=the_other)
    newvectortype.Free()
elif procid==receiver:
    comm.Recv([target,count,MPI.DOUBLE],source=the_other)
</pre>
</div>
</div>
</p>

<!-- environment: mplnote start embedded generator -->
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->

<p name="switchToTextMode">
  MPL has the 
<tt>strided_vector_layout</tt>
  of the vector type:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vectormpl" aria-expanded="false" aria-controls="vectormpl">
        C++ Code: vectormpl
      </button>
    </h5>
  </div>
  <div id="vectormpl" class="collapse">
  <pre>
// vector.cxx
vector&lt;double&gt;
  source(stride*count);
if (procno==sender) {
  mpl::strided_vector_layout&lt;double&gt;
    newvectortype(count,1,stride);
  comm_world.send
    (source.data(),newvectortype,the_other);
}
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
  (See note&nbsp;
6.1
 for nonstrided vectors.)
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Two-dimensionalarrays">6.3.3.1</a> Two-dimensional arrays</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Vectortype">Vector type</a> > <a href="mpi-data.html#Two-dimensionalarrays">Two-dimensional arrays</a>
</p>
</p>

<p name="switchToTextMode">
Figure&nbsp;
6.4
 indicates one source of irregular
data:
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/blasmatrix.jpeg" width=800></img>
<p name="caption">
FIGURE 6.4: Memory layout of a row and column of a matrix in column-major storage
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
with a matrix on 
<i>column-major storage</i>
, a column is
stored in contiguous memory. However, a row of such a matrix
is not contiguous; its elements being separated by a 
<i>stride</i>
equal to the column length.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

  How would you describe the memory layout of a submatrix,
  if the whole matrix has size $M\times N$ and the submatrix $m\times n$?
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<!-- environment: answer start embedded generator -->
<!-- environment block purpose: [[ environment=answer ]] -->
<answer>


</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

As an example of this datatype, consider the example of transposing
a matrix, for instance to convert between
C and Fortran arrays (see section&nbsp;
<i>Eijkhout:IntroHPC</i>
). Suppose that
a processor has a matrix stored in&nbsp;C, row-major, layout, and it needs
to send a column to another processor. If the matrix is declared as
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
  int M,N; double mat[M][N]
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
then a column has $M$ blocks of one element, spaced $N$&nbsp;locations apart.
In other words:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Datatype MPI_column;
MPI_Type_vector(
    /* count= */ M, /* blocklength= */ 1, /* stride= */ N,
    MPI_DOUBLE, &MPI_column );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Sending the first column is easy:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Send( mat, 1,MPI_column, ... );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
The second column is just a little trickier: you now need to pick out
elements with the same stride, but starting at 
<tt>A[0][1]</tt>
.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Send( &(mat[0][1]), 1,MPI_column, ... );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
You can make this marginally more efficient (and harder to read)
by replacing the index expression by 
<tt>mat+1</tt>
.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Suppose you have a matrix of size $4N\times 4N$, and you want to
  send the elements 
<tt>A[4*i][4*j]</tt>
 with $i,j=0,&hellip;,N-1$. How would
  you send these elements with a single transfer?
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<!-- environment: answer start embedded generator -->
<!-- environment block purpose: [[ environment=answer ]] -->
<answer>


</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

  Allocate a matrix on processor zero, using Fortran column-major storage.
  Using $P$ sendrecv calls, distribute the rows of this matrix among the
  processors.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- environment: pythonnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  In C and Fortran it's easy to apply a derived type
  to data in the middle of an array,
  for instance to extract an arbitrary column out of a C&nbsp;matrix,
  or row out of a Fortran matrix.
  While Python has no trouble describing sections from an array,
  usually it copies these instead of taking the address.
  Therefore, it is necessary to convert the matrix
  to a buffer and compute an explicit offset in bytes:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#pmatcolsend" aria-expanded="false" aria-controls="pmatcolsend">
        Text: pmatcolsend
      </button>
    </h5>
  </div>
  <div id="pmatcolsend" class="collapse">
  <pre>
## rowcol.py
rowsize = 4; colsize = 5
coltype = MPI.INT.Create_vector(4, 1, 5)
coltype.Commit()
columntosend = 2
    comm.Send\
        ( [np.frombuffer(matrix.data, np.intc,
                         offset=columntosend*np.dtype('intc').itemsize),
           1,coltype],
          receiver)
</pre>
</div>
</div>
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/stridesend.png" width=800></img>
<p name="caption">
FIGURE 6.5: Send strided data from process zero to all others
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

  Let processor&nbsp;0 have an array&nbsp;$x$ of length $10P$, where $P$&nbsp;is the number of processors.
  Elements $0,P,2P,&hellip;,9P$ should go to processor zero, $1,P+1,2P+1,&hellip;$ to processor&nbsp;1,
  et cetera. Code this as a sequence of send/recv calls, using a vector datatype
  for the send, and a contiguous buffer for the receive.
</p>

<p name="switchToTextMode">
  For simplicity, skip the send to/from zero. What is the most elegant
  solution if you want to include that case?
</p>

<p name="switchToTextMode">
  For testing, define the array as $x[i]=i$.
<!-- skeleton start: stridesend -->
<button id="runBtnstridesend">Compile and run stridesend</button>
<div id="editorDivstridesend" 
     style="height:125px;border:1px solid black; 
     resize:vertical; overflow: hidden;"></div>
<pre id="outputPrestridesend"></pre>
<script name="defSkeletonstridesend">
let examplestridesend = new Example(
    "runBtnstridesend", "editorDivstridesend", "outputPrestridesend", 
    "skeletons/stridesend.c", "stridesend.c",
    "mpicc stridesend.c && mpiexec -n 4 ./a.out" );
examplestridesend.initialize();
</script>
<!-- skeleton end: stridesend -->
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Write code to compare the time it takes to send a strided subset
  from an array: copy the elements by hand to a smaller buffer, or use
  a vector data type. What do you find? You may need to test on fairly
  large arrays.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Subarraytype">6.3.4</a> Subarray type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Subarraytype">Subarray type</a>
</p>

</p>

<p name="switchToTextMode">
The vector datatype can be used for blocks in an array of dimension
more than&nbsp;2 by using it recursively. However, this gets
tedious. Instead, there is an explicit subarray type
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_subarray" aria-expanded="false" aria-controls="MPI_Type_create_subarray">
        Routine reference: MPI_Type_create_subarray
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_subarray" class="collapse">
  <pre>
Semantics:
MPI_TYPE_CREATE_SUBARRAY(
    ndims, array_of_sizes, array_of_subsizes,
    array_of_starts, order, oldtype, newtype)
IN ndims: number of array dimensions (positive integer)
IN array_of_sizes: number of elements of type oldtype in each dimension
    of the full array (array of positive integers)
IN array_of_subsizes: number of elements of type oldtype in each
    dimension of the subarray (array of positive integers)
IN array_of_starts: starting coordinates of the subarray in each
    dimension (array of non-negative integers)
IN order: array storage order flag (state)
IN oldtype: array element datatype (handle)
OUT newtype: new datatype (handle)

C:
int MPI_Type_create_subarray(
    int ndims, const int array_of_sizes[],
    const int array_of_subsizes[], const int array_of_starts[],
    int order, MPI_Datatype oldtype, MPI_Datatype *newtype)

Fortran:
MPI_Type_create_subarray(ndims, array_of_sizes, array_of_subsizes,
    array_of_starts, order, oldtype, newtype, ierror)
INTEGER, INTENT(IN) :: ndims, array_of_sizes(ndims),
    array_of_subsizes(ndims), array_of_starts(ndims), order
TYPE(MPI_Datatype), INTENT(IN) :: oldtype
TYPE(MPI_Datatype), INTENT(OUT) :: newtype
INTEGER, OPTIONAL, INTENT(OUT) :: ierror

Python:
MPI.Datatype.Create_subarray
   (self, sizes, subsizes, starts, int order=ORDER_C)
</pre>
</div>
</div>
<i>MPI_Type_create_subarray</i>
This describes the dimensionality and extent of the array, and
the starting point (the `upper left corner') and extent of the
subarray.
</p>

<!-- environment: mplnote start embedded generator -->
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  The templated 
<tt>subarray_layout</tt>
  from a vector of triplets of global size&nbsp;/ subblock size&nbsp;/ first coordinate.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
mpl::subarray_layout&lt;int&gt;(
 { {ny, ny_l, ny_0}, {nx, nx_l, nx_0} }
);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

<!-- skeleton start: cubegather -->
<button id="runBtncubegather">Compile and run cubegather</button>
<div id="editorDivcubegather" 
     style="height:125px;border:1px solid black; 
     resize:vertical; overflow: hidden;"></div>
<pre id="outputPrecubegather"></pre>
<script name="defSkeletoncubegather">
let examplecubegather = new Example(
    "runBtncubegather", "editorDivcubegather", "outputPrecubegather", 
    "skeletons/cubegather.c", "cubegather.c",
    "mpicc cubegather.c && mpiexec -n 4 ./a.out" );
examplecubegather.initialize();
</script>
<!-- skeleton end: cubegather -->
</p>

<p name="switchToTextMode">
  Assume that your number of processors is $P=Q^3$, and that each
  process has an array of identical size. Use
<tt>MPI_Type_create_subarray</tt>
 to gather all data onto a root process.
  Use a sequence of send and receive calls;
<tt>MPI_Gather</tt>
 does not work here.
</p>

<!-- environment: tacc start embedded generator -->
<!-- environment block purpose: [[ environment=tacc ]] -->
<tacc>

<p name="tacc">
<!-- TranslatingLineGenerator tacc ['tacc'] -->
If you haven't started 
<tt>idev</tt>
 with the right number of processes,
use
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
ibrun -np 27 cubegather
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Normally you use 
<tt>ibrun</tt>
 without process count argument.
</p name="tacc">

</tacc>
<!-- environment: tacc end embedded generator -->
<p name="switchToTextMode">

</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

Subarrays are naturally supported in Fortran through array sections:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#fsectionsend" aria-expanded="false" aria-controls="fsectionsend">
        Fortran Code: fsectionsend
      </button>
    </h5>
  </div>
  <div id="fsectionsend" class="collapse">
  <pre>
!! section.F90
  integer,parameter :: siz=20
  real,dimension(siz,siz) :: matrix = [ ((j+(i-1)*siz,i=1,siz),j=1,siz) ]
  real,dimension(2,2) :: submatrix
  if (procno==0) then
     call MPI_Send(matrix(1:2,1:2),4,MPI_REAL,1,0,comm)
  else if (procno==1) then
     call MPI_Recv(submatrix,4,MPI_REAL,0,0,comm,MPI_STATUS_IGNORE)
     if (submatrix(2,2)==22) then
        print *,"Yay"
     else
        print *,"nay...."
     end if
  end if
</pre>
</div>
</div>
at least, since \mpistandard{3}.
</p>

<p name="switchToTextMode">
The possibilities for the 
<tt>order</tt>
 parameter are
<tt>MPI_ORDER_C</tt>
 and 
<tt>MPI_ORDER_FORTRAN</tt>
.
However, this has nothing to do with the order of traversal of elements;
it determines how the bounds of the subarray are interpreted.
As an example, we fill a $4\times 4$ array in C&nbsp;order with the numbers&nbsp;$0\cdots15$,
and send the $[0,1]\times [0\cdots4]$ slice two ways,
first C&nbsp;order, then Fortran order:
\cverbatimsnippet[code/mpi/c/row2col.c]{row2colsub}
</p>

<p name="switchToTextMode">
The receiver receives the following, formatted to bring out
where the numbers originate:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
Received C order:
 0.000 1.000 2.000 3.000
 4.000 5.000 6.000 7.000
Received F order:
 0.000 1.000
 4.000 5.000
 8.000 9.000
 12.000 13.000
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Indexedtype">6.3.5</a> Indexed type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Indexedtype">Indexed type</a>
</p>

</p>

<p name="switchToTextMode">
The indexed datatype, constructed with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_indexed" aria-expanded="false" aria-controls="MPI_Type_indexed">
        Routine reference: MPI_Type_indexed
      </button>
    </h5>
  </div>
  <div id="MPI_Type_indexed" class="collapse">
  <pre>
Semantics:
count [in] number of blocks --
    also number of entries in indices and blocklens
blocklens [in] number of elements in each block
    (array of nonnegative integers)
indices [in] displacement of each block in multiples of old_type
    (array of integers)
old_type [in] old datatype (handle)
newtype [out] new datatype (handle)

C:
int MPI_Type_indexed(int count,
    const int array_of_blocklengths[],
    const int array_of_displacements[],
    MPI_Datatype oldtype, MPI_Datatype
    *newtype)

Fortran:
MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements,
    oldtype, newtype, ierror)
INTEGER, INTENT(IN) :: count, array_of_blocklengths(count),
array_of_displacements(count)
TYPE(MPI_Datatype), INTENT(IN) :: oldtype
TYPE(MPI_Datatype), INTENT(OUT) :: newtype
INTEGER, OPTIONAL, INTENT(OUT) :: ierror

Python:
MPI.Datatype.Create_vector(self, blocklengths,displacements )
</pre>
</div>
</div>
<i>MPI_Type_indexed</i>
can send arbitrarily located elements from an array of a single datatype.
You need to supply an array of index locations, plus an array of blocklengths
with a separate blocklength for each index. The total number of elements sent
is the sum of the blocklengths.
</p>

<!-- environment: figure start embedded generator -->
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/data-indexed.jpeg" width=800></img>
<p name="caption">
FIGURE 6.6: The elements of an MPI Indexed datatype
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

The following example picks items that are on prime number-indexed
locations.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#indexed" aria-expanded="false" aria-controls="indexed">
        C Code: indexed
      </button>
    </h5>
  </div>
  <div id="indexed" class="collapse">
  <pre>
// indexed.c
displacements = (int*) malloc(count*sizeof(int));
blocklengths = (int*) malloc(count*sizeof(int));
source = (int*) malloc(totalcount*sizeof(int));
target = (int*) malloc(targetbuffersize*sizeof(int));
MPI_Datatype newvectortype;
if (procno==sender) {
  MPI_Type_indexed(count,blocklengths,displacements,MPI_INT,&newvectortype);
  MPI_Type_commit(&newvectortype);
  MPI_Send(source,1,newvectortype,the_other,0,comm);
  MPI_Type_free(&newvectortype);
} else if (procno==receiver) {
  MPI_Status recv_status;
  int recv_count;
  MPI_Recv(target,targetbuffersize,MPI_INT,the_other,0,comm,
    &recv_status);
  MPI_Get_count(&recv_status,MPI_INT,&recv_count);
  ASSERT(recv_count==count);
}
</pre>
</div>
</div>
For Fortran we show the legacy syntax for once:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#indexed-f" aria-expanded="false" aria-controls="indexed-f">
        Fortran Code: indexed-f
      </button>
    </h5>
  </div>
  <div id="indexed-f" class="collapse">
  <pre>
!! indexed.F90
  integer :: newvectortype;
  ALLOCATE(indices(count))
  ALLOCATE(blocklengths(count))
  ALLOCATE(source(totalcount))
  ALLOCATE(targt(count))
  if (mytid==sender) then
     call MPI_Type_indexed(count,blocklengths,indices,MPI_INT,&
          newvectortype,err)
     call MPI_Type_commit(newvectortype,err)
     call MPI_Send(source,1,newvectortype,receiver,0,comm,err)
     call MPI_Type_free(newvectortype,err)
  else if (mytid==receiver) then
    call MPI_Recv(targt,count,MPI_INT,sender,0,comm,&
         recv_status,err)
    call MPI_Get_count(recv_status,MPI_INT,recv_count,err)
    !    ASSERT(recv_count==count);
 end if
</pre>
</div>
</div>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#indexp" aria-expanded="false" aria-controls="indexp">
        Python Code: indexp
      </button>
    </h5>
  </div>
  <div id="indexp" class="collapse">
  <pre>
## indexed.py
displacements = np.empty(count,dtype=np.int)
blocklengths = np.empty(count,dtype=np.int)
source = np.empty(totalcount,dtype=np.float64)
target = np.empty(count,dtype=np.float64)
if procid==sender:
    newindextype = MPI.DOUBLE.Create_indexed(blocklengths,displacements)
    newindextype.Commit()
    comm.Send([source,1,newindextype],dest=the_other)
    newindextype.Free()
elif procid==receiver:
    comm.Recv([target,count,MPI.DOUBLE],source=the_other)
</pre>
</div>
</div>
</p>

<!-- environment: mplnote start embedded generator -->
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  In 
<span title="acronym" ><i>MPL</i></span>
, the 
<tt>indexed_layout</tt>
  of 2-tuples denoting block length&nbsp;/ block location.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#indexedmpl" aria-expanded="false" aria-controls="indexedmpl">
        C++ Code: indexedmpl
      </button>
    </h5>
  </div>
  <div id="indexedmpl" class="collapse">
  <pre>
// indexed.cxx
const int count = 5;
mpl::contiguous_layout&lt;int&gt;
  fiveints(count);
mpl::indexed_layout&lt;int&gt;
  indexed_where{ { {1,2}, {1,3}, {1,5}, {1,7}, {1,11} } };

if (procno==sender) {
  comm_world.send( source_buffer.data(),indexed_where, receiver );
} else if (procno==receiver) {
  auto recv_status =
    comm_world.recv( target_buffer.data(),fiveints, sender );
  int recv_count = recv_status.get_count&lt;int&gt;();
  assert(recv_count==count);
}
</pre>
</div>
</div>
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  The size/displacement arrays for 
<tt>MPI_Gatherv</tt>
&nbsp;/
<tt>MPI_Alltoallv</tt>
 are handled through a
<tt>layouts</tt>
<tt>layout</tt>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#mpllayouts" aria-expanded="false" aria-controls="mpllayouts">
        C++ Code: mpllayouts
      </button>
    </h5>
  </div>
  <div id="mpllayouts" class="collapse">
  <pre>
mpl::layouts&lt;int&gt; receive_layout;
for ( int iproc=0,loc=0; iproc&lt;nprocs; iproc++ ) {
  auto siz = size_buffer.at(iproc);
  receive_layout.push_back
	( mpl::indexed_layout&lt;int&gt;( {{ siz,loc }} ) );
  loc += siz;
}
</pre>
</div>
</div>
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  For the case where all block lengths are the same,
  use 
<tt>indexed_block_layout</tt>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#indexedbmpl" aria-expanded="false" aria-controls="indexedbmpl">
        C++ Code: indexedbmpl
      </button>
    </h5>
  </div>
  <div id="indexedbmpl" class="collapse">
  <pre>
// indexedblock.cxx
mpl::indexed_block_layout&lt;int&gt;
  indexed_where(  1, {2,3,5,7,11} );
comm_world.send( source_buffer.data(),indexed_where, receiver );
</pre>
</div>
</div>
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

You can also 
<tt>MPI_Type_create_hindexed</tt>
 which describes blocks
of a single old type, but with index locations in bytes, rather than
in multiples of the old type.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int MPI_Type_create_hindexed
 (int count, int blocklens[], MPI_Aint indices[],
  MPI_Datatype old_type,MPI_Datatype *newtype)
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
A slightly simpler version,
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_hindexed_block" aria-expanded="false" aria-controls="MPI_Type_create_hindexed_block">
        Routine reference: MPI_Type_create_hindexed_block
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_hindexed_block" class="collapse">
  <pre>
int MPI_Type_create_hindexed_block
   (int count,int blocklength,
    const MPI_Aint array_of_displacements[],
    MPI_Datatype oldtype, MPI_Datatype *newtype)

Input Parameters:
count : length of array of displacements (integer)
blocklength : size of block (integer)
array_of_displacements : array of displacements (array of integer)
oldtype : old datatype (handle)

Output Parameter:
newtype : new datatype (handle)
</pre>
</div>
</div>
<i>MPI_Type_create_hindexed_block</i>
assumes constant block length.
</p>

<p name="switchToTextMode">
There is an important difference between the 
<tt>hindexed</tt>
 and the
above 
<tt>MPI_Type_indexed</tt>
: that one described offsets from
a base location; these routines describes absolute memory addresses.
You can use this to send for instance the elements of a linked list.
You would traverse the list, recording the addresses of the
elements with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Get_address" aria-expanded="false" aria-controls="MPI_Get_address">
        Routine reference: MPI_Get_address
      </button>
    </h5>
  </div>
  <div id="MPI_Get_address" class="collapse">
  <pre>
C:
int MPI_Get_address
   (void *location,
    MPI_Aint *address
    );

Input Parameters:
location : location in caller memory (choice)

Output parameters:
address : address of location (address)
</pre>
</div>
</div>
<i>MPI_Get_address</i>
.
(The routine 
</p>

<p name="switchToTextMode">
In C++ you can use this to
send an 
<tt>std::&lt;vector&gt;</tt>

<!-- index -->
, that
is, a vector object from the 
<i>C++ standard library</i>
, if
the component type is a pointer.
</p>

<h3><a id="Structtype">6.3.6</a> Struct type</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Deriveddatatypes">Derived datatypes</a> > <a href="mpi-data.html#Structtype">Struct type</a>
</p>

<p name="switchToTextMode">

The structure type, created with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_struct" aria-expanded="false" aria-controls="MPI_Type_create_struct">
        Routine reference: MPI_Type_create_struct
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_struct" class="collapse">
  <pre>
C:
int MPI_Type_create_struct(
  int count, int blocklengths[], MPI_Aint displacements[],
  MPI_Datatype types[], MPI_Datatype *newtype);


</pre>
</div>
</div>
<i>MPI_Type_create_struct</i>
,
can contain multiple data types. (The routine
<tt>MPI_Type_struct</tt>
 is deprecated with \mpistandard{3}.)
<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/data-struct.jpeg" width=800></img>
<p name="caption">
FIGURE 6.7: The elements of an MPI Struct datatype
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
The specification contains a `count' parameter that specifies how many blocks
there are in a single structure. For instance,
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
struct {
 int i;
 float x,y;
} point;
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
has two blocks, one of a single integer, and one of two floats.
This is illustrated in figure&nbsp;
6.7
.
</p>

<!-- environment: description start embedded generator -->
<!-- environment block purpose: [[ environment=description ]] -->
<description>
<ul>
<!-- TranslatingLineGenerator description ['description'] -->
<li>
[
<tt>count</tt>
] The number of blocks in this
  datatype. The 
<tt>blocklengths</tt>
, 
<tt>displacements</tt>
, 
<tt>types</tt>

  arguments have to be at least of this length.
<li>
[
<tt>blocklengths</tt>
] array containing the lengths of the blocks of each datatype.
<li>
[
<tt>displacements</tt>
] array describing the relative location
  of the blocks of each datatype.
<li>
[
<tt>types</tt>
] array containing the datatypes; each block in
  the new type is of a single datatype; there can be multiple
  blocks consisting of the same type.
</ul>
</description>
<!-- environment: description end embedded generator -->
<p name="switchToTextMode">
In this example, unlike the previous ones, both sender and receiver
create the structure type. With structures it is no longer possible to
send as a derived type and receive as a array of a simple type.
(It would be possible to send as one structure type and receive as another,
as long as they have the same 
<i>datatype signature</i>
.)
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#structure" aria-expanded="false" aria-controls="structure">
        C Code: structure
      </button>
    </h5>
  </div>
  <div id="structure" class="collapse">
  <pre>
// struct.c
struct object {
  char c;
  double x[2];
  int i;
};
MPI_Datatype newstructuretype;
int structlen = 3;
int blocklengths[structlen]; MPI_Datatype types[structlen];
MPI_Aint displacements[structlen];

/*
 * where are the components relative to the structure?
 */
MPI_Aint current_displacement=0;

// one character
blocklengths[0] = 1; types[0] = MPI_CHAR;
displacements[0] = (size_t)&(myobject.c) - (size_t)&myobject;

// two doubles
blocklengths[1] = 2; types[1] = MPI_DOUBLE;
displacements[1] = (size_t)&(myobject.x) - (size_t)&myobject;

// one int
blocklengths[2] = 1; types[2] = MPI_INT;
displacements[2] = (size_t)&(myobject.i) - (size_t)&myobject;

MPI_Type_create_struct(structlen,blocklengths,displacements,types,&newstructuretype);
MPI_Type_commit(&newstructuretype);
if (procno==sender) {
  MPI_Send(&myobject,1,newstructuretype,the_other,0,comm);
} else if (procno==receiver) {
  MPI_Recv(&myobject,1,newstructuretype,the_other,0,comm,MPI_STATUS_IGNORE);
}
MPI_Type_free(&newstructuretype);
</pre>
</div>
</div>
<p name="switchToTextMode">

Note the 
<tt>displacement</tt>
 calculations in this example,
which involve some not so elegant pointer arithmetic.
The following Fortran code uses 
<tt>MPI_Get_address</tt>
,
which is more elegant, and in fact
the only way address calculations can be done in Fortran.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#fstructure" aria-expanded="false" aria-controls="fstructure">
        Fortran Code: fstructure
      </button>
    </h5>
  </div>
  <div id="fstructure" class="collapse">
  <pre>
!! struct.F90
  Type object
     character :: c
     real*8,dimension(2) :: x
     integer :: i
  end type object
  type(object) :: myobject
  integer,parameter :: structlen = 3
  type(MPI_Datatype) :: newstructuretype
  integer,dimension(structlen) :: blocklengths
  type(MPI_Datatype),dimension(structlen) :: types;
  MPI_Aint,dimension(structlen) :: displacements
  MPI_Aint :: base_displacement, next_displacement
  if (procno==sender) then
     myobject%c = 'x'
     myobject%x(0) = 2.7; myobject%x(1) = 1.5
     myobject%i = 37

  !! component 1: one character
  blocklengths(1) = 1; types(1) = MPI_CHAR
  call MPI_Get_address(myobject,base_displacement)
  call MPI_Get_address(myobject%c,next_displacement)
  displacements(1) = next_displacement-base_displacement

  !! component 2: two doubles
  blocklengths(2) = 2; types(2) = MPI_DOUBLE
  call MPI_Get_address(myobject%x,next_displacement)
  displacements(2) = next_displacement-base_displacement

  !! component 3: one int
  blocklengths(3) = 1; types(3) = MPI_INT
  call MPI_Get_address(myobject%i,next_displacement)
  displacements(3) = next_displacement-base_displacement

  if (procno==sender) then
     call MPI_Send(myobject,1,newstructuretype,receiver,0,comm)
  else if (procno==receiver) then
     call MPI_Recv(myobject,1,newstructuretype,sender,0,comm,MPI_STATUS_IGNORE)
  end if
  call MPI_Type_free(newstructuretype)
</pre>
</div>
</div>
<p name="switchToTextMode">

It would have been incorrect to write
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
displacement[0] = 0;
displacement[1] = displacement[0] + sizeof(char);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
since you do not know the way the 
<i>compiler</i>
 lays out the
structure in memory\footnote{Homework question: what does the language
  standard say about this?}.
</p>

<p name="switchToTextMode">
If you want to send more than one structure, you have to worry more
about padding in the structure. You can solve this by adding an extra
type 
<tt>MPI_UB</tt>
 for the `upper bound' on the structure:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
displacements[3] = sizeof(myobject); types[3] = MPI_UB;
MPI_Type_create_struct(struclen+1,.....);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  One could describe the MPI struct type as a collection of
  displacements, to be applied to any set of items that conforms
  to the specifications.
  An 
<span title="acronym" ><i>MPL</i></span>
<tt>heterogeneous_layout</tt>
  incorporates the actual data. Thus you could write
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#structuremplscalar" aria-expanded="false" aria-controls="structuremplscalar">
        C++ Code: structuremplscalar
      </button>
    </h5>
  </div>
  <div id="structuremplscalar" class="collapse">
  <pre>
// structscalar.cxx
char c; double x; int i;
if (procno==sender) {
  c = 'x'; x = 2.4; i = 37; }
mpl::heterogeneous_layout object( c,x,i );
if (procno==sender)
  comm_world.send( mpl::absolute,object,receiver );
else if (procno==receiver)
  comm_world.recv( mpl::absolute,object,sender );
</pre>
</div>
</div>
  Here, the 
<tt>absolute</tt>
  the layout is absolute rather than a relative description.
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- environment: mplnote start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  More complicated data than scalars takes more work:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#structurempl" aria-expanded="false" aria-controls="structurempl">
        C++ Code: structurempl
      </button>
    </h5>
  </div>
  <div id="structurempl" class="collapse">
  <pre>
// struct.cxx
char c; vector&lt;double&gt; x(2); int i;
if (procno==sender) {
  c = 'x'; x[0] = 2.7; x[1] = 1.5; i = 37; }
mpl::heterogeneous_layout object
  ( c,
    mpl::make_absolute(x.data(),mpl::vector_layout&lt;double&gt;(2)),
    i );
if (procno==sender) {
  comm_world.send( mpl::absolute,object,receiver );
} else if (procno==receiver) {
  comm_world.recv( mpl::absolute,object,sender );
}
</pre>
</div>
</div>
  Note the 
<tt>make_absolute</tt>
<tt>absolute</tt>
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<!-- TranslatingLineGenerator file ['file'] -->
</p>

<h2><a id="Bigdatatypes">6.4</a> Big data types</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a>
</p>

<!-- index -->
<p name="switchToTextMode">

The 
<tt>size</tt>
 parameter in MPI send and receive calls is of type integer,
meaning that it's maximally~$2^{31}-1$. These day computers are big enough
that this is a limitation.
As of the MPI~\mpistandard{4} standard, this has been solved by allowing a
larger count parameter.
The implementation of this depends somewhat on the language.
</p>

<p name="switchToTextMode">
\begin{mpifournote}
{MPI Count type}
</p>

<h3><a id="C">6.4.1</a> C</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a> > <a href="mpi-data.html#C">C</a>
</p>

<p name="switchToTextMode">

For every routine, such as 
<tt>MPI_Send</tt>
 with an integer count,
there is a corresponding 
<tt>MPI_Send_c</tt>
 with a count
of type 
<tt>MPI_Count</tt>
.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#reducecount" aria-expanded="false" aria-controls="reducecount">
        C Code: reducecount
      </button>
    </h5>
  </div>
  <div id="reducecount" class="collapse">
  <pre>
MPI_Count buffersize = 1000;
double *indata,*outdata;
indata = (double*) malloc( buffersize*sizeof(double) );
outdata = (double*) malloc( buffersize*sizeof(double) );
MPI_Allreduce_c(indata,outdata,buffersize,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
</pre>
</div>
</div>
<p name="switchToTextMode">

<h3><a id="Fortran">6.4.2</a> Fortran</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a> > <a href="mpi-data.html#Fortran">Fortran</a>
</p>
</p>

<p name="switchToTextMode">
The count parameter can be declared  to be
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
Integer(kind=MPI_COUNT_KIND) :: count
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Since Fortran has polymorphism, the same routine names can be used.
</p>

<p name="switchToTextMode">
\end{mpifournote}
</p>

<h3><a id="Countdatatype">6.4.3</a> Count datatype</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a> > <a href="mpi-data.html#Countdatatype">Count datatype</a>
</p>
<p name="switchToTextMode">

The 
<tt>MPI_Count</tt>
 datatype is defined as being large enough
to accomodate values of
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
the ordinary 4-byte integer type;
<li>
the 
<tt>MPI_Aint</tt>
 type, sections
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Byteaddressingtype">6.2.4</a>
 and&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Byteaddressingtype">6.2.4</a>
;
<li>
the 
<tt>MPI_Offset</tt>
 type, section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-io.html#Individualfilepointers,contiguouswrites">10.2.2</a>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

The  <tt>size_t</tt>  type in&nbsp;C/C++ is defined as big enough to
contain the output of  <tt>sizeof</tt> , that is,
being big enough to measure any object.
</p>

<h3><a id="MPI3temporarysolution">6.4.4</a> MPI 3 temporary solution</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Bigdatatypes">Big data types</a> > <a href="mpi-data.html#MPI3temporarysolution">MPI 3 temporary solution</a>
</p>
<p name="switchToTextMode">

Large messages were already possible by using
derived types: to send
a 
<i>big data type</i>
 of $10^{40}$ elements you would
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
create a contiguous type with $10^{20}$ elements, and
<li>
send $10^{20}$ elements of that type.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
This often works, but it's not perfect. For instance, the routine
<tt>MPI_Get_elements</tt>
 returns the total number of basic elements sent
(as opposed to 
<tt>MPI_Get_count</tt>
 which would return the number
of elements of the derived type). Since its output argument is
of integer type, it can't store the right value.
</p>

<p name="switchToTextMode">
The \mpistandard{3} standard has addressed this
through the introduction of an 
<tt>MPI_Count</tt>
 datatype,
and new routines that return that type of count.
(In view of the `embiggened' routins, this solution
is no longer needed, and will probably be deprecated in later standards.)
</p>

<p name="switchToTextMode">
Let us consider an example.
</p>

<p name="switchToTextMode">
Allocating a buffer of more than 4Gbyte is not hard:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bigvectoralloc" aria-expanded="false" aria-controls="bigvectoralloc">
        C Code: bigvectoralloc
      </button>
    </h5>
  </div>
  <div id="bigvectoralloc" class="collapse">
  <pre>
// vectorx.c
float *source=NULL,*target=NULL;
int mediumsize = 1&lt;&lt;30;
int nblocks = 8;
size_t datasize = (size_t)mediumsize * nblocks * sizeof(float);
if (procno==sender) {
  source = (float*) malloc(datasize);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
We use the trick with sending elements of a derived type:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bigvectorptp" aria-expanded="false" aria-controls="bigvectorptp">
        C Code: bigvectorptp
      </button>
    </h5>
  </div>
  <div id="bigvectorptp" class="collapse">
  <pre>
MPI_Datatype blocktype;
MPI_Type_contiguous(mediumsize,MPI_FLOAT,&blocktype);
MPI_Type_commit(&blocktype);
if (procno==sender) {
  MPI_Send(source,nblocks,blocktype,receiver,0,comm);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
We use the same trick for the receive call, but now we catch the status
parameter which will later tell us how many elements of the basic type
were sent:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bigvectorrecv" aria-expanded="false" aria-controls="bigvectorrecv">
        C Code: bigvectorrecv
      </button>
    </h5>
  </div>
  <div id="bigvectorrecv" class="collapse">
  <pre>
} else if (procno==receiver) {
  MPI_Status recv_status;
  MPI_Recv(target,nblocks,blocktype,sender,0,comm,
    &recv_status);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
When we query how many of the basic elements are in the buffer
(remember that in the receive call the buffer length is
an upper bound on the number of elements received)
do we
need a counter that is larger than an integer.  MPI has introduced a
type 
<tt>MPI_Count</tt>
 for this, and new routines such as
<i>MPI_Get_elements_x</i>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Get_elements_x" aria-expanded="false" aria-controls="MPI_Get_elements_x">
        Routine reference: MPI_Get_elements_x
      </button>
    </h5>
  </div>
  <div id="MPI_Get_elements_x" class="collapse">
  <pre>
Synopsis
Returns the number of basic elements in a datatype

int MPI_Get_elements
    (const MPI_Status *status, MPI_Datatype datatype, int *count)
int MPI_Get_elements_x
    (const MPI_Status *status, MPI_Datatype datatype, MPI_Count *count)

Input Parameters:
status : return status of receive operation (Status)
datatype : datatype used by receive operation (handle)

Output Parameters:
count : number of received basic elements (integer/MPI_Count)
</pre>
</div>
</div>
 that return a
count of this type:
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#bigvectorq" aria-expanded="false" aria-controls="bigvectorq">
        C Code: bigvectorq
      </button>
    </h5>
  </div>
  <div id="bigvectorq" class="collapse">
  <pre>
MPI_Count recv_count;
MPI_Get_elements_x(&recv_status,MPI_FLOAT,&recv_count);
</pre>
</div>
</div>
<p name="switchToTextMode">

<!-- environment: remark start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=remark ]] -->
<remark>
<b>Remark</b>
<p name="remark">
<!-- TranslatingLineGenerator remark ['remark'] -->
  Computing a big number to allocate is not entirely simple.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#compsizet" aria-expanded="false" aria-controls="compsizet">
        C Code: compsizet
      </button>
    </h5>
  </div>
  <div id="compsizet" class="collapse">
  <pre>
// getx.c
int gig = 1&lt;&lt;30;
int nblocks = 8;
size_t big1 = gig * nblocks * sizeof(double);
size_t big2 = (size_t)1 * gig * nblocks * sizeof(double);
size_t big3 = (size_t) gig * nblocks * sizeof(double);
size_t big4 = gig * nblocks * (size_t) ( sizeof(double) );
size_t big5 = sizeof(double) * gig * nblocks;
;
</pre>
</div>
</div>
  gives as output:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
size of size_t = 8
0 68719476736 68719476736 0 68719476736
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Clearly, not only do operations go left-to-right, but casting is done that way too:
the computed subexpressions are only cast to 
<tt>size_t</tt>
 if one operand is.
</p name="remark">
</remark>
<!-- environment: remark end embedded generator -->
<p name="switchToTextMode">

Above, we did not actually create a datatype that was bigger than&nbsp;2G,
but if you do so, you can query its extent by
<i>MPI_Type_get_extent_x</i>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_get_extent_x" aria-expanded="false" aria-controls="MPI_Type_get_extent_x">
        Routine reference: MPI_Type_get_extent_x
      </button>
    </h5>
  </div>
  <div id="MPI_Type_get_extent_x" class="collapse">
  <pre>
Semantics:
MPI_Type_get_extent(datatype,lb,extent)
MPI_Type_get_extent_x(datatype,lb,extent)
MPI_Type_get_true_extent(datatype,true_lb,true_extent)
MPI_Type_get_true_extent_x(datatype,true_lb,true_extent)

Input argument:
datatype: Data type for which information is wanted (handle).

Output arguments:
lb / true_lb: (True) lower bound of data type (integer).
extent / true_extent: (True) extent of data type (integer).

C:
int MPI_Type_get_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_extent_x(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent_x(
    MPI_Datatype datatype,
    MPI_Count *true_lb, MPI_Count *true_extent)

Fortran
MPI_TYPE_GET_TRUE_EXTENT(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_ADDRESS_KIND) TRUE_LB, TRUE_EXTENT
MPI_TYPE_GET_TRUE_EXTENT_X(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_COUNT_KIND) TRUE_LB, TRUE_EXTENT


</pre>
</div>
</div>
and
<i>MPI_Type_get_true_extent_x</i>
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_get_true_extent_x" aria-expanded="false" aria-controls="MPI_Type_get_true_extent_x">
        Routine reference: MPI_Type_get_true_extent_x
      </button>
    </h5>
  </div>
  <div id="MPI_Type_get_true_extent_x" class="collapse">
  <pre>
Semantics:
MPI_Type_get_extent(datatype,lb,extent)
MPI_Type_get_extent_x(datatype,lb,extent)
MPI_Type_get_true_extent(datatype,true_lb,true_extent)
MPI_Type_get_true_extent_x(datatype,true_lb,true_extent)

Input argument:
datatype: Data type for which information is wanted (handle).

Output arguments:
lb / true_lb: (True) lower bound of data type (integer).
extent / true_extent: (True) extent of data type (integer).

C:
int MPI_Type_get_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_extent_x(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent_x(
    MPI_Datatype datatype,
    MPI_Count *true_lb, MPI_Count *true_extent)

Fortran
MPI_TYPE_GET_TRUE_EXTENT(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_ADDRESS_KIND) TRUE_LB, TRUE_EXTENT
MPI_TYPE_GET_TRUE_EXTENT_X(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_COUNT_KIND) TRUE_LB, TRUE_EXTENT


</pre>
</div>
</div>
.
</p>

<!-- environment: pythonnote start embedded generator -->
<!-- environment block purpose: [[ environment=pythonnote ]] -->
<remark>
<b>Python note</b>
<!-- TranslatingLineGenerator pythonnote ['pythonnote'] -->
<p name="switchToTextMode">
  Since python has unlimited size integers there is
  no explicit need for the `x' variants of routines.
  Internally,  <tt>MPI.Status.Get_elements</tt>  is implemented
  in terms of 
<tt>MPI_Get_elements_x</tt>
.
</remark>
<!-- environment: pythonnote end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
</p>

<p name="switchToTextMode">

<!-- TranslatingLineGenerator file ['file'] -->
</p>

<h2><a id="Typemapsandtypematching">6.5</a> Type maps and type matching</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typemapsandtypematching">Type maps and type matching</a>
</p>
<p name="switchToTextMode">

With derived types, you saw that it was not necessary for
the type of the sender and receiver to match.
Howver, when the send buffer is constructed,
and the receive buffer unpacked,
it is necessary for the successive types in that buffer to match.
</p>

<p name="switchToTextMode">
The types in the send and receive buffers also need to match
the datatypes of the underlying architecture, with two exceptions.
The 
<tt>MPI_PACKED</tt>
 and 
<tt>MPI_BYTE</tt>
 types
can match any underlying type.
However, this still does not mean that it is a good idea to use
these types on only sender or receiver, and a specific type on the other.
</p>

<h2><a id="Typeextent">6.6</a> Type extent</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a>
</p>

<p name="switchToTextMode">

See section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#MatchinglanguagetypetoMPItype">6.2.5</a>
about the related issue of type sizes.
</p>

<h3><a id="Extentandtrueextent">6.6.1</a> Extent and true extent</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentandtrueextent">Extent and true extent</a>
</p>
<p name="switchToTextMode">

The 
<i>datatype extent</i>

<!-- index -->
,
measured with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_get_extent" aria-expanded="false" aria-controls="MPI_Type_get_extent">
        Routine reference: MPI_Type_get_extent
      </button>
    </h5>
  </div>
  <div id="MPI_Type_get_extent" class="collapse">
  <pre>
Semantics:

int MPI_Type_get_extent(
    MPI_Datatype datatype,
    MPI_Aint *lb, MPI_Aint *extent
    );

datatype: [in] datatype to get information on (handle)
lb: [out] lower bound of datatype (integer)
extent: [out] extent of datatype (integer)
</pre>
</div>
</div>
<i>MPI_Type_get_extent</i>
,
is strictly the distance from the
first to the last data item of the type,
that is, with counting the gaps in the type.
It is measured in bytes so the output parameters are
of type  <tt>MPI_Aint</tt> .
</p>

<!-- environment: figure start embedded generator -->
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<p name="switchToTextMode">
  \includegraphics{extentvector}
<p name="caption">
FIGURE 6.8: Extent of a vector datatype
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

In the following example
(see also figure~
6.8
)
we measure the extent of a vector type.
Note that the extent is not the stride times the number of blocks,
because that would count a `trailing gap'.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#vectortypeextent" aria-expanded="false" aria-controls="vectortypeextent">
        C Code: vectortypeextent
      </button>
    </h5>
  </div>
  <div id="vectortypeextent" class="collapse">
  <pre>
MPI_Aint lb,asize;
MPI_Type_vector(count,bs,stride,MPI_DOUBLE,&newtype);
MPI_Type_commit(&newtype);
MPI_Type_get_extent(newtype,&lb,&asize);
ASSERT( lb==0 );
ASSERT( asize==((count-1)*stride+bs)*sizeof(double) );
MPI_Type_free(&newtype);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
Similarly, using 
<tt>MPI_Type_get_extent</tt>
 counts the gaps
in a 
<tt>struct</tt>
 induced by 
<i>alignment</i>
 issues.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#structextent" aria-expanded="false" aria-controls="structextent">
        C Code: structextent
      </button>
    </h5>
  </div>
  <div id="structextent" class="collapse">
  <pre>
size_t size_of_struct = sizeof(struct object);
MPI_Aint typesize,typelb;
MPI_Type_get_extent(newstructuretype,&typelb,&typesize);
assert( typesize==size_of_struct );
</pre>
</div>
</div>
See section~
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Structtype">6.3.6</a>
 for the code defining the structure type.
</p>

<!-- environment: remark start embedded generator -->
<!-- environment block purpose: [[ environment=remark ]] -->
<remark>
<b>Remark</b>
<p name="remark">
<!-- TranslatingLineGenerator remark ['remark'] -->
  Routine 
<tt>MPI_Type_get_extent</tt>
  replaces
  deprecated functions 
</p name="remark">
</remark>
<!-- environment: remark end embedded generator -->
<p name="switchToTextMode">

The 
<i>subarray datatype</i>

<!-- index -->
 need not
start at the first element of the buffer, so the extent is an
overstatement of how much data is involved. The routine
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_get_true_extent" aria-expanded="false" aria-controls="MPI_Type_get_true_extent">
        Routine reference: MPI_Type_get_true_extent
      </button>
    </h5>
  </div>
  <div id="MPI_Type_get_true_extent" class="collapse">
  <pre>
Semantics:
MPI_Type_get_extent(datatype,lb,extent)
MPI_Type_get_extent_x(datatype,lb,extent)
MPI_Type_get_true_extent(datatype,true_lb,true_extent)
MPI_Type_get_true_extent_x(datatype,true_lb,true_extent)

Input argument:
datatype: Data type for which information is wanted (handle).

Output arguments:
lb / true_lb: (True) lower bound of data type (integer).
extent / true_extent: (True) extent of data type (integer).

C:
int MPI_Type_get_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_extent_x(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent(
    MPI_Datatype datatype,
    MPI_Aint *true_lb, MPI_Aint *true_extent)
int MPI_Type_get_true_extent_x(
    MPI_Datatype datatype,
    MPI_Count *true_lb, MPI_Count *true_extent)

Fortran
MPI_TYPE_GET_TRUE_EXTENT(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_ADDRESS_KIND) TRUE_LB, TRUE_EXTENT
MPI_TYPE_GET_TRUE_EXTENT_X(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)
    INTEGER    DATATYPE, IERROR
    INTEGER(KIND=MPI_COUNT_KIND) TRUE_LB, TRUE_EXTENT


</pre>
</div>
</div>
<i>MPI_Type_get_true_extent</i>
 returns the lower bound,
indicating where the data starts, and the extent from that point.
</p>

<!-- environment: comment start embedded generator -->
<!-- environment block purpose: [[ environment=comment ]] -->
<comment>


</comment>
<!-- environment: comment end embedded generator -->
<p name="switchToTextMode">

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#trueextent" aria-expanded="false" aria-controls="trueextent">
        C Code: trueextent
      </button>
    </h5>
  </div>
  <div id="trueextent" class="collapse">
  <pre>
// trueextent.c
int sender = 0, receiver = 1, the_other = 1-procno,
  count = 4;
int sizes[2] = {4,6},subsizes[2] = {2,3},starts[2] = {1,2};
MPI_Datatype subarraytype;
if (procno==sender) {
  MPI_Type_create_subarray
    (2,sizes,subsizes,starts,MPI_ORDER_C,MPI_DOUBLE,&subarraytype);
  MPI_Type_commit(&subarraytype);

  MPI_Aint true_lb,true_extent,extent;
//    MPI_Type_get_extent(subarraytype,&extent);
  MPI_Type_get_true_extent
    (subarraytype,&true_lb,&true_extent);
  MPI_Aint
    comp_lb = sizeof(double) *
        ( starts[0]*sizes[1]+starts[1] );
    comp_extent = sizeof(double) *
        ( (starts[0]+subsizes[0]-1)*sizes[1] + starts[1]+subsizes[1] )
        - comp_lb;
//    ASSERT(extent==true_lb+extent);
  ASSERT(true_lb==comp_lb);
  ASSERT(true_extent==comp_extent);

  MPI_Send(source,1,subarraytype,the_other,0,comm);
  MPI_Type_free(&subarraytype);
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
There is also a `big data' routine 
<tt>MPI_Type_get_true_extent_x</tt>
that has an 
<tt>MPI_Count</tt>
 as output.
</p>

<h3><a id="Extentresizing">6.6.2</a> Extent resizing</h3>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentresizing">Extent resizing</a>
</p>
<p name="switchToTextMode">

A type is partly characterized by its lower bound and extent,
or equivalently lower bound and upperbound.
Somewhat miraculously, you can actually change these to achieve special effects.
This is needed for some cases of gather/scatter operations, or when the count
of derived items in a buffer is more than one.
</p>

<p name="switchToTextMode">
To understand the latter case, consider the vector type from the previous section.
It is clear that
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Type_vector( 2*count,bs,stride,oldtype,&two_n_type );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
will not give the same result as
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Type_vector( count,bs,stride,oldtype,&one_n_type );
MPI_Type_contiguous( 2,&one_n_type,&two_n_type );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

The problem here is that MPI uses the extent of the send type in a scatter,
or the receive type in a gather: if that type is 20 bytes big from
its first to its last element, then
data will be read out 20 bytes apart in a scatter, or written 20 bytes apart
in a gather. This ignores the `gaps' in the type!
</p>

<p name="switchToTextMode">
The technicality on which the solution hinges is that you can `resize' a type
with 
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Type_create_resized" aria-expanded="false" aria-controls="MPI_Type_create_resized">
        Routine reference: MPI_Type_create_resized
      </button>
    </h5>
  </div>
  <div id="MPI_Type_create_resized" class="collapse">
  <pre>
</pre>
</div>
</div>
<i>MPI_Type_create_resized</i>
to give it a different extent, while not affecting how much data there
actually is in it.
</p>

<h4><a id="Example1">6.6.2.1</a> Example 1</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentresizing">Extent resizing</a> > <a href="mpi-data.html#Example1">Example 1</a>
</p>
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<p name="switchToTextMode">
  \includegraphics{extentpad}
<p name="caption">
FIGURE 6.9: Effect of resizing a type
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

First consider sending more than one derived type,
from a buffer containing consecutive integers:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#twovectorsend" aria-expanded="false" aria-controls="twovectorsend">
        C Code: twovectorsend
      </button>
    </h5>
  </div>
  <div id="twovectorsend" class="collapse">
  <pre>
// vectorpadsend.c
for (int i=0; i&lt;max_elements; i++) sendbuffer[i] = i;
MPI_Type_vector(count,blocklength,stride,MPI_INT,&stridetype);
MPI_Type_commit(&stridetype);
MPI_Send( sendbuffer,ntypes,stridetype, receiver,0, comm );
</pre>
</div>
</div>
We receive into a contiguous buffer:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#twovectorrecv" aria-expanded="false" aria-controls="twovectorrecv">
        C Code: twovectorrecv
      </button>
    </h5>
  </div>
  <div id="twovectorrecv" class="collapse">
  <pre>
MPI_Recv( recvbuffer,max_elements,MPI_INT, sender,0, comm,&status );
int count; MPI_Get_count(&status,MPI_INT,&count);
printf("Receive %d elements:",count);
for (int i=0; i&lt;count; i++) printf(" %d",recvbuffer[i]);
printf("\n");
</pre>
</div>
</div>
giving an output of:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
Receive 6 elements: 0 2 4 5 7 9
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Next, we resize the type to ad the gap at the end.
This is illustrated in figure&nbsp;
6.9
.
</p>

<p name="switchToTextMode">
Resizing the type looks like:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#twovectorpad" aria-expanded="false" aria-controls="twovectorpad">
        C Code: twovectorpad
      </button>
    </h5>
  </div>
  <div id="twovectorpad" class="collapse">
  <pre>
MPI_Type_get_extent(stridetype,&l,&e);
printf("Stride type l=%ld e=%ld\n",l,e);
e += ( stride-blocklength) * sizeof(int);
MPI_Type_create_resized(stridetype,l,e,&paddedtype);
MPI_Type_get_extent(paddedtype,&l,&e);
printf("Padded type l=%ld e=%ld\n",l,e);
MPI_Type_commit(&paddedtype);
MPI_Send( sendbuffer,ntypes,paddedtype, receiver,0, comm );
</pre>
</div>
</div>
and the corresponding output,
including querying the extents,
is:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
Strided type l=0 e=20
Padded  type l=0 e=24
Receive 6 elements: 0 2 4 6 8 10
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Example2">6.6.2.2</a> Example 2</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentresizing">Extent resizing</a> > <a href="mpi-data.html#Example2">Example 2</a>
</p>
</p>

<p name="switchToTextMode">
For another example, let's revisit exercise&nbsp;
6.5
(and  figure&nbsp;
6.5
)
where each process makes a
buffer of integers that will be interleaved in a gather call:
Strided data was sent in individual transactions.
Would it be possible to address all these interleaved packets in one
gather or scatter call?
</p>

<!-- environment: lstlisting start embedded generator -->
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int *mydata = (int*) malloc( localsize*sizeof(int) );
for (int i=0; i&lt;localsize; i++)
  mydata[i] = i*nprocs+procno;
MPI_Gather( mydata,localsize,MPI_INT,
    /* rest to be determined */ );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

An ordinary gather call will of course not interleave, but
put the data end-to-end:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Gather( mydata,localsize,MPI_INT,
            gathered,localsize,MPI_INT, // abutting
            root,comm );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<!-- environment: verbatim start embedded generator -->
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
gather 4 elements from 3 procs:
 0 3 6 9 1 4 7 10 2 5 8 11
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Using a strided type still puts data end-to-end, but now there
are unwritten gaps in the gather buffer:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
MPI_Gather( mydata,localsize,MPI_INT,
            gathered,1,stridetype, // abut with gaps
            root,comm );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<!-- environment: verbatim start embedded generator -->
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
 0 1879048192 1100361260 3 3 0 6 0 0 9 1 198654
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/stride-extent.png" width=800></img>
<p name="caption">
FIGURE 6.10: Interleaved gather from data with resized extent
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

The trick is to use 
<tt>MPI_Type_create_resized</tt>
to make the extent of the type only one int long:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#interleavegather" aria-expanded="false" aria-controls="interleavegather">
        C Code: interleavegather
      </button>
    </h5>
  </div>
  <div id="interleavegather" class="collapse">
  <pre>
// interleavegather.c
MPI_Datatype interleavetype;
MPI_Type_create_resized(stridetype,0,sizeof(int),&interleavetype);
MPI_Type_commit(&interleavetype);
MPI_Gather( mydata,localsize,MPI_INT,
	      gathered,1,interleavetype, // shrunk extent
	      root,comm );
</pre>
</div>
</div>
Now data is written with the same stride, but
at starting points equal to the shrunk extent:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
 0 1 2 3 4 5 6 7 8 9 10 11
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

This is illustrated in figure&nbsp;
6.10
.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

  Rewrite exercise&nbsp;
6.5
 to use a gather,
  rather than individual messages.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">
[stridesend]
</p>

<!-- environment: mplnote start embedded generator -->
<!-- environment block purpose: [[ environment=mplnote ]] -->
<remark>
<b>MPL note</b>
<!-- TranslatingLineGenerator mplnote ['mplnote'] -->
<p name="switchToTextMode">
  Resizing a datatype does not give a new type, but
  does the resize `in place':
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
void layout::resize(ssize_t lb, ssize_t extent);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<i>End of MPL note</i>
</remark>
<!-- environment: mplnote end embedded generator -->
<p name="switchToTextMode">

<h4><a id="Example:dynamicvectors">6.6.2.3</a> Example: dynamic vectors</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentresizing">Extent resizing</a> > <a href="mpi-data.html#Example:dynamicvectors">Example: dynamic vectors</a>
</p>
</p>

<p name="switchToTextMode">
Does it bother you (a little) that in the vector type you
have to specify explicitly how many blocks there are?
It would be nice if you could create a `block with padding'
and then send however many of those.
</p>

<p name="switchToTextMode">
Well, you can introduce that padding by resizing a type,
making it a little larger.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#paddedblock1" aria-expanded="false" aria-controls="paddedblock1">
        C Code: paddedblock1
      </button>
    </h5>
  </div>
  <div id="paddedblock1" class="collapse">
  <pre>
// stridestretch.c
MPI_Datatype oneblock;
MPI_Type_vector(1,1,stride,MPI_DOUBLE,&oneblock);
MPI_Type_commit(&oneblock);
MPI_Aint block_lb,block_x;
MPI_Type_get_extent(oneblock,&block_lb,&block_x);
printf("One block has extent: %ld\n",block_x);

MPI_Datatype paddedblock;
MPI_Type_create_resized(oneblock,0,stride*sizeof(double),&paddedblock);
MPI_Type_commit(&paddedblock);
MPI_Type_get_extent(paddedblock,&block_lb,&block_x);
printf("Padded block has extent: %ld\n",block_x);

// now send a bunch of these padded blocks
MPI_Send(source,count,paddedblock,the_other,0,comm);
</pre>
</div>
</div>
<p name="switchToTextMode">

There is a second solution to this problem, using a structure type.
This does not use resizing, but rather indicates a displacement
that reaches to the end of the structure. We do this
by putting a type 
<tt>MPI_UB</tt>
 at this displacement:
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#paddedblock2" aria-expanded="false" aria-controls="paddedblock2">
        C Code: paddedblock2
      </button>
    </h5>
  </div>
  <div id="paddedblock2" class="collapse">
  <pre>
int blens[2]; MPI_Aint displs[2];
MPI_Datatype types[2], paddedblock;
blens[0] = 1; blens[1] = 1;
displs[0] = 0; displs[1] = 2 * sizeof(double);
types[0] = MPI_DOUBLE; types[1] = MPI_UB;
MPI_Type_struct(2, blens, displs, types, &paddedblock);
MPI_Type_commit(&paddedblock);
MPI_Status recv_status;
MPI_Recv(target,count,paddedblock,the_other,0,comm,&recv_status);
</pre>
</div>
</div>
<p name="switchToTextMode">

<h4><a id="Example:transpose">6.6.2.4</a> Example: transpose</h4>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Typeextent">Type extent</a> > <a href="mpi-data.html#Extentresizing">Extent resizing</a> > <a href="mpi-data.html#Example:transpose">Example: transpose</a>
</p>
<!-- index -->
</p>

<!-- environment: figure start embedded generator -->
<!-- environment block purpose: [[ environment=figure ]] -->
<figure>
<float mode=figure>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/transposetype.png" width=800></img>
<p name="caption">
FIGURE 6.11: Transposing a 1D partitioned array
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
Transposing data is an important part of such operations as the 
<span title="acronym" ><i>FFT</i></span>
.
We develop this in steps. Refer to figure&nbsp;
6.11
.
</p>

<p name="switchToTextMode">
The source data can be described as a vector type defined as:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
there are $b$ blocks,
<li>
of blocksize $b$,
<li>
spaced apart by the global $i$-size of the array.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#transposesrctype" aria-expanded="false" aria-controls="transposesrctype">
        C Code: transposesrctype
      </button>
    </h5>
  </div>
  <div id="transposesrctype" class="collapse">
  <pre>
// transposeblock.cxx
MPI_Datatype sourceblock;
MPI_Type_vector( blocksize_j,blocksize_i,isize,MPI_INT,&sourceblock);
MPI_Type_commit( &sourceblock);
</pre>
</div>
</div>
<p name="switchToTextMode">

The target type is harder to describe.
First we note that each contiguous block from the source type
can be described as a vector type with:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
$b$ blocks,
<li>
of size&nbsp;1 each,
<li>
stided by the global $j$-size of the matrix.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#transposetarlinetype" aria-expanded="false" aria-controls="transposetarlinetype">
        C Code: transposetarlinetype
      </button>
    </h5>
  </div>
  <div id="transposetarlinetype" class="collapse">
  <pre>
MPI_Datatype targetcolumn;
MPI_Type_vector( blocksize_i,1,jsize, MPI_INT,&targetcolumn);
MPI_Type_commit( &targetcolumn );
</pre>
</div>
</div>
<p name="switchToTextMode">

For the full type at the receiving process we now need to pack
$b$ of these lines together.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Finish the code.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
    What is the extent of the 
<tt>targetcolumn</tt>
 type?
<li>
What is the spacing of the first elements of the blocks? How
    do you therefore resize the 
<tt>targetcolumn</tt>
 type?
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
</p>

<h2><a id="Reconstructingtypes">6.7</a> Reconstructing types</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Reconstructingtypes">Reconstructing types</a>
</p>
<p name="switchToTextMode">

It is possible to find from a datatype how it was constructed.
This uses the routines
<tt>MPI_Type_get_envelope</tt>
 and
<tt>MPI_Type_get_contents</tt>
.
The first routine returns the 
<i>combiner</i>
(with values such as 
<tt>MPI_COMBINER_VECTOR</tt>
)
and the number of parameters;
the second routine is then used to retrieve the actual parameters.
</p>

<!-- environment: comment start embedded generator -->
<!-- environment block purpose: [[ environment=comment ]] -->
<comment>


</comment>
<!-- environment: comment end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Packing">6.8</a> Packing</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Packing">Packing</a>
</p>

</p>

<p name="switchToTextMode">
One of the reasons for derived datatypes is dealing with noncontiguous data.
In older communication libraries this could only be done by 
<i>packing</i>
 data
from its original containers into a buffer, and likewise unpacking it at the
receiver into its destination data structures.
</p>

<p name="switchToTextMode">
MPI offers this packing facility, partly for compatibility with such libraries,
but also for reasons of flexibility. Unlike with derived datatypes,
which transfers data atomically, packing routines add data sequentially
to the buffer and unpacking takes them sequentially.
</p>

<p name="switchToTextMode">
This means that
one could pack an integer describing how many floating point numbers
are in the rest of the packed message.
Correspondingly, the unpack routine could then investigate the first integer
and based on it unpack the right number of floating point numbers.
</p>

<p name="switchToTextMode">
MPI offers the following:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The 
<tt>MPI_Pack</tt>
 command adds data to a send buffer;
<li>
the 
<tt>MPI_Unpack</tt>
 command retrieves data from a receive buffer;
<li>
the buffer is sent with a datatype of 
<tt>MPI_PACKED</tt>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

With 
<tt>MPI_Pack</tt>
 data elements can be added
to a buffer one at a time. The 
<tt>position</tt>
 parameter is updated
each time by the packing routine.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int MPI_Pack(
  void *inbuf, int incount, MPI_Datatype datatype,
  void *outbuf, int outcount, int *position,
  MPI_Comm comm);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Conversely, 
<tt>MPI_Unpack</tt>
 retrieves one element
from the buffer at a time. You need to specify the MPI datatype.
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
int MPI_Unpack(
  void *inbuf, int insize, int *position,
  void *outbuf, int outcount, MPI_Datatype datatype,
  MPI_Comm comm);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

A packed buffer is sent or received with a datatype of
<tt>MPI_PACKED</tt>
. The sending routine uses the 
<tt>position</tt>

parameter to specify how much data is sent, but the receiving routine
does not know this value a&nbsp;priori, so has to specify an upper bound.
</p>

<p name="switchToTextMode">
\csnippetwithoutput{packunpack}{examples/mpi/pack}{pack}
</p>

<p name="switchToTextMode">
You can precompute the size of the required buffer with
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#MPI_Pack_size" aria-expanded="false" aria-controls="MPI_Pack_size">
        Routine reference: MPI_Pack_size
      </button>
    </h5>
  </div>
  <div id="MPI_Pack_size" class="collapse">
  <pre>
C:
int MPI_Pack_size
   (int incount, MPI_Datatype datatype, MPI_Comm comm, int *size)

Input parameters:
incount : Count argument to packing call (integer).
datatype : Datatype argument to packing call (handle).
comm : Communicator argument to packing call (handle).

Output parameters:
size : Upper bound on size of packed message, in bytes (integer).

Fortran:
MPI_PACK_SIZE(INCOUNT, DATATYPE, COMM, SIZE, IERROR)
input parameters:
INTEGER :: INCOUNT, DATATYPE, COMM
INTEGER :: SIZE, IERROR
</pre>
</div>
</div>
<i>MPI_Pack_size</i>
Add one time 
<tt>MPI_BSEND_OVERHEAD</tt>
.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->

  Suppose you have a `structure of arrays'
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
struct aos {
  int length;
  double *reals;
  double *imags;
};
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
  with dynamically created arrays. Write code to send and receive this
  structure.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
</p>

<p name="switchToTextMode">
\newpage
<h2><a id="Reviewquestions">6.9</a> Review questions</h2>
<p name=crumbs>
crumb trail:  > <a href="mpi-data.html">mpi-data</a> > <a href="mpi-data.html#Reviewquestions">Review questions</a>
</p>
</p>

<p name="switchToTextMode">
For all true/false questions, if you answer that a statement is false,
give a one-line explanation.
</p>

<!-- environment: enumerate start embedded generator -->
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
Give two examples of MPI derived datatypes. What parameters are used
to describe them?
<!-- environment: answer start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=answer ]] -->
<answer>


</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

<li>
Give a practical example where the sender uses a different type to send
  than the receiver uses in the corresponding receive call. Name the types involved.
<!-- environment: answer start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=answer ]] -->
<answer>


</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

<li>
Fortran only. True or false?
<!-- environment: enumerate start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=enumerate ]] -->
<enumerate>
<ol>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
Array indices can be different between the send and receive buffer arrays.
<li>
It is allowed to send an array section.
<li>
You need to 
<tt>Reshape</tt>
 a multi-dimensional array
    to linear shape before you can send it.
<li>
An allocatable array, when dimensioned and allocated, is
    treated by MPI as if it were a normal static array, when used as
    send buffer.
<li>
An allocatable array is allocated if you use it as the receive
    buffer: it is filled with the incoming data.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<li>
Fortran only: how do you handle the case where you want to use
  an allocatable array as receive buffer, but it has not been
  allocated yet, and you do not know the size of the incoming data?
</p>

</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

</div>
<a href="index.html">Back to Table of Contents</a>
