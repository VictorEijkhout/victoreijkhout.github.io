<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Scientific Data Storage</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


27.1 : <a href="hdf5.html#IntroductiontoHDF5">Introduction to HDF5</a><br>
27.2 : <a href="hdf5.html#Creatingafile">Creating a file</a><br>
27.3 : <a href="hdf5.html#Datasets">Datasets</a><br>
27.4 : <a href="hdf5.html#Writingthedata">Writing the data</a><br>
27.5 : <a href="hdf5.html#Reading">Reading</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>27 Scientific Data Storage</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

There are many ways of storing data, in particular data that comes in
arrays. A~surprising number of people stores data in spreadsheets,
then exports them to ascii files with comma or tab delimiters, and expects other
people (or other programs written by themselves) to read that in
again. Such a process is wasteful in several respects:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The ascii representation of a number takes up much more space
  than the internal binary representation. Ideally, you would want a
  file to be as compact as the representation in memory.
<li>
Conversion to and from ascii is slow; it may also lead to loss
  of precision.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
For such reasons, it is desirable to have a file format that is based
on binary storage. There are a few more requirements on a useful file
format:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Since binary storage can differ between platforms, a good file
  format is platform-independent. This will, for instance, prevent the
  confusion between 
<i>big-endian</i>
 and
<i>little-endian</i>
 storage, as well as conventions of 32
  versus 64 bit floating point numbers.
<li>
Application data can be heterogeneous, comprising integer,
  character, and floating point data. Ideally, all this data should be
  stored together.
<li>
Application data is also structured. This structure should be
  reflected in the stored form.
<li>
It is desirable for a file format to be
  
<i>self-documenting</i>
. If you store a matrix and a right-hand side
  vector in a file, wouldn't it be nice if the file itself told you
  which of the stored numbers are the matrix, which the vector, and
  what the sizes of the objects are?
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
This tutorial will introduce the HDF5 library, which fulfills these
requirements. HDF5 is a large and complicated library, so this
tutorial will only touch on the basics. For
further information, consult 
<a href=http://www.hdfgroup.org/HDF5/>http://www.hdfgroup.org/HDF5/</a>
.
While you do this tutorial, keep your browser open on

<a href=http://www.hdfgroup.org/HDF5/doc/>http://www.hdfgroup.org/HDF5/doc/</a>
 or

<a href=http://www.hdfgroup.org/HDF5/RM/RM_H5Front.html>http://www.hdfgroup.org/HDF5/RM/RM_H5Front.html</a>

for the exact
syntax of the routines.
</p>

<h2><a id="IntroductiontoHDF5">27.1</a> Introduction to HDF5</h2>
<p name=crumbs>
crumb trail:  > <a href="hdf5.html">hdf5</a> > <a href="hdf5.html#IntroductiontoHDF5">Introduction to HDF5</a>
</p>
<p name="switchToTextMode">

As described above, HDF5 is a file format that is machine-independent
and self-documenting. Each HDF5 file is set up like a directory tree,
with subdirectories, and leaf nodes which contain the actual
data. This means that data can be found in a file by referring to its
name, rather than its location in the file. In this section you will
learn to write programs that write to and read from HDF5 files. In
order to check that the files are as you intend, you can use the

<tt>h5dump</tt>
 utility on the command line.\footnote{In order to do the
  examples, the 
<tt>h5dump</tt>
 utility needs to be in your path, and you
  need to know the location of the 
<tt>hdf5.h</tt>
 and 
<tt>libhdf5.a</tt>
 and
  related library files.}
</p>

<p name="switchToTextMode">
Just a word about compatibility. The HDF5 format is not compatible
with the older version HDF4, which is no longer under development. You
can still come across people using hdf4 for historic reasons. This
tutorial is based on HDF5 version~1.6. Some interfaces changed in the
current version~1.8; in order to use 1.6 APIs with 1.8 software, add a
flag 
<tt>-DH5_USE_16_API</tt>
 to your compile line.
</p>

<p name="switchToTextMode">
Many HDF5 routines are about creating objects: file handles, members
in a dataset, et cetera. The general syntax for that is
<!-- environment: verbatim start embedded generator -->
</p>
hid_t h_id;
h_id = H5Xsomething(...);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Failure to create the object is indicated by a negative return
parameter, so it would be a good idea to create a file

<tt>myh5defs.h</tt>
  containing:
<!-- environment: verbatim start embedded generator -->
</p>
#include "hdf5.h"
#define H5REPORT(e) \
  {if (e&lt;0) {printf("\nHDF5 error on line %d\n\n",__LINE__); \
   return e;}}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
and use this as:
<!-- environment: verbatim start embedded generator -->
</p>
#include "myh5defs.h"


hid_t h_id;
h_id = H5Xsomething(...); H5REPORT(h_id);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Creatingafile">27.2</a> Creating a file</h2>
<p name=crumbs>
crumb trail:  > <a href="hdf5.html">hdf5</a> > <a href="hdf5.html#Creatingafile">Creating a file</a>
</p>
</p>

<p name="switchToTextMode">
First of all, we need to create an HDF5 file.
<!-- environment: verbatim start embedded generator -->
</p>
hid_t file_id;
herr_t status;


file_id = H5Fcreate( filename, ... );
    ...
status = H5Fclose(file_id);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
This file will be the container for a number of data items, organized
like a directory tree.
</p>

<p name="switchToTextMode">
\practical{Create an HDF5 file by compiling and running the 
<tt>create.c</tt>

  example below.}{A file 
<tt>file.h5</tt>
 should be created.}{Be sure to add HDF5
  include and library directories:\\ \n{cc -c create.c
    -I. -I/opt/local/include}\\ and\\ \n{cc -o create create.o
    -L/opt/local/lib -lhdf5}. The include and lib directories will be
  system dependent.}
\begin{istc}
  On the TACC clusters, do 
<tt>module load hdf5</tt>
, which will give you
  environment variables 
<tt>TACC_HDF5_INC</tt>
 and 
<tt>TACC_HDF5_LIB</tt>
 for
  the include and library directories, respectively.
\end{istc}
</p>

<p name="switchToTextMode">
{\small \verbatiminput{tutorials/hdf5/create.c} }
</p>

<p name="switchToTextMode">
You can display the created file on the commandline:
<!-- environment: verbatim start embedded generator -->
</p>
%% h5dump file.h5
HDF5 "file.h5" {
GROUP "/" {
}
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Note that an empty file corresponds to just the root of the directory
tree that will hold the data.
</p>

<h2><a id="Datasets">27.3</a> Datasets</h2>
<p name=crumbs>
crumb trail:  > <a href="hdf5.html">hdf5</a> > <a href="hdf5.html#Datasets">Datasets</a>
</p>
<p name="switchToTextMode">

Next we create a dataset, in this example a 2D grid. To describe this,
we first need to construct a dataspace:
<!-- environment: verbatim start embedded generator -->
</p>
   dims[0] = 4; dims[1] = 6;
   dataspace_id = H5Screate_simple(2, dims, NULL);
   dataset_id = H5Dcreate(file_id, "/dset", dataspace_id, .... );
   ....
   status = H5Dclose(dataset_id);
   status = H5Sclose(dataspace_id);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Note that datasets and dataspaces need to be closed, just like files.
</p>

<p name="switchToTextMode">
\practical{Create a dataset by compiling and running the 
<tt>dataset.c</tt>

  code below}{This creates a file 
<tt>dset.h</tt>
 that can be displayed
  with 
<tt>h5dump</tt>
.}{}
</p>

<p name="switchToTextMode">
{\small \verbatiminput{tutorials/hdf5/dataset.c} }
</p>

<p name="switchToTextMode">
We again view the created file online:
<!-- environment: verbatim start embedded generator -->
</p>
%% h5dump dset.h5
HDF5 "dset.h5" {
GROUP "/" {
   DATASET "dset" {
      DATATYPE  H5T_STD_I32BE
      DATASPACE  SIMPLE { ( 4, 6 ) / ( 4, 6 ) }
      DATA {
      (0,0): 0, 0, 0, 0, 0, 0,
      (1,0): 0, 0, 0, 0, 0, 0,
      (2,0): 0, 0, 0, 0, 0, 0,
      (3,0): 0, 0, 0, 0, 0, 0
      }
   }
}
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

The datafile contains such information as the size of the arrays you
store. Still, you may want to add related scalar information. For
instance, if the array is output of a program, you could record
with what input
parameter was it generated.
</p>

<!-- environment: verbatim start embedded generator -->
   parmspace = H5Screate(H5S_SCALAR);
   parm_id = H5Dcreate
     (file_id,"/parm",H5T_NATIVE_INT,parmspace,H5P_DEFAULT);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

\practical{Add a scalar dataspace to the HDF5 file, by compiling and
  running the 
<tt>parmwrite.c</tt>
 code below.}{A new file 
<tt>wdset.h5</tt>

  is created.}{}
</p>

<p name="switchToTextMode">
{\small \verbatiminput{tutorials/hdf5/parmdataset.c} }
</p>

<!-- environment: verbatim start embedded generator -->
%% h5dump wdset.h5
HDF5 "wdset.h5" {
GROUP "/" {
   DATASET "dset" {
      DATATYPE  H5T_IEEE_F64LE
      DATASPACE  SIMPLE { ( 4, 6 ) / ( 4, 6 ) }
      DATA {
      (0,0): 0.5, 1.5, 2.5, 3.5, 4.5, 5.5,
      (1,0): 6.5, 7.5, 8.5, 9.5, 10.5, 11.5,
      (2,0): 12.5, 13.5, 14.5, 15.5, 16.5, 17.5,
      (3,0): 18.5, 19.5, 20.5, 21.5, 22.5, 23.5
      }
   }
   DATASET "parm" {
      DATATYPE  H5T_STD_I32LE
      DATASPACE  SCALAR
      DATA {
      (0): 37
      }
   }
}
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Writingthedata">27.4</a> Writing the data</h2>
<p name=crumbs>
crumb trail:  > <a href="hdf5.html">hdf5</a> > <a href="hdf5.html#Writingthedata">Writing the data</a>
</p>
</p>

<p name="switchToTextMode">
The datasets you created allocate the space in the hdf5 file. Now you
need to put actual data in it. This is done with the 
<tt>H5Dwrite</tt>
 call.
</p>

<p name="switchToTextMode">
{\small
<!-- environment: verbatim start embedded generator -->
</p>
/* Write floating point data */
for (i=0; i&lt;24; i++) data[i] = i+.5;
status = H5Dwrite
  (dataset,H5T_NATIVE_DOUBLE,H5S_ALL,H5S_ALL,H5P_DEFAULT,
   data);
/* write parameter value */
parm = 37;
status = H5Dwrite
  (parmset,H5T_NATIVE_INT,H5S_ALL,H5S_ALL,H5P_DEFAULT,
   &parm);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#tutorials/hdf5/parmwrite.c" aria-expanded="false" aria-controls="tutorials/hdf5/parmwrite.c">
        Text: tutorials/hdf5/parmwrite.c
      </button>
    </h5>
  </div>
  <div id="tutorials/hdf5/parmwrite.c" class="collapse">
  <pre>
/*
 * File: parmwrite.c
 * Author: Victor Eijkhout
 */
#include "myh5defs.h"
#define FILE "wdset.h5"

main() {

   hid_t       file_id, dataset, dataspace;  /* identifiers */
   hid_t       parmset,parmspace;
   hsize_t     dims[2];
   herr_t      status;
   double data[24]; int i,parm;

   /* Create a new file using default properties. */
   file_id = H5Fcreate(FILE, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);

   /* Create the dataset. */
   dims[0] = 4; dims[1] = 6;
   dataspace = H5Screate_simple(2, dims, NULL);
   dataset = H5Dcreate
     (file_id, "/dset", H5T_NATIVE_DOUBLE, dataspace, H5P_DEFAULT);

   /* Add a descriptive parameter */
   parmspace = H5Screate(H5S_SCALAR);
   parmset = H5Dcreate
     (file_id,"/parm",H5T_NATIVE_INT,parmspace,H5P_DEFAULT);

   /* Write data to file */
   for (i=0; i&lt;24; i++) data[i] = i+.5;
   status = H5Dwrite
     (dataset,H5T_NATIVE_DOUBLE,H5S_ALL,H5S_ALL,H5P_DEFAULT,
      data); H5REPORT(status);

   /* write parameter value */
   parm = 37;
   status = H5Dwrite
     (parmset,H5T_NATIVE_INT,H5S_ALL,H5S_ALL,H5P_DEFAULT,
      &parm); H5REPORT(status);

   /* End access to the dataset and release resources used by it. */
   status = H5Dclose(dataset);
   status = H5Dclose(parmset);

   /* Terminate access to the data space. */
   status = H5Sclose(dataspace);
   status = H5Sclose(parmspace);

   /* Close the file. */
   status = H5Fclose(file_id);
}

</pre>
</div>
</div>
</p>

<!-- environment: verbatim start embedded generator -->
%% h5dump wdset.h5
HDF5 "wdset.h5" {
GROUP "/" {
   DATASET "dset" {
      DATATYPE  H5T_IEEE_F64LE
      DATASPACE  SIMPLE { ( 4, 6 ) / ( 4, 6 ) }
      DATA {
      (0,0): 0.5, 1.5, 2.5, 3.5, 4.5, 5.5,
      (1,0): 6.5, 7.5, 8.5, 9.5, 10.5, 11.5,
      (2,0): 12.5, 13.5, 14.5, 15.5, 16.5, 17.5,
      (3,0): 18.5, 19.5, 20.5, 21.5, 22.5, 23.5
      }
   }
   DATASET "parm" {
      DATATYPE  H5T_STD_I32LE
      DATASPACE  SCALAR
      DATA {
      (0): 37
      }
   }
}
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
</p>

<p name="switchToTextMode">
If you look closely at the source and the dump, you see that the data
types are declared as `native', but rendered as 
<tt>LE</tt>
.  The `native'
declaration makes the datatypes behave like the built-in C or Fortran
data types. Alternatively, you can explicitly indicate whether data is
<i>little-endian</i>
 or 
<i>big-endian</i>
. These terms
describe how the bytes of a data item are ordered in memory. Most
architectures use little endian, as you can see in the dump output,
but, notably, IBM
<!-- index -->
 uses big endian.
</p>

<h2><a id="Reading">27.5</a> Reading</h2>
<p name=crumbs>
crumb trail:  > <a href="hdf5.html">hdf5</a> > <a href="hdf5.html#Reading">Reading</a>
</p>
<p name="switchToTextMode">

Now that we have a file with some data, we can do the mirror part of
the story: reading from that file. The essential commands are
<!-- environment: verbatim start embedded generator -->
</p>
  h5file = H5Fopen( .... )
  ....
  H5Dread( dataset, .... data .... )
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
where the 
<tt>H5Dread</tt>
 command has the same arguments as the
corresponding 
<tt>H5Dwrite</tt>
.
</p>

<p name="switchToTextMode">
\practical{Read data from the 
<tt>wdset.h5</tt>
 file that you create in the
  previous exercise, by compiling and running the 
<tt>allread.c</tt>

  example below.}{Running the 
<tt>allread</tt>
 executable will print the
  value&nbsp;
<tt>37</tt>
 of the parameter, and the value&nbsp;
<tt>8.5</tt>
 of the
  
<tt>(1,2)</tt>
 data point of the array.}{Make sure that you run
  
<tt>parmwrite</tt>
 to create the input file.}
</p>

<p name="switchToTextMode">
{\small \verbatiminput{tutorials/hdf5/allread.c} }
</p>

<!-- environment: verbatim start embedded generator -->
 %% ./allread
parameter value: 37
arbitrary data point [1,2]: 8.500000e+00
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

</div>
<a href="index.html">Back to Table of Contents</a>
