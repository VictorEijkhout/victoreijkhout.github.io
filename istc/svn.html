<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Source code control</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


26.1 : <a href="svn.html#Workflowinsourcecodecontrolsystems">Workflow in source code control systems</a><br>
26.2 : <a href="svn.html#Mercurial(hg)andGit">Mercurial (hg) and Git</a><br>
26.3 : <a href="svn.html#Createandpopulatearepository">Create and populate a repository</a><br>
26.4 : <a href="svn.html#Newfiles">New files</a><br>
26.5 : <a href="svn.html#Editingfiles">Editing files</a><br>
26.6 : <a href="svn.html#Oops!Undo!">Oops! Undo!</a><br>
26.7 : <a href="svn.html#Conflicts">Conflicts</a><br>
26.8 : <a href="svn.html#Inspectingthehistory">Inspecting the history</a><br>
26.9 : <a href="svn.html#Branching">Branching</a><br>
26.10 : <a href="svn.html#Pullrequestsandforks">Pull requests and forks</a><br>
26.11 : <a href="svn.html#Otherissues">Other issues</a><br>
26.11.1 : <a href="svn.html#Transport">Transport</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>26 Source code control</h1>
<!-- TranslatingLineGenerator file ['file'] -->
</p>

<i>Source code control</i>
<!-- index -->
<p name="switchToTextMode">
 systems, also
called 
<i>revision control</i>

  systems|see{source code control}}  or
<i>version control</i>
<!-- index -->
systems, are
a way of storing software, where not only the current version is
stored, but also all previous versions.
This is done by maintaining a 
<i>repository</i>
 for all versions,
while one or more users work on a `checked out' copy of the latest
version. Those of the users that are developers can then commit their
changes to the repository. Other users then update their local copy.
The repository typically resides on a remote machine that is reliably
backup up.
</p>

<p name="switchToTextMode">
There are various reasons for keeping your source in a repository.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
If you work in a team, it is the best way to synchronize your
  work with your colleagues. It is also a way to document what changes
  were made, by whom, and why.
<li>
It will allow you to roll back a defective code to a version
  that worked.
<li>
It allows you to have branches, for instance for customizations
  that need to be kept out of the main development line. If you are
  working in a team, a branch is a way to develop a major feature, stay up
  to date with changes your colleagues make, and only add your feature
  to the main development when it is sufficiently tested.
<li>
If you work alone, it is a way to synchronize between more than
  one machine. (You could even imagine traveling without all your
  files, and installing them from the repository onto a borrowed
  machine as the need arises.)
<li>
Having a source code repository is one way to backup your work.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

There are various source code control systems; in this tutorial you
can learn the basics of 
<i>Subversion</i>
 (also called
<i>svn</i>
source code control systems, and Mercurial (or~
<tt>hg</tt>
), which is an
example of the new generation of 
code control} systems.
</p>

<h2><a id="Workflowinsourcecodecontrolsystems">26.1</a> Workflow in source code control systems</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Workflowinsourcecodecontrolsystems">Workflow in source code control systems</a>
</p>
<p name="switchToTextMode">

Source code control systems are built around the notion
of 
<i>repository</i>
: a central store of the files of a project,
together with their whole history. Thus, a repository allows you to
share files with multiple people, but also to roll back changes, apply
patches to old version, et cetera.
</p>

<p name="switchToTextMode">
The basic actions on a repository are:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Creating the repository; this requires you to have space and
  write permissions on some server. Maybe your sysadmin has to do it
  for you.
<li>
Checking out the repository, that is, making a local copy of its
  contents in your own space.
<li>

 Adding your changes to the repository, and
<li>
Updating your local copy with someone else's changes.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Adding your own changes is not always possible: there are many projects
where the developer allows you to check out the repository, but not to
incorporate changes. Such a repository is said to be read-only.
</p>

<p name="switchToTextMode">
Figure~
26.1
 illustrates these actions for the Subversion system.
<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/repo-flow-svn.jpeg" width=800></img>
<p name="caption">
FIGURE 26.1: Workflow in traditional source code control systems such as Subversion
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
Users who have checked out the repository can edit files, and check in
the new versions with the 
<tt>commit</tt>
 command; to get the changes
committed by other users you use 
<tt>update</tt>
.
</p>

<p name="switchToTextMode">
One of the uses of committing is that you can roll your code back to
an earlier version if you realize you made a mistake or introduced a
bug.
It also allows you to see the difference between different
code version. However, committing many small changes may be confusing
to other developers, for instance if they come to rely on something
you introduce which you later remove again. For this reason,
<i>distributed source code control</i>
 systems use two levels
of repositories.
</p>

<p name="switchToTextMode">
There is still a top level that is authoritative, but
now there is a lower level, typically of local copies, where you can
commit your changes and accumulate them until you finally add them to
the central repository.
<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/repo-flow-hg.jpeg" width=800></img>
<p name="caption">
FIGURE 26.2: Workflow in distributed source code control systems such as Mercurial
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
This also makes it easier to contribute to a read-only repository:
you make your local changes, and when you are finished you tell the
developer to inspect your changes and pull them into the top level
repository. This structure is illustrated in figure~
26.2
.
</p>

<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Mercurial(hg)andGit">26.2</a> Mercurial (hg) and Git</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Mercurial(hg)andGit">Mercurial (hg) and Git</a>
</p>
<!-- index -->
<!-- index -->
<!-- index -->
</p>

<i>Mercurial</i>
<p name="switchToTextMode">
of 
<i>distributed source code control</i>
 systems. Many
commands are the same as for subversion, but there are some new
ones, corresponding to the new level of sophistication.
Mercurial and git share some commands, but there are also differences.
Git is ultimately more powerful, but mercurial is easier to use at first.
</p>

<p name="switchToTextMode">
Here is a translation between the two systems:

<a href=https://github.com/sympy/sympy/wiki/Git-hg-rosetta-stone>https://github.com/sympy/sympy/wiki/Git-hg-rosetta-stone</a>
.
</p>

<p name="switchToTextMode">
Minimal introduction to git: 
<a href=http://rogerdudler.github.io/git-guide/>http://rogerdudler.github.io/git-guide/</a>

</p>

<p name="switchToTextMode">
This lab should be done two people, to simulate a group
of programmers working on a joint project. You can also do this on
your own by using two clones of the repository,
preferably opening two windows on your computer.
</p>

<p name="switchToTextMode">
Best practices for distributed version control:

<a href=https://homes.cs.washington.edu/~mernst/advice/version-control.html>https://homes.cs.washington.edu/~mernst/advice/version-control.html</a>

</p>

<h2><a id="Createandpopulatearepository">26.3</a> Create and populate a repository</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Createandpopulatearepository">Create and populate a repository</a>
</p>
<p name="switchToTextMode">

<!-- environment: purpose start embedded generator -->
</p>
<!-- TranslatingLineGenerator purpose ['purpose'] -->
  In this section you will create a repository and make a local copy
  to work on.
</p name="purpose">
</purpose>
<!-- environment: purpose end embedded generator -->
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  Clone an existing repository</td></tr>
<tr><td>
  mercurial</td><td>git</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>hg clone <url> [ localdir ]</tt>
</td><td>
  
<tt>git clone <url> [ localdir ]</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  Create a completely new repository</td></tr>
<tr><td>
  </td><td>git init \# current directory or add explicit </td></tr>
<tr><td>
  </td><td>git remote add origin git@github.com:Name/Repo.git \# or other URL</td></tr>
<tr><td>
  </td><td>git push --set-upstream origin master \# when you first push</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

First we need to have a repository. In practice, you will often use
one that has been previously set up, but there are several ways to
set up a repository yourself.
There are commercial and free hosting services such as
  
<a href=http://bitbucket.org>http://bitbucket.org</a>
. (Academic users can have more private
  repositories.)
</p>

<p name="switchToTextMode">
Let's assume that one student has created a repository 
<tt>your-project</tt>

on Bitbucket. Both students can then clone it:
<!-- environment: verbatim start embedded generator -->
</p>
%% hg clone https://YourName@bitbucket.org/YourName/your-project
updating to branch default
0 files updated, 0 files merged, 0 files removed,
    0 files unresolved
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
or
<!-- environment: verbatim start embedded generator -->
</p>
%% git clone git@bitbucket.org:YourName/yourproject.git
Cloning into 'yourproject'...
warning: You appear to have cloned an empty repository.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
You now have an empty directory 
<tt>your-project</tt>
.
</p>

<p name="switchToTextMode">
\practical{Go into the project directory and see if it is really
  empty.}{There is a hidden directory 
<tt>.hg</tt>
 or 
<tt>.git</tt>
}{}
</p>

<h2><a id="Newfiles">26.4</a> New files</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Newfiles">New files</a>
</p>

<p name="switchToTextMode">


<b>Creating an untracked file</b><br>

</p>

<!-- environment: purpose start embedded generator -->
<!-- TranslatingLineGenerator purpose ['purpose'] -->
  In this section you will make some simple changes:
  creating a new file
  and
  editing an existing file
</p name="purpose">
</purpose>
<!-- environment: purpose end embedded generator -->
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  mercurial</td><td>git</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>hg status [ path] </tt>
</td><td>
  
<tt>git status [ path ]</tt>
</td></tr>
<tr><td>
  
<tt>hg add [ files ] </tt>
</td><td>
  
<tt>git add [ files ]</tt>
</td></tr>
<tr><td>
  once for each file</td><td>every time the file is changed</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

One student now makes a file to add to the repository:
<!-- environment: verbatim start embedded generator -->
</p>
%%  cat &gt; firstfile
a
b
c
d
e
f
^D
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
(where 
 <tt>^D</tt>  stands for control-D, which terminates the input.)
This file is unknown to 
<tt>hg</tt>
:
<!-- environment: verbatim start embedded generator -->
</p>
%% hg status
? firstfile
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Git is a little more verbose:
<!-- environment: verbatim start embedded generator -->
</p>
git status
On branch master


Initial commit


Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)


firstfile


nothing added to commit but untracked files present
  (use "git add" to track)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">


<b>Adding the file to the repository</b><br>

</p>

<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/git-push.png" width=800></img>
<p name="caption">
FIGURE 26.3: Add local changes to the remote repository
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

We need to declare the file as belonging to the repository; a
subsequent 
<tt>hg commit</tt>
 command then copies it into the repository.
<!-- environment: verbatim start embedded generator -->
</p>
%% hg add firstfile
%% hg status
A firstfile
%% hg commit -m "made a first file"
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
or
<!-- environment: verbatim start embedded generator -->
</p>
%% git add firstfile
%% git status
On branch master


Initial commit


Changes to be committed:
  (use "git rm --cached &lt;file&gt;..." to unstage)


        new file:   firstfile
%% git commit -a -m "adding a first file"
  [master (root-commit) f4b738c] adding a first file
  1 file changed, 5 insertions(+)
  create mode 100644 firstfile
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  mercurial</td><td>git</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>hg commit -m </td><td>lt;message</td><td>gt;</tt>
</td><td>
  
<tt>git commit -m </td><td>lt;message</td><td>gt;</tt>
</td></tr>
<tr><td>
  
<tt>hg push</tt>
</td><td>
  
<tt>git push origin master</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

Unlike with Subversion, the file has now only been copied into the
local repository, so that you can, for instance, roll back your
changes. If you want this file added to the main repository,
you need the 
<tt>hg push</tt>
 command:
<!-- environment: verbatim start embedded generator -->
</p>
%% hg push https://YourName@bitbucket.org/YourName/your-project
pushing to https://YourName@bitbucket.org/YourName/your-project
searching for changes
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 1 changes to 1 files
remote: bb/acl: YourName is allowed. accepted payload.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
In the 
<tt>push</tt>
 step you were probably asked for your password. You can
prevent that by having some lines in your 
 <tt>$HOME/.hgrc</tt>  file:
{\footnotesize
<!-- environment: verbatim start embedded generator -->
</p>
[paths]
projectrepo = https://YourName:yourpassword@bitbucket.org/YourName/my-project
[ui]
username=Your Name &lt;you@somewhere.youruniversity.edu&gt;
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
Now the command 
<tt>hg push projectrepo</tt>
 will push the local changes
to the global repository without asking for your password. Of course,
now you have a file with a cleartext password, so you should set the
permissions of this file correctly.
</p>

<p name="switchToTextMode">
With git you need to be more explicit, since the ties between your
local copy and the `upstream' repository can be more fluid.
<!-- environment: verbatim start embedded generator -->
</p>
git remote add origin git@bitbucket.org:YourName/yourrepo.git
git push origin master
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<iframe src="graphics/git-pull.pdf" width=800></iframe>
<p name="caption">
FIGURE 26.4: Get changes that were made to the remote repository
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

The second student now needs to update their repository. Just like the
upload took two commands, this pass also takes two. First you do \n{hg
  pull} to update your local repository. This does not update the
local files you have: for that you need to do 
<tt>hg update</tt>
.
</p>

<p name="switchToTextMode">
\practical{Do this and check that the contents of the file are
  correct.}{In order to do the update command, you have to be in a
  checked-out copy of the repository.}
</p>

<p name="switchToTextMode">
\practical{Let both students create a new directory with a few
  files. Declare the directory and commit it. Pull and update to
  obtain the changes the other mde.}{You can do 
<tt>hg add</tt>
 on the
  directory, this will also add the files contained in it.}{}
</p>

<p name="switchToTextMode">
Since you will mostly be doing an update immediately after a pull, you
can combine them:
<!-- environment: verbatim start embedded generator -->
</p>
hg pull -u
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Git will report what files are updated; for Hg you need to take the
changeset number and query:
<!-- environment: verbatim start embedded generator -->
</p>
hg status --change 82ffb99c79fd
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: remark start embedded generator -->
</p>
<!-- TranslatingLineGenerator remark ['remark'] -->
  In order for Mercurial to keep track of your files, you should never do
  the shell commands
  
<tt>cp</tt>
 or 
<tt>mv</tt>
 on files that are in the repository. Instead, do
  
<tt>hg cp</tt>
 or 
<tt>hg mv</tt>
. Likewise, there is a command 
<tt>hg rm</tt>
.
</p name="remark">
</remark>
<!-- environment: remark end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Editingfiles">26.5</a> Editing files</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Editingfiles">Editing files</a>
</p>
</p>

<p name="switchToTextMode">
Mercurial and Git differ in their behavior regarding edited files.
Both show them as modified, but
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Mercurial will automatically include them in a commit, and push them upstream.
<li>
Git needs an explicit 
<tt>git add</tt>
 each time the file is edited, otherwise it will not
  become part of a commit. Do not 
<tt>git add -A</tt>
 since this will probably add too much
  to your repo, such as auto-save and binary files.
  You can simplify your life by doing 
<tt>git add -u</tt>
 which adds all `updated' files to a commit.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Oops!Undo!">26.6</a> Oops! Undo!</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Oops!Undo!">Oops! Undo!</a>
</p>
</p>

<p name="switchToTextMode">
One of the reasons for having source code control is to be able to
revert changes. The easiest undo is to go back to the last stored
version in the repository.
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  mercurial</td><td>git</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>hg revert </td><td>lt;yourfile</td><td>gt;</tt>
</td><td>
  
<tt>git checkout -- </td><td>lt;yourfile</td><td>gt;</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Conflicts">26.7</a> Conflicts</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Conflicts">Conflicts</a>
</p>
</p>

<!-- environment: purpose start embedded generator -->
<!-- TranslatingLineGenerator purpose ['purpose'] -->
  In this section you will learn about how do deal with conflicting
  edits by two users of the same repository.
</p name="purpose">
</purpose>
<!-- environment: purpose end embedded generator -->
<p name="switchToTextMode">

Now let's see what happens when two people edit the same file.
Let both students make an edit to 
 <tt>firstfile</tt> , but one to the
top, the other to the bottom. After one student commits the edit, the
other can commit changes, after all, these only affect the local repository.
However, trying to push that change gives an error:
<!-- environment: verbatim start embedded generator -->
</p>
%% emacs firstfile # make some change
%% hg commit -m ``first again''
%% hg push test
abort: push creates new remote head b0d31ea209b3!
(you should pull and merge or use push -f to force)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
The solution is to get the other edit, and commit again. This takes a
couple of commands:
{\small
<!-- environment: verbatim start embedded generator -->
</p>
%% hg pull myproject
searching for changes
adding changesets
adding manifests
adding file changes
added 1 changesets with 1 changes to 1 files (+1 heads)
(run 'hg heads' to see heads, 'hg merge' to merge)


%% hg merge
merging firstfile
0 files updated, 1 files merged, 0 files removed, 0 files unresolved
(branch merge, don't forget to commit)


%% hg status
M firstfile
%% hg commit -m ``my edit again''
%% hg push test
pushing to https://VictorEijkhout:***@bitbucket.org/
                       VictorEijkhout/my-project
searching for changes
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 2 changesets with 2 changes to 1 files
remote: bb/acl: VictorEijkhout is allowed. accepted payload.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
</p>

<p name="switchToTextMode">
This may seem complicated, but you see that Mercurial prompts you
for what commands to execute, and the workflow is clear, if you refer
to figure&nbsp;
26.2
.
</p>

<p name="switchToTextMode">
\practical{Do a 
<tt>cat</tt>
 on the file that both of you have been editing.
You should find that both edits are incorporated. That is the `merge'
that Mercurial referred to.}{}{}
</p>

<p name="switchToTextMode">
If both students make edits on the same part of the file, version
control can no
longer resolve the conflicts. For instance, let one student insert a
line between the first and the second, and let the second student edit
the second line. Whoever tries to push second, will get messages
like this:
{\small
<!-- environment: verbatim start embedded generator -->
</p>
%% hg pull test
added 3 changesets with 3 changes to 1 files (+1 heads)
(run 'hg heads' to see heads, 'hg merge' to merge)
%% hg merge
merging firstfile
warning: conflicts during merge.
merging firstfile incomplete!
    (edit conflicts, then use 'hg resolve --mark')
0 files updated, 0 files merged, 0 files removed, 1 files unresolved
use 'hg resolve' to retry unresolved file merges
    or 'hg update -C .' to abandon
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
</p>

<p name="switchToTextMode">
For git:
<!-- environment: verbatim start embedded generator -->
</p>
CONFLICT (content): Merge conflict in &lt;name of some file&gt;
Automatic merge failed; fix conflicts and then commit the result.
[solutions-mpi-c:955] emacs &lt;name of some file&gt;
[solutions-mpi-c:956] git add !$ && git commit -m "fix conflict" && git pull && git push
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

There are now the following options:
<!-- environment: enumerate start embedded generator -->
</p>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
There is usually a way to indicate whether to use the local or
  the remote version.
<li>
There are graphical programs to resolve conflicts. They will
  typically show you 3 colums, for the two versions, and for your
  resolution. You can then indicate `take this from the local version,
  and this from the remote'.
<li>
You can also edit the file to resolve the conflicts yourself. We
  will discuss that shortly.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

Both  will give you several options. It is easiest to resolve the
conflict with a text editor. If you open the file that has the conflict
you'll see something like:
<!-- environment: verbatim start embedded generator -->
</p>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; local
aa
bbbb
=======
aaa
a2
b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; other
c
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
indicating the difference between the local version (`mine') and the
other, that is the version that you pulled and tried to merge.
You need to edit the file to resolve the conflict.
</p>

<p name="switchToTextMode">
After this, you tell hg that the conflict was resolved:
<!-- environment: verbatim start embedded generator -->
</p>
 hg resolve --mark
%% hg status
M firstfile
? firstfile.orig
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
or
<!-- environment: verbatim start embedded generator -->
</p>
git add &lt;name of that file&gt;
git commit -m "fixed conflict in &lt;name of that file&gt;"
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
After this you can commit and push again.
The other student then needs to do another update to get the
correction.
</p>

<p name="switchToTextMode">
For conflicts in binary files, git has a flag where you can indicate
which version to use:
<!-- environment: verbatim start embedded generator -->
</p>
git checkout --ours path/to/file
git checkout --theirs path/to/file
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Not all files can be merged: for binary files Mercurial will ask you:
<!-- environment: verbatim start embedded generator -->
</p>
%% hg merge
merging proposal.tex
merging summary.tex
merking references.tex
 no tool found to merge proposal.pdf
keep (l)ocal or take (o)ther? o
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
This means that the only choices are to keep your local version
(type&nbsp;
<tt>l</tt>
 and hit return) or take the other version (type&nbsp;
<tt>o</tt>
 and
hit return). In the case of a binary file that was obvious generated
automatically, some people argue that they should not be in the
repository to begin with.
</p>

<h2><a id="Inspectingthehistory">26.8</a> Inspecting the history</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Inspectingthehistory">Inspecting the history</a>
</p>
<p name="switchToTextMode">

<!-- environment: purpose start embedded generator -->
</p>
<!-- TranslatingLineGenerator purpose ['purpose'] -->
  In this section, you will learn how to view and compare files in the
  repository.
</p name="purpose">
</purpose>
<!-- environment: purpose end embedded generator -->
<p name="switchToTextMode">

If you want to know where you cloned a repository from, look in the
file 
<tt>.hg/hgrc</tt>
.
</p>

<p name="switchToTextMode">
The main sources of information about the repository are 
<tt>hg log</tt>

and 
<tt>hg id</tt>
. The latter gives you global information, depending
on what option you use. For instance, 
<tt>hg id -n</tt>
 gives the local revision
number.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
[
<tt>hg log</tt>
] gives you a list of all changesets so far,
  with the comments you entered.
<li>
[
<tt>hg log -v</tt>
] tells you what files were affected in each changeset.
<li>
[
<tt>hg log -r 5</tt>
] or 
<tt>hg log -r 6:8</tt>
 gives information on
  one or more changesets.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

To see differences in various revisions of individual files, use

<tt>hg diff</tt>
. First
make sure you are up to date. Now do 
<tt>hg diff firstfile</tt>
. No
output, right? Now make an edit in 
<tt>firstfile</tt>
 and do \n{hg diff
  firstfile} again. This gives you the difference between the last
commited version and the working copy.
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  </td></tr>
<tr><td>
  mercurial</td><td>git</td></tr>
<tr><td>
  </td></tr>
<tr><td>
  
<tt>hg diff </td><td>lt;file</td><td>gt;</tt>
</td><td>
  
<tt>git diff HEAD </td><td>lt;file</td><td>gt;</tt>
</td></tr>
<tr><td>
  
<tt>hg diff -r A -r B </td><td>lt;file</td><td>gt;</tt>
</td><td>
  
<tt>git diff A..B </td><td>lt;file</td><td>gt;</tt>
</td></tr>
<tr><td>
  </td></tr>
<tr><td>
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

For example:
<!-- environment: verbatim start embedded generator -->
</p>
[src:1151] git pull
[...]
From github.com:Username/Reponame
   c5aaa43..2f5ce0b  main       -&gt; origin/main
Updating c5aaa43..2f5ce0b
Fast-forward
 src/net.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
[src:1156] git diff c5aaa43..2f5ce0b net.cpp
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<!-- environment: itemize start embedded generator -->
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The 
<tt>pull</tt>
 command tells you what the previous and current
  commit identifiers are; and
<li>
With 
<tt>diff</tt>
, specifying these identifiers, you get the changes
  in 
<tt>diff</tt>
 format.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Check for yourself what happens when you do a commit but no push, and
you issue the above diff command.
</p>

<p name="switchToTextMode">
You can also ask for differences between committed versions with

<tt>hg diff -r 4:6 firstfile</tt>
.
</p>

<p name="switchToTextMode">
The output of this diff command is a bit cryptic, but you can
understand it without too much trouble. There are also fancy GUI
implementations of hg for every platform that show you differences in
a much nicer way.
</p>

<p name="switchToTextMode">
If you simply want to see what a file used to look like, do \n{hg
  cat -r 2 firstfile}. To get a copy of a certain revision of the
repository, do 
<tt>hg export -r 3 . ../rev3</tt>
, which exports the
repository at the current directory (`dot') to the directory 
<tt>../rev3</tt>
.
</p>

<p name="switchToTextMode">
If you save the output of 
<tt>hg diff</tt>
, it is possible to apply it
with the Unix 
<tt>patch</tt>
 command. This is a quick way to send patches
to someone without them needing to check out the repository.
</p>

<h2><a id="Branching">26.9</a> Branching</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Branching">Branching</a>
</p>
<p name="switchToTextMode">

Create branch:
</p>

<p name="switchToTextMode">

<tt>git checkout -b newbranch</tt>

</p>

<p name="switchToTextMode">
List available:
</p>

<p name="switchToTextMode">

<tt>git branch</tt>

</p>

<p name="switchToTextMode">
After that switch:
</p>

<p name="switchToTextMode">

<tt>git checkout branchname</tt>

</p>

<p name="switchToTextMode">

<tt>git push --set-upstream origin newbranch</tt>

</p>

<p name="switchToTextMode">

See what branches there are: 
<tt>hg brances</tt>

</p>

<p name="switchToTextMode">
See what branch you are working on: 
<tt>hg branch</tt>

</p>

<p name="switchToTextMode">
Switch to a branch (this undoes local changes): 
<tt>hg update -C branchname</tt>

</p>

<h2><a id="Pullrequestsandforks">26.10</a> Pull requests and forks</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Pullrequestsandforks">Pull requests and forks</a>
</p>
<p name="switchToTextMode">

Suppose you want to contribute changes to a repository,
but you don't have write permissions on a repository.
(Of course, you need to have read permissions to the repository
in order to make the changes.)
Lack of write permission means that you can not create a branch,
and push and merge it.
A 
<i>pull request</i>
 is then a way to communicate
your changes so that they can be pulled, rather
than you pushing them.
</p>

<!-- environment: enumerate start embedded generator -->
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
  In github, creating a fork is made with a press of the `Fork' button.
<li>
  Clone your fork.
<!-- environment: verbatim start embedded generator -->
</p>
git clone &lt;original-url&gt; repo-fork
cd repo-fork
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<li>
  Make your edits in the cloned fork.
<li>
You need to keep your fork up to date with the original repo.
  First you connect the original repo as `upstream' to your fork:
<!-- environment: verbatim start embedded generator -->
</p>
git remote add upstream &lt;original-url&gt;
git remote -v # check on the state of things
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
(the name `upstream' is the conventional name; it is not a keyword.)
<li>
  Optionally, check out a branch. If you 
<tt>git status</tt>
, you should see
<!-- environment: verbatim start embedded generator -->
</p>
On branch YourBranch
Your branch is up to date with 'origin/YourBranch.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<li>
Keep your fork updated:
<!-- environment: verbatim start embedded generator -->
</p>
git fetch upstream
git merge upstream/master master # or specific branch
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

To make pull request:
<!-- environment: enumerate start embedded generator -->
</p>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
Create a new branch
<!-- environment: verbatim start embedded generator -->
</p>
git checkout -b YourChangesBranch
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<li>
  Make your changes and commit them:
<!-- environment: verbatim start embedded generator -->
</p>
git add file1 file2
git commit -m "changes summary"
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<li>
Push your changes to the origin, that is,
  your repo on github:
<!-- environment: verbatim start embedded generator -->
</p>
git push --set-upstream origin YourChangesBranch
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
(remember that you didn't have write permission to the original repo!)
<li>
You probably now get a message with URL to visit for creating
  a pull request.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

</p>

<h2><a id="Otherissues">26.11</a> Other issues</h2>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Otherissues">Other issues</a>
</p>
<p name="switchToTextMode">

<h3><a id="Transport">26.11.1</a> Transport</h3>
<p name=crumbs>
crumb trail:  > <a href="svn.html">svn</a> > <a href="svn.html#Otherissues">Other issues</a> > <a href="svn.html#Transport">Transport</a>
</p>
</p>

<p name="switchToTextMode">
Mercurial and git can use either 
<tt>ssh</tt>
 or 
<tt>http</tt>
 as
<i>transport</i>
<!-- index -->
<!-- index -->
.
With Git you may need to redefine the transport for a 
<tt>push</tt>
:
<!-- environment: verbatim start embedded generator -->
</p>
git remote rm origin
git remote add origin git@github.com:TACC/pylauncher.git
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

You can change the transport with 
<tt>git remote set-url</tt>
:
<!-- environment: verbatim start embedded generator -->
</p>
git remote -v # check current transport
git remote set-url origin git@hostname:USERNAME/REPOSITORY.git
git remote -v # verify changes
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<!-- index -->
<!-- index -->
<p name="switchToTextMode">

</p>

</div>
<a href="index.html">Back to Table of Contents</a>
