<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Good coding practices</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


29.1 : <a href="coding.html#Defensiveprogramming">Defensive programming</a><br>
29.1.1 : <a href="coding.html#Assertions">Assertions</a><br>
29.1.1.1 : <a href="coding.html#TheC<tt>assert<tt>macro">The C <tt>assert</tt> macro</a><br>
29.1.1.2 : <a href="coding.html#AnassertmacroforFortran">An assert macro for Fortran</a><br>
29.1.2 : <a href="coding.html#Useoferrorcodes">Use of error codes</a><br>
29.2 : <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a><br>
29.2.1 : <a href="coding.html#Arrayboundcheckingandothermemorytechniques">Array bound checking and other memory techniques</a><br>
29.2.2 : <a href="coding.html#Memoryleaks">Memory leaks</a><br>
29.2.3 : <a href="coding.html#Roll-your-ownmalloc">Roll-your-own malloc</a><br>
29.2.4 : <a href="coding.html#Specifictechniques:Fortran">Specific techniques: Fortran</a><br>
29.3 : <a href="coding.html#Testing">Testing</a><br>
29.3.1 : <a href="coding.html#Test-drivendesignanddevelopment">Test-driven design and development</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>29 Good coding practices</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

Sooner or later, and probably sooner than later, every programmer is
confronted with code not behaving as intended. In this section you
will learn some techniques of dealing with this problem. At first we
will see a number of techniques for 
<i>preventing</i>
 errors;
in the next chapter we will discuss debugging, the process of
finding the inevitable errors in a program, once they have occurred.
</p>

<h2><a id="Defensiveprogramming">29.1</a> Defensive programming</h2>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Defensiveprogramming">Defensive programming</a>
</p>
<p name="switchToTextMode">

In this section we will discuss a number of  techniques
that are aimed at preventing the likelihood of programming errors, or
increasing the likelihood of them being found at runtime.
We call this  
</p>

<p name="switchToTextMode">
Scientific codes are often large and involved, so it
is a good practice to code knowing that you are going to make mistakes
and prepare for them. Another good coding practice is the use of
tools: there is no point in reinventing the wheel if someone has
already done it for you. Some of these tools are be described in
other sections:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Build systems, such as Make, Scons, Bjam; see section~
tut:gnumake
.
<li>
Source code management with SVN, Git; see section~
tut:svn
.
<li>
Regression testing and designing with testing in mind (unit testing)
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

First we will have a look at runtime sanity checks, where you test
for things that can not or should not
happen.
</p>

<h3><a id="Assertions">29.1.1</a> Assertions</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Defensiveprogramming">Defensive programming</a> > <a href="coding.html#Assertions">Assertions</a>
</p>
<!-- index -->
<p name="switchToTextMode">

In the things that can go wrong with a program we can distinguish between
errors and bugs. Errors are things that legitimately happen but that should
not. File systems are common sources of errors: a program wants to open a file but
the file doesn't exist because the user mistyped the name, or the program
writes to a file but the disk is full. Other errors can come from arithmetic,
such as 
<i>overflow</i>
 errors.
</p>

<p name="switchToTextMode">
On the other hand, a 
<i>bug</i>
 in a program is an occurrence that cannot
legitimately occur. Of course, `legitimately' here means `according to
the programmer's intentions'. Bugs can often be described as `the computer
always does what you ask, not necessarily what you want'.
</p>

<p name="switchToTextMode">
Assertions serve to detect bugs in your program: an 
<i>assertion</i>
is a predicate that should be true at a certain point in your program.
Thus, an assertion failing means that you didn't code what you intended to code.
An assertion is typically a statement in your programming language,
or a preprocessor macro; upon failure of the assertion, your program
will stop.
</p>

<p name="switchToTextMode">
Some examples of assertions:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
If a subprogram has an array argument, it is a good idea to
  test whether the actual argument is a null pointer before indexing
  into the array.
<li>
Similarly, you could test a dynamically allocated data structure
  for not having a null pointer.
<li>
If you calculate a numerical result for which certain
  mathematical properties hold, for instance you are writing a sine function, for
  which the result has to be in $[-1,1]$, you should test whether this
  property indeed holds for the result.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Assertions are often disabled in a program once it's sufficiently tested.
The reason for this is that assertions can be expensive to execute.
For instance,
if you have a complicated data structure, you could write a complicated
integrity test, and perform that test in an assertion, which you put
after every access to the data structure.
</p>

<p name="switchToTextMode">
Because assertions are often disabled in the `production' version of a code,
they should not affect any stored data . If they do, your code may
behave differently when you're testing it with assertions, versus how you
use it in practice without them. This is also formulated as `assertions
should not have 
<i>side-effects</i>
'.
</p>

<p name="switchToTextMode">

<h4><a id="TheC<tt>assert<tt>macro">29.1.1.1</a> The C <tt>assert</tt> macro</h4>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Defensiveprogramming">Defensive programming</a> > <a href="coding.html#Assertions">Assertions</a> > <a href="coding.html#TheC<tt>assert<tt>macro">The C <tt>assert</tt> macro</a>
</p>
</p>

<p name="switchToTextMode">
The C standard library has a file 
<tt>assert.h</tt>
 which provides an

<tt>assert()</tt>
 macro. Inserting 
<tt>assert(foo)</tt>
 has the following
effect: if 
<tt>foo</tt>
 is zero (false), a diagnostic message is printed
on standard error:
<!-- environment: verbatim start embedded generator -->
</p>
Assertion failed: foo, file filename, line line-number
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
which includes the literal text of the expression,
the file name, and line number; and the program is subsequently stopped.
Here is an example:
<!-- environment: verbatim start embedded generator -->
</p>
#include&lt;assert.h&gt;


void open_record(char *record_name)
{
  assert(record_name!=NULL);
  /* Rest of code */
}


int main(void)
{
  open_record(NULL);
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
The 
<tt>assert</tt>
 macro can be disabled by defining the

<tt>NDEBUG</tt>
 macro.
</p>

<h4><a id="AnassertmacroforFortran">29.1.1.2</a> An assert macro for Fortran</h4>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Defensiveprogramming">Defensive programming</a> > <a href="coding.html#Assertions">Assertions</a> > <a href="coding.html#AnassertmacroforFortran">An assert macro for Fortran</a>
</p>
<p name="switchToTextMode">

(Thanks to Robert Mclay for this code.)
</p>

<!-- environment: verbatim start embedded generator -->
#if (defined( GFORTRAN ) || defined( G95 ) || defined ( PGI) )
# define MKSTR(x) "x"
#else
# define MKSTR(x) #x
#endif
#ifndef NDEBUG
# define ASSERT(x, msg) if (.not. (x) ) \
                call assert( FILE , LINE ,MKSTR(x),msg)
#else
# define ASSERT(x, msg)
#endif
subroutine assert(file, ln, testStr, msgIn)
implicit none
character(*) :: file, testStr, msgIn
integer :: ln
print *, "Assert: ",trim(testStr)," Failed at ",trim(file),":",ln
print *, "Msg:", trim(msgIn)
stop
end subroutine assert
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
which is used as
<!-- environment: verbatim start embedded generator -->
</p>
ASSERT(nItemsSet.gt.arraySize,"Too many elements set")
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- environment: notready start embedded generator -->
</p>

</notready>
<!-- environment: notready end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
</p>

<h3><a id="Useoferrorcodes">29.1.2</a> Use of error codes</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Defensiveprogramming">Defensive programming</a> > <a href="coding.html#Useoferrorcodes">Use of error codes</a>
</p>
<p name="switchToTextMode">

In some software libraries (for instance MPI or PETSc) every subprogram
returns a result, either the function value or a parameter, to
indicate success or failure of the routine. It is good programming
practice to check these error parameters, even if you think that
nothing can possibly go wrong.
</p>

<p name="switchToTextMode">
It is also a good idea to write your own subprograms in such a way
that they always have an error parameter. Let us consider the case of
a function that performs some numerical computation.
</p>

<!-- environment: verbatim start embedded generator -->
float compute(float val)
{
  float result;
  result = ... /* some computation */
  return result;
}


float value,result;
result = compute(value);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Looks good? What if the computation can fail, for instance:
<!-- environment: verbatim start embedded generator -->
</p>
  result = ... sqrt(val) ... /* some computation */
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
How do we handle the case where the user passes a negative number?
<!-- environment: verbatim start embedded generator -->
</p>
float compute(float val)
{
  float result;
  if (val&lt;0) { /* then what? */
  } else
    result = ... sqrt(val) ... /* some computation */
  return result;
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
We could print an error message and deliver some result, but the
message may go unnoticed, and the calling environment does not really
receive any notification that something has gone wrong.
</p>

<p name="switchToTextMode">
The following approach is more flexible:
<!-- environment: verbatim start embedded generator -->
</p>
int compute(float val,float *result)
{
  float result;
  if (val&lt;0) {
    return -1;
  } else {
    *result = ... sqrt(val) ... /* some computation */
  }
  return 0;
}


float value,result; int ierr;
ierr = compute(value,&result);
if (ierr!=0) { /* take appropriate action */
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
You can save yourself a lot of typing by writing
<!-- environment: verbatim start embedded generator -->
</p>
#define CHECK_FOR_ERROR(ierr) \
  if (ierr!=0) { \
    printf("Error %d detected\n",ierr); \
    return -1 ; }
....
ierr = compute(value,&result); CHECK_FOR_ERROR(ierr);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Using some cpp macros you can even define
<!-- environment: verbatim start embedded generator -->
</p>
#define CHECK_FOR_ERROR(ierr) \
  if (ierr!=0) { \
    printf("Error %d detected in line %d of file %s\n",\
           ierr,__LINE__,__FILE__); \
    return -1 ; }
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Note that this macro not only prints an error message, but also does a
further return. This means that, if you adopt this use of error codes
systematically, you will get a full backtrace of the calling tree if
an error occurs. (In the Python language this is precisely the wrong
approach since the backtrace is built-in.)
</p>

<h2><a id="Guardingagainstmemoryerrors">29.2</a> Guarding against memory errors</h2>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a>
</p>
<p name="switchToTextMode">

In scientific computing it goes pretty much without saying that you
will be working with large amounts of data.
Some programming languages make managing data easy, others, one might
say, make making errors with data easy.
</p>

<p name="switchToTextMode">
The following are some examples of 
<i>memory violations</i>

<!-- index -->
.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Writing outside array bounds. If the address is outside the user
  memory, your code may exit with an error such as
<i>segmentation violation</i>
, and the error is reasonably easy
  to find. If the address is just outside an array, it will corrupt
  data but not crash the program; such an error may go undetected for
  a long time, as it can have no effect, or only introduce subtly
  wrong values in your computation.
<li>
Reading outside array bounds can be harder to find than errors
  in writing, as it will often not stop your code, but only introduce
  wrong values.
<li>
The use of uninitialized memory is similar to reading outside
  array bounds, and can go undetected for a long time. One variant of
  this is through attaching memory to an unallocated pointer.
</p>

<p name="switchToTextMode">
  This particular kind of error can manifest itself in interesting
  behavior. Let's say you notice that your program misbehaves, you
  recompile it with debug mode to find the error, and now the error no
  longer occurs. This is probably due to the effect that, with low
  optimization levels, all allocated arrays are filled with
  zeros. Therefore, your code was originally reading a random value,
  but is now getting a zero.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

This section contains some
techniques to prevent errors in dealing with memory that you have
reserved for your data.
</p>

<h3><a id="Arrayboundcheckingandothermemorytechniques">29.2.1</a> Array bound checking and other memory techniques</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a> > <a href="coding.html#Arrayboundcheckingandothermemorytechniques">Array bound checking and other memory techniques</a>
</p>
<p name="switchToTextMode">

In parallel codes, memory errors will often show up by a crash in an
MPI routine. This is hardly ever an MPI problem or a problem with your
cluster.
</p>

<p name="switchToTextMode">
Compilers for  Fortran often have support for array bound
checking. Since this makes your code much slower, you would only
enable it during the development phase of your code.
</p>

<h3><a id="Memoryleaks">29.2.2</a> Memory leaks</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a> > <a href="coding.html#Memoryleaks">Memory leaks</a>
</p>
<p name="switchToTextMode">

We say that a program has a 
<i>memory leak</i>
, if it allocates
memory, and subsequently loses track of that memory. The operating
system then thinks the memory is in use, while it is not, and as a
result the computer memory can get filled up with allocated memory
that serves no useful purpose.
</p>

<p name="switchToTextMode">
In this example data is allocated inside a lexical scope:
<!-- environment: verbatim start embedded generator -->
</p>
for (i=.... ) {
  real *block = malloc( /* large number of bytes */ )
  /* do something with that block of memory */
  /* and forget to call "free" on that block */
}
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
The block of memory is allocated in each iteration, but the allocation
of one iteration is no longer available in the next. A similar example
can be made with allocating inside a conditional.
</p>

<p name="switchToTextMode">
It should be noted
that this problem is far less serious in Fortran, where memory is
deallocated automatically as a variable goes out of scope.
</p>

<p name="switchToTextMode">
There are various tools for detecting memory errors: Valgrind,
DMALLOC, Electric Fence. For valgrind, see section&nbsp;
30.6.2.1
.
</p>

<h3><a id="Roll-your-ownmalloc">29.2.3</a> Roll-your-own malloc</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a> > <a href="coding.html#Roll-your-ownmalloc">Roll-your-own malloc</a>
</p>
<p name="switchToTextMode">

Many programming errors arise from improper use of dynamically
allocated memory: the program writes beyond the bounds, or writes to
memory that has not been allocated yet, or has already been
freed. While some compilers can do bound checking at runtime, this
slows down your program. A&nbsp;better strategy is to write your own memory
management. Some libraries such as PETSc already supply an enhanced
malloc; if this is available you should certainly make use of
it. (The 
<i>gcc</i>

<!-- index -->
 compiler has a
function 
<tt>mcheck</tt>
, defined in 
<tt>mcheck.h</tt>
, that has a
similar function.)
</p>

<p name="switchToTextMode">
If you write in&nbsp;C, you will probably know the 
<tt>malloc</tt>
 and 
<tt>free</tt>
 calls:
<!-- environment: verbatim start embedded generator -->
</p>
int *ip;
ip = (int*) malloc(500*sizeof(int));
if (ip==0) {/* could not allocate memory */}
..... do stuff with ip .....
free(ip);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
You can save yourself some typing by
<!-- environment: verbatim start embedded generator -->
</p>
#define MYMALLOC(a,b,c) \
  a = (c*)malloc(b*sizeof(c)); \
  if (a==0) {/* error message and appropriate action */}


int *ip;
MYMALLOC(ip,500,int);
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Runtime checks on memory usage (either by compiler-generated bounds
checking, or through tools like
valgrind or Rational Purify) are expensive, but you can catch many
problems by adding some functionality to your malloc.
What we will do here is to detect memory corruption
after the fact.
</p>

<p name="switchToTextMode">
We allocate a few integers to the left and right of the
allocated object (line&nbsp;
<tt>1</tt>
 in the code below),
and put a recognizable value in them (line 
<tt>2</tt>
 and&nbsp;
<tt>3</tt>
), as well as the
size of the object (line&nbsp;
<tt>2</tt>
). We then return the pointer to the
actually requested memory area (line&nbsp;
<tt>4</tt>
).
<!-- environment: verbatim start embedded generator -->
</p>
#define MEMCOOKIE 137
#define MYMALLOC(a,b,c) { \
  char *aa; int *ii; \
  aa = malloc(b*sizeof(c)+3*sizeof(int)); /* 1 */ \
  ii = (int*)aa; ii[0] = b*sizeof(c); \
          ii[1] = MEMCOOKIE;              /* 2 */ \
  aa = (char*)(ii+2); a = (c*)aa ;        /* 4 */ \
  aa = aa+b*sizesof(c); ii = (int*)aa; \
          ii[0] = MEMCOOKIE;              /* 3 */ \
  }
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Now you can write your own 
<tt>free</tt>
, which tests whether the bounds of
the object have not been written over.
<!-- environment: verbatim start embedded generator -->
</p>
#define MYFREE(a) { \
  char *aa; int *ii,; ii = (int*)a; \
  if (*(--ii)!=MEMCOOKIE) printf("object corrupted\n"); \
  n = *(--ii); aa = a+n; ii = (int*)aa; \
  if (*ii!=MEMCOOKIE)  printf("object corrupted\n"); \
  }
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
You can extend this idea: in every allocated object, also store two
pointers, so that the allocated memory areas become a doubly linked
list. You can then write a macro 
<tt>CHECKMEMORY</tt>
 which tests all your
allocated objects for corruption.
</p>

<p name="switchToTextMode">
Such solutions to the memory corruption problem are fairly easy to
write, and they carry little overhead. There is a memory overhead of
at most 5 integers per object, and there is practically no performance
penalty.
</p>

<p name="switchToTextMode">
(Instead of writing a wrapper for 
<tt>malloc</tt>
, on some systems you can
influence the behavior of the system routine. On linux, 
<tt>malloc</tt>

calls hooks that can be replaced with your own routines;
see&nbsp;
<a href=http://www.gnu.org/s/libc/manual/html_node/Hooks-for-Malloc.html>http://www.gnu.org/s/libc/manual/html_node/Hooks-for-Malloc.html</a>
.)
</p>

<h3><a id="Specifictechniques:Fortran">29.2.4</a> Specific techniques: Fortran</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Guardingagainstmemoryerrors">Guarding against memory errors</a> > <a href="coding.html#Specifictechniques:Fortran">Specific techniques: Fortran</a>
</p>
<p name="switchToTextMode">

Use 
<tt>Implicit none</tt>
.
</p>

<p name="switchToTextMode">
Put all subprograms in modules so that the compiler can check for
missing arguments and type mismatches. It also allows for automatic
dependency building with 
<tt>fdepend</tt>
.
</p>

<p name="switchToTextMode">
Use the C preprocessor for conditional compilation and such.
</p>

<h2><a id="Testing">29.3</a> Testing</h2>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Testing">Testing</a>
</p>
<p name="switchToTextMode">

There are various philosophies for testing the correctness of a code.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Correctness proving: the programmer draws up predicates that
  describe the intended behavior of code fragments and proves by
  mathematical techniques that these predicates
  hold&nbsp;
<a href="https://pages.tacc.utexas.edu/~eijkhout/istc/html/bibliography.html#Hoare1969axiomatic,Dijkstra1974Programming">[Hoare1969axiomatic,Dijkstra1974Programming]</a>
.
<li>
Unit testing: each routine is tested separately for
  correctness. This approach is often hard to do for numerical codes,
  since with floating point numbers there is essentially an infinity
  of possible inputs, and it is not easy to decide what would
  constitute a sufficient
  set of inputs.
<li>
Integration testing: test subsystems
<li>
System testing: test the whole code. This is often appropriate
  for numerical codes, since we often have model problems with known
  solutions, or there are properties such as bounds that need to hold
  on the global solution.
<li>
Test-driven design: the program development process is driven by
  the requirement that testing is possible at all times.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

With parallel codes we run into a new category of difficulties with
testing. Many algorithms, when executed in parallel, will execute
operations in a slightly different order, leading to different
roundoff behavior. For instance, the parallel computation of a vector
sum will use partial sums. Some algorithms have an inherent damping of
numerical errors, for instance stationary iterative methods
(section&nbsp;
5.5.1
), but others have no such built-in error
correction (nonstationary methods;
section&nbsp;
5.5.8
). As a result, the same iterative
process can take different numbers of iterations depending on how many
processors are used.
</p>

<h3><a id="Test-drivendesignanddevelopment">29.3.1</a> Test-driven design and development</h3>
<p name=crumbs>
crumb trail:  > <a href="coding.html">coding</a> > <a href="coding.html#Testing">Testing</a> > <a href="coding.html#Test-drivendesignanddevelopment">Test-driven design and development</a>
</p>
<p name="switchToTextMode">

In test-driven design there is a strong emphasis on the code always
being testable. The basic ideas are as follows.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Both the whole code and its parts should always be testable.
<li>
When extending the code, make only the smallest change that
  allows for testing.
<li>
With every change, test before and after.
<li>
Assure correctness before adding new features.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

</p>

</div>
<a href="index.html">Back to Table of Contents</a>
