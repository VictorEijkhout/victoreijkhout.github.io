<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Debugging</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


30.1 : <a href="debug.html#Invokingthedebugger">Invoking the debugger</a><br>
30.2 : <a href="debug.html#Findingerrors:where,frame,print">Finding errors: where, frame, print</a><br>
30.2.1 : <a href="debug.html#Cprograms">C programs</a><br>
30.2.2 : <a href="debug.html#Fortranprograms">Fortran programs</a><br>
30.3 : <a href="debug.html#Steppingthroughaprogram">Stepping through a program</a><br>
30.4 : <a href="debug.html#Inspectingvalues">Inspecting values</a><br>
30.5 : <a href="debug.html#Breakpoints">Breakpoints</a><br>
30.6 : <a href="debug.html#Memorydebugging">Memory debugging</a><br>
30.6.1 : <a href="debug.html#Typeofmemoryerrors">Type of memory errors</a><br>
30.6.1.1 : <a href="debug.html#Invalidpointers">Invalid pointers</a><br>
30.6.1.2 : <a href="debug.html#Out-of-boundserrors">Out-of-bounds errors</a><br>
30.6.1.3 : <a href="debug.html#Memoryleaks">Memory leaks</a><br>
30.6.2 : <a href="debug.html#Memorytools">Memory tools</a><br>
30.6.2.1 : <a href="debug.html#Valgrind">Valgrind</a><br>
30.6.2.2 : <a href="debug.html#Electricfence">Electric fence</a><br>
30.7 : <a href="debug.html#Paralleldebugging">Parallel debugging</a><br>
30.8 : <a href="debug.html#Furtherreading">Further reading</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>30 Debugging</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<!-- index -->
</p>

<!-- environment: quotation start embedded generator -->
<!-- TranslatingLineGenerator quotation ['quotation'] -->
  \noindent
  Debugging is like being the detective in a crime movie where you are
  also the murderer. (Filipe Fortes, 2013)
</p name="quotation">
</quotation>
<!-- environment: quotation end embedded generator -->
<p name="switchToTextMode">

When a program misbehaves, 
<i>debugging</i>
 is the process of finding
out 
<i>why</i>
.
There are various strategies of finding errors in a program.
The crudest one is debugging by print statements. If you have a
notion of where in your code the error arises, you can edit your code
to insert print statements, recompile, rerun, and see if the output
gives you any suggestions. There are several problems with this:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
The edit/compile/run cycle is time consuming, especially since
<li>
often the error will be caused by an earlier section of code,
  requiring you to edit, compile, and rerun repeatedly. Furthermore,
<li>
the amount of data produced by your program can be too large to
  display and inspect effectively, and
<li>
if your program is parallel, you probably need to print out data
  from all processors, making the inspection process very tedious.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
<!-- index -->
</p>

<p name="switchToTextMode">
For these reasons, the best way to debug is by the use of an
interactive 
<i>debugger</i>
, a program that allows you to monitor
and control the behavior of a running program. In this section you
will familiarize yourself with
<i>gdb</i>
<!-- index -->
 and
<i>lldb</i>
,
the open source
debuggers of the 
<i>GNU</i>
 and 
<i>clang</i>
 projects respectively.
Other debuggers are
proprietary, and typically come with a compiler suite. Another
distinction is that gdb is a commandline debugger; there are
graphical debuggers such as 
<i>ddd</i>
 (a~frontend to gdb) or
<i>DDT</i>
 and 
<i>TotalView</i>
 (debuggers for parallel
codes). We limit ourselves to gdb, since it incorporates the basic
concepts common to all debuggers.
</p>

<p name="switchToTextMode">
In this tutorial you will debug a number of simple programs with
gdb and valgrind. The files can be found in the repository
in the directory 
<tt>code/gdb</tt>
.
</p>

<!-- environment: table start embedded generator -->
<!-- TranslatingLineGenerator table ['table'] -->
<p name="caption">
TABLE: List of common gdb / lldb commands
</p>
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
    \toprule
    gdb </td><td> lldb</td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Starting a debugger run </td></tr>
<tr><td>
    \midrule
    
<tt>\$ gdb program</tt>
</td><td>
<tt>\$ lldb program</tt>
</td></tr>
<tr><td>
    
<tt>(gdb) run</tt>
</td><td>
<tt>(lldb) run</tt>
</td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Displaying a stack trace </td></tr>
<tr><td>
    \midrule
    
<tt>(gdb) where</tt>
</td><td>
<tt>(lldb) thread backtrace</tt>
</td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Investigate a specific frame</td></tr>
<tr><td>
    \midrule
    
<tt>frame 2</tt>
</td><td>
<tt>frame select 2</tt>
</td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Run/step</td></tr>
<tr><td>
    \midrule
    
<tt>run / step / continue</tt>
</td><td>thread continue / step-in/over/out</td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Set a breakpoint at a line</td></tr>
<tr><td>
    \midrule
    
<tt>break foo.c:12</tt>
</td><td>
<tt>breakpoint set [ -f foo.c ] -l 12</tt>
</td></tr>
<tr><td>
    
<tt>break foo.c:12 if n>0</tt>
</td><td></td></tr>
<tr><td>
    
<tt>info breakpoints</tt>
</td><td></td></tr>
<tr><td>
</p>

<p name="switchToTextMode">
    \midrule
    Set a breakpoint for exceptions</td></tr>
<tr><td>
    \midrule
    
<tt>catch throw</tt>
</td><td>
<tt>break set -E C++</tt>
</td></tr>
<tr><td>
    \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
</tbody></table>
</table>
<!-- environment: table end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Invokingthedebugger">30.1</a> Invoking the debugger</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Invokingthedebugger">Invoking the debugger</a>
</p>
</p>

<p name="switchToTextMode">
There are three ways of using gdb: using it to start a program,
attaching it to an already running program, or using it to inspect a
<i>core dump</i>
. We will only consider the first possibility.
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  \toprule
  Starting a debugger run </td></tr>
<tr><td>
  \midrule
  gdb </td><td> lldb</td></tr>
<tr><td>
  \midrule
  
<tt>\$ gdb program</tt>
</td><td>
<tt>\$ lldb program</tt>
</td></tr>
<tr><td>
  
<tt>(gdb) run</tt>
</td><td>
<tt>(lldb) run</tt>
</td></tr>
<tr><td>
  \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

Here is an example of how to start gdb with program that has no
arguments (Fortran users, use 
<tt>hello.F</tt>
):
\codelisting{tutorials/gdb/c/hello.c}
<!-- environment: verbatim start embedded generator -->
</p>
%% cc -g -o hello hello.c
# regular invocation:
%% ./hello
hello world
# invocation from gdb:
%% gdb hello
GNU gdb 6.3.50-20050815 # ..... [version info]
Copyright 2004 Free Software Foundation, Inc. .... [copyright info] ....
(gdb) run
Starting program: /home/eijkhout/tutorials/gdb/hello
Reading symbols for shared libraries +. done
hello world


Program exited normally.
(gdb) quit
%%
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Important note: the program was compiled with the 
  flag}&nbsp;
<tt>-g</tt>
. This causes the 
<i>symbol table</i>
 (that is, the
translation from machine address to program variables) and other debug
information to be included in the binary. This will make your binary
larger than strictly necessary, but it will also make it slower, for
instance because the compiler will not perform certain
optimizations\footnote{Compiler optimizations are not supposed to
  change the semantics of a program, but sometimes do. This can lead
  to the nightmare scenario where a program crashes or gives incorrect
  results, but magically works correctly with compiled with debug and
  run in a debugger.}.
</p>

<p name="switchToTextMode">
To illustrate the presence of the symbol table do
<!-- environment: verbatim start embedded generator -->
</p>
%% cc -g -o hello hello.c
%% gdb hello
GNU gdb 6.3.50-20050815 # ..... version info
(gdb) list
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
and compare it with leaving out the 
<tt>-g</tt>
 flag:
<!-- environment: verbatim start embedded generator -->
</p>
%% cc -o hello hello.c
%% gdb hello
GNU gdb 6.3.50-20050815 # ..... version info
(gdb) list
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

For a program with commandline input we give the arguments to the

<tt>run</tt>
 command (Fortran users use 
<tt>say.F</tt>
):
<!-- environment: multicols start embedded generator -->
</p>
<!-- TranslatingLineGenerator multicols ['multicols'] -->
  \codelisting{tutorials/gdb/c/say.c}
  \vfill
<!-- environment: verbatim start embedded generator -->
</p>
%% cc -o say -g say.c
%% ./say 2
hello world
hello world
%% gdb say
.... the usual messages ...
(gdb) run 2
Starting program: /home/eijkhout/tutorials/gdb/c/say 2
Reading symbols for shared libraries +. done
hello world
hello world


Program exited normally.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
</multicols>
<!-- environment: multicols end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Findingerrors:where,frame,print">30.2</a> Finding errors: where, frame, print</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Findingerrors:where,frame,print">Finding errors: where, frame, print</a>
</p>
</p>

<p name="switchToTextMode">
Let us now consider some programs with errors.
</p>

<h3><a id="Cprograms">30.2.1</a> C programs</h3>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Findingerrors:where,frame,print">Finding errors: where, frame, print</a> > <a href="debug.html#Cprograms">C programs</a>
</p>
<p name="switchToTextMode">

The following code has several errors.
We will use the debugger to uncover them.
</p>

<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#gdb-square" aria-expanded="false" aria-controls="gdb-square">
        Text: gdb-square
      </button>
    </h5>
  </div>
  <div id="gdb-square" class="collapse">
  <pre>
// square.c
  int nmax,i;
  float *squares,sum;

  fscanf(stdin,"%d",nmax);
  for (i=1; i&lt;=nmax; i++) {
    squares[i] = 1./(i*i); sum += squares[i];
  }
  printf("Sum: %e\n",sum);
</pre>
</div>
</div>
<!-- environment: verbatim start embedded generator -->
%% cc -g -o square square.c
%% ./square
5000
Segmentation fault
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
The 
<i>segmentation fault</i>
 (other messages are possible too)
indicates that we are accessing
memory that we are not allowed to, making the program exit.
A&nbsp;debugger will quickly tell us where this happens:
<!-- environment: verbatim start embedded generator -->
</p>
%% gdb square
(gdb) run
50000


Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x000000000000eb4a
0x00007fff824295ca in __svfscanf_l ()
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Apparently the error occurred in a function 
<tt>__svfscanf_l</tt>
, which is
not one of ours, but a system function. Using the 
<tt>backtrace</tt>

(or&nbsp;
<tt>bt</tt>
, also 
<tt>where</tt>
 or&nbsp;
<tt>w</tt>
) command we
display the 
<i>call stack</i>
. This usually allows us to find out
where the error lies:
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  \toprule
  Displaying a stack trace </td></tr>
<tr><td>
  \midrule
  gdb </td><td> lldb</td></tr>
<tr><td>
  \midrule
  
<tt>(gdb) where</tt>
</td><td>
<tt>(lldb) thread backtrace</tt>
</td></tr>
<tr><td>
  \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

{\small
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) where
#0  0x00007fff824295ca in __svfscanf_l ()
#1  0x00007fff8244011b in fscanf ()
#2  0x0000000100000e89 in main (argc=1, argv=0x7fff5fbfc7c0) at square.c:7
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
</p>

<p name="switchToTextMode">
We inspect the actual problem:
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
    \toprule
    Investigate a specific frame</td></tr>
<tr><td>
    \midrule
    gdb</td><td>clang</td></tr>
<tr><td>
    
<tt>frame 2</tt>
</td><td>
<tt>frame select 2</tt>
</td></tr>
<tr><td>
    \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

We take a close look at line&nbsp;7, and see that we need to
change 
<tt>nmax</tt>
 to&nbsp;
<tt>&nmax</tt>
.
</p>

<p name="switchToTextMode">
There is still an error in our program:
{\small
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) run
50000


Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0x000000010000f000
0x0000000100000ebe in main (argc=2, argv=0x7fff5fbfc7a8) at square1.c:9
9           squares[i] = 1./(i*i); sum += squares[i];
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
We investigate further:
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) print i
$1 = 11237
(gdb) print squares[i]
Cannot access memory at address 0x10000f000
(gdb) print squares
$2 = (float *) 0x0
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
and we quickly see that we forgot to allocate 
<tt>squares</tt>
.
</p>

<p name="switchToTextMode">
Memory errors can also occur if we have a legitimate array, but we access it
outside its bounds.
The following program fills an array, forward, and reads it out, backward.
However, there is an indexing error in the second loop.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#gdb-up" aria-expanded="false" aria-controls="gdb-up">
        Text: gdb-up
      </button>
    </h5>
  </div>
  <div id="gdb-up" class="collapse">
  <pre>
// up.c
  int nlocal = 100,i;
  double s, *array = (double*) malloc(nlocal*sizeof(double));
  for (i=0; i&lt;nlocal; i++) {
    double di = (double)i;
    array[i] = 1/(di*di);
  }
  s = 0.;
  for (i=nlocal-1; i&gt;=0; i++) {
    double di = (double)i;
    s += array[i];
  }
</pre>
</div>
</div>
<!-- environment: verbatim start embedded generator -->
</p>
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000100200000
0x0000000100000f43 in main (argc=1, argv=0x7fff5fbfe2c0) at up.c:15
15          s += array[i];
(gdb) print array
$1 = (double *) 0x100104d00
(gdb) print i
$2 = 128608
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
You see that the index where the debugger finally complains
is quite a bit larger than the size of the array.
<!-- environment: exercise start embedded generator -->
</p>
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Can you think of a reason why indexing out of bounds is not immediately fatal?
  What would determine where it does become a problem?
  (Hint: how is computer memory structured?)
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<!-- environment: answer start embedded generator -->

</answer>
<!-- environment: answer end embedded generator -->
<p name="switchToTextMode">

In section&nbsp;
30.6.2.1
 you will see a tool
that spots any out-of-bound indexing.
</p>

<h3><a id="Fortranprograms">30.2.2</a> Fortran programs</h3>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Findingerrors:where,frame,print">Finding errors: where, frame, print</a> > <a href="debug.html#Fortranprograms">Fortran programs</a>
</p>
<p name="switchToTextMode">

Compile and run the following program:
\codelisting{tutorials/gdb/f/square.F}
It should end prematurely with a message such as `Illegal instruction'.
Running the program in gdb quickly tells you where the problem lies:
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) run
Starting program: tutorials/gdb//fsquare
Reading symbols for shared libraries ++++. done


Program received signal EXC_BAD_INSTRUCTION,
Illegal instruction/operand.
0x0000000100000da3 in square () at square.F:7
7                sum = sum + squares(i)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
We take a close look at the code and see that we did not allocate

<tt>squares</tt>
 properly.
</p>

<h2><a id="Steppingthroughaprogram">30.3</a> Stepping through a program</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Steppingthroughaprogram">Stepping through a program</a>
</p>
<p name="switchToTextMode">

<!-- environment: tabular start embedded generator -->
</p>
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  \toprule
  Stepping through a program</td></tr>
<tr><td>
  \midrule
  gdb</td><td>lldb</td><td>meaning</td></tr>
<tr><td>
  
<tt>run</tt>
</td><td></td><td>start a run</td></tr>
<tr><td>
  
<tt>cont</tt>
</td><td></td><td>continue from breakpoint</td></tr>
<tr><td>
  
<tt>next</tt>
</td><td></td><td>next statement on same level</td></tr>
<tr><td>
  
<tt>step</tt>
</td><td></td><td>next statement, this level or next</td></tr>
<tr><td>
  \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

Often the error in a program is sufficiently obscure that you need to
investigate the program run in detail. Compile the following program
\codelisting{tutorials/gdb/c/roots.c}
and run it:
<!-- environment: verbatim start embedded generator -->
</p>
%% ./roots
sum: nan
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Start it in gdb as before:
<!-- environment: verbatim start embedded generator -->
</p>
%% gdb roots
GNU gdb 6.3.50-20050815
Copyright 2004 Free Software Foundation, Inc.
....
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
but before you run the program, you set a 
<i>breakpoint</i>
at 
<tt>main</tt>
.
This tells the execution to stop, or `break', in the main program.
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) break main
Breakpoint 1 at 0x100000ea6: file root.c, line 14.
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Now the program will stop at the first executable statement in 
<tt>main</tt>
:
<!-- environment: verbatim start embedded generator -->
</p>
(gdb) run
Starting program: tutorials/gdb/c/roots
Reading symbols for shared libraries +. done


Breakpoint 1, main () at roots.c:14
14        float x=0;
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Most of the time you will set a breakpoint at a specific line:
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  \toprule
  Set a breakpoint at a line</td></tr>
<tr><td>
  \midrule
  gdb</td><td>lldb</td></tr>
<tr><td>
  
<tt>break foo.c:12</tt>
</td><td>
<tt>breakpoint set [ -f foo.c ] -l 12</tt>
</td></tr>
<tr><td>
  \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

If execution is stopped at a breakpoint, you can do various things,
such as issuing the 
<tt>step</tt>
 command:
<!-- environment: verbatim start embedded generator -->
</p>
Breakpoint 1, main () at roots.c:14
14        float x=0;
(gdb) step
15        for (i=100; i&gt;-100; i--)
(gdb)
16          x += root(i);
(gdb)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
(if you just hit return, the previously issued command is
repeated). Do a number of 
<tt>step</tt>
s in a row by hitting return. What
do you notice about the function and the loop?
</p>

<p name="switchToTextMode">
Switch from doing 
<tt>step</tt>
 to doing 
<tt>next</tt>
. Now what do you notice
about the loop and the function?
</p>

<p name="switchToTextMode">
Set another breakpoint: 
<tt>break 17</tt>
 and do 
<tt>cont</tt>
. What happens?
</p>

<p name="switchToTextMode">
Rerun the program after you set a breakpoint on the line with the

<tt>sqrt</tt>
 call. When the execution stops there do 
<tt>where</tt>
 and

<tt>list</tt>
.
</p>

<h2><a id="Inspectingvalues">30.4</a> Inspecting values</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Inspectingvalues">Inspecting values</a>
</p>
<p name="switchToTextMode">

Run the previous program again in gdb: set a breakpoint at the line
that does the 
<tt>sqrt</tt>
 call before you actually call 
<tt>run</tt>
. When the
program gets to line&nbsp;8 you can do 
<tt>print n</tt>
. Do 
<tt>cont</tt>
. Where does
the program stop?
</p>

<p name="switchToTextMode">
If you want to repair a variable, you can do 
<tt>set var=value</tt>
. Change
the variable 
<tt>n</tt>
 and confirm that the square root of the new value
is computed. Which commands do you do?
</p>

<h2><a id="Breakpoints">30.5</a> Breakpoints</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Breakpoints">Breakpoints</a>
</p>
<!-- index -->
<p name="switchToTextMode">

If a problem occurs in a loop, it can be tedious keep typing 
<tt>cont</tt>

and inspecting the variable with 
<tt>print</tt>
. Instead you can add a
condition to an existing breakpoint. First of all, you can make the breakpoint
subject to a condition: with
<!-- environment: verbatim start embedded generator -->
</p>
condition 1 if (n&lt;0)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
breakpoint&nbsp;1 will only obeyed if 
<tt>n&lt;0</tt>
 is true.
</p>

<p name="switchToTextMode">
You can also have a breakpoint that is only activated by some condition.
The statement
<!-- environment: verbatim start embedded generator -->
</p>
break 8 if (n&lt;0)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
means that breakpoint&nbsp;8 becomes (unconditionally) active after
the condition 
<tt>n&lt;0</tt>
 is encountered.
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
  \toprule
  Set a breakpoint </td></tr>
<tr><td>
  \midrule
  gdb </td><td> lldb</td></tr>
<tr><td>
  \midrule
    
<tt>break foo.c:12</tt>
</td><td>
<tt>breakpoint set [ -f foo.c ] -l 12</tt>
</td></tr>
<tr><td>
    
<tt>break foo.c:12 if n</td><td>gt;0</tt>
</td><td></td></tr>
<tr><td>
  \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

</p>

<!-- environment: remark start embedded generator -->
<!-- TranslatingLineGenerator remark ['remark'] -->
  You can break on 
<tt>NaN</tt>
 with the following trick:
<!-- environment: verbatim start embedded generator -->
</p>
break foo.c:12 if x!=x
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
  using the fact that 
<tt>NaN</tt>
 is the only number not equal to itself.
</p name="remark">
</remark>
<!-- environment: remark end embedded generator -->
<p name="switchToTextMode">

Another possibility is to use 
<tt>ignore 1 50</tt>
, which will not stop at
breakpoint 1 the next 50 times.
</p>

<p name="switchToTextMode">
Remove the existing breakpoint, redefine it with the condition 
<tt>n&lt;0</tt>

and rerun your program. When the program breaks, find for what value
of the loop variable it happened. What is the sequence of commands you use?
</p>

<p name="switchToTextMode">
You can set a breakpoint in various ways:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>break foo.c</tt>
 to stop when code in a certain file is reached;
<li>

<tt>break 123</tt>
 to stop at a certain line in the current file;
<li>

<tt>break foo</tt>
 to stop at subprogram 
<tt>foo</tt>

<li>
or various combinations, such as 
<tt>break foo.c:123</tt>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Information about breakpoints:
</p>

<!-- environment: itemize start embedded generator -->
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
If you set many breakpoints, you can find out what they are with
  
<tt>info breakpoints</tt>
.
<li>
You can remove breakpoints with 
<tt>delete n</tt>
 where 
<tt>n</tt>
 is the
  number of the breakpoint.
<li>
If you restart your program with 
<tt>run</tt>
 without leaving gdb,
  the breakpoints stay in effect.
<li>
If you leave gdb, the breakpoints are cleared but you can save
  them: 
<tt>save breakpoints &lt;file&gt;</tt>
. Use 
<tt>source &lt;file&gt;</tt>
 to read
  them in on the next gdb run.
<li>
In languages with 
<i>exceptions</i>
, such
  as&nbsp;
<i>C++</i>

<!-- index -->
, you can set a 
<i>catchpoint</i>
:
</p>

<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular ['tabular'] -->
    \toprule
    Set a breakpoint for exceptions</td></tr>
<tr><td>
    \midrule
    gdb</td><td>clang\   
<tt>catch throw</tt>
</td><td>
<tt>break set -E C++</tt>
</td></tr>
<tr><td>
    \bottomrule
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
<p name="switchToTextMode">

</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Finally, you can execute commands at a breakpoint:
<!-- environment: verbatim start embedded generator -->
</p>
break 45
command
print x
cont
end
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
This states that at line 45 variable&nbsp;
<tt>x</tt>
 is to be printed, and execution
should immediately continue.
</p>

<p name="switchToTextMode">
If you want to run repeated gdb sessions on the same program,
you may want to save an reload breakpoints. This can be done with
<!-- environment: verbatim start embedded generator -->
</p>
save-breakpoint filename
source filename
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
<!-- index -->
</p>

<h2><a id="Memorydebugging">30.6</a> Memory debugging</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a>
</p>
<p name="switchToTextMode">

Many problems in programming stem from memory errors. We start with a
sort description of the most common types, and then discuss tools that
help you detect them.
</p>

<h3><a id="Typeofmemoryerrors">30.6.1</a> Type of memory errors</h3>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Typeofmemoryerrors">Type of memory errors</a>
</p>
<p name="switchToTextMode">

<h4><a id="Invalidpointers">30.6.1.1</a> Invalid pointers</h4>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Typeofmemoryerrors">Type of memory errors</a> > <a href="debug.html#Invalidpointers">Invalid pointers</a>
</p>
</p>

<p name="switchToTextMode">
Dereferencing a pointer that does not point to an allocated object can lead to an error.
If your pointer points into valid memory anyway, your computation will continue but with incorrect results.
</p>

<p name="switchToTextMode">
However, it is more likely that
your program will probably exit with a
<i>segmentation violation</i>
 or a 
<i>bus error</i>
.
</p>

<h4><a id="Out-of-boundserrors">30.6.1.2</a> Out-of-bounds errors</h4>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Typeofmemoryerrors">Type of memory errors</a> > <a href="debug.html#Out-of-boundserrors">Out-of-bounds errors</a>
</p>
<p name="switchToTextMode">

Addressing outside the bounds of an allocated object is less likely to crash your program and more likely to give incorrect results.
</p>

<p name="switchToTextMode">
Exceeding bounds by a large enough amount will again give a
segmentation violation, but going out of bounds by a small amount may
read invalid data, or corrupt data of other variables, giving
incorrect results that may go undetected for a long time.
</p>

<h4><a id="Memoryleaks">30.6.1.3</a> Memory leaks</h4>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Typeofmemoryerrors">Type of memory errors</a> > <a href="debug.html#Memoryleaks">Memory leaks</a>
</p>
<p name="switchToTextMode">

We speak of a 
<i>memory leak</i>
 if allocated memory becomes unreachable.
Example:
<!-- environment: lstlisting start embedded generator -->
</p>
if (something) {
  double *x = malloc(10*sizeofdouble);
  // do something with x
}
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
After the conditional, the allocated memory is not freed, but the
pointer that pointed to has gone away.
</p>

<p name="switchToTextMode">
This last type especially can be hard to find.
Memory leaks will only surface in that your program runs out of
  memory. That in turn is detectable because your allocation will
  fail. It is a good idea to always check the return result of your
<tt>malloc</tt>
 or 
<tt>allocate</tt>
 statement!
</p>

<h3><a id="Memorytools">30.6.2</a> Memory tools</h3>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Memorytools">Memory tools</a>
</p>
<p name="switchToTextMode">

<h4><a id="Valgrind">30.6.2.1</a> Valgrind</h4>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Memorytools">Memory tools</a> > <a href="debug.html#Valgrind">Valgrind</a>
</p>

</p>

<p name="switchToTextMode">
Insert the following allocation of 
<tt>squares</tt>
 in your program:
<!-- environment: verbatim start embedded generator -->
</p>
squares = (float *) malloc( nmax*sizeof(float) );
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Compile and run your program. The output will likely be correct,
although the program is not. Can you see the problem?
</p>

<!-- index -->
<p name="switchToTextMode">

To find such subtle memory errors you need a different tool: a memory
debugging tool. A&nbsp;popular (because open source) one is
<i>valgrind</i>
<i>purify</i>
.
</p>

<p name="switchToTextMode">
\codelisting{tutorials/gdb/c/square1.c}
Compile this program with 
<tt>cc -o square1 square1.c</tt>
 and run it with

<tt>valgrind square1</tt>
 (you need to type the input value). You will lots
of output, starting with:
{\small
<!-- environment: verbatim start embedded generator -->
</p>
%% valgrind square1
==53695== Memcheck, a memory error detector
==53695== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==53695== Using Valgrind-3.6.1 and LibVEX; rerun with -h for copyright info
==53695== Command: a.out
==53695==
10
==53695== Invalid write of size 4
==53695==    at 0x100000EB0: main (square1.c:10)
==53695==  Address 0x10027e148 is 0 bytes after a block of size 40 alloc'd
==53695==    at 0x1000101EF: malloc (vg_replace_malloc.c:236)
==53695==    by 0x100000E77: main (square1.c:8)
==53695==
==53695== Invalid read of size 4
==53695==    at 0x100000EC1: main (square1.c:11)
==53695==  Address 0x10027e148 is 0 bytes after a block of size 40 alloc'd
==53695==    at 0x1000101EF: malloc (vg_replace_malloc.c:236)
==53695==    by 0x100000E77: main (square1.c:8)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
Valgrind is informative but cryptic, since it works on the bare
memory, not on variables. Thus, these error messages take some
exegesis. They state that a line 10 writes a 4-byte object immediately
after a block of 40 bytes that was allocated. In other words: the code
is writing outside the bounds of an allocated array. Do you see what
the problem in the code is?
</p>

<p name="switchToTextMode">
Note that valgrind also reports at the end of the program run how much
memory is still in use, meaning not properly 
<tt>free</tt>
d.
</p>

<p name="switchToTextMode">
If you fix the array bounds and recompile and rerun the program,
valgrind still complains:
{\small
<!-- environment: verbatim start embedded generator -->
</p>
==53785== Conditional jump or move depends on uninitialised value(s)
==53785==    at 0x10006FC68: __dtoa (in /usr/lib/libSystem.B.dylib)
==53785==    by 0x10003199F: __vfprintf (in /usr/lib/libSystem.B.dylib)
==53785==    by 0x1000738AA: vfprintf_l (in /usr/lib/libSystem.B.dylib)
==53785==    by 0x1000A1006: printf (in /usr/lib/libSystem.B.dylib)
==53785==    by 0x100000EF3: main (in ./square2)
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
}
Although no line number is given, the mention of 
<tt>printf</tt>
 gives an
indication where the problem lies.
The reference to an `uninitialized value' is again cryptic: the only
value being output is 
<tt>sum</tt>
, and that is not uninitialized: it has
been added to several times. Do you see why valgrind calls it
uninitialized all the same?
</p>

<!-- index -->
<p name="switchToTextMode">

<h4><a id="Electricfence">30.6.2.2</a> Electric fence</h4>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Memorydebugging">Memory debugging</a> > <a href="debug.html#Memorytools">Memory tools</a> > <a href="debug.html#Electricfence">Electric fence</a>
</p>
</p>

<p name="switchToTextMode">
The 
<i>electric fence</i>
 library is one of a number of tools
that supplies a new 
<tt>malloc</tt>
 with debugging support.
These are linked instead of the 
<tt>malloc</tt>
 of the standard
<tt>libc</tt>
.
</p>

<!-- environment: verbatim start embedded generator -->
cc -o program program.c -L/location/of/efence -lefence
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Suppose your program has an out-of-bounds error. Running with gdb,
this error may only become apparent if the bounds are exceeded by a
large amount. On the other hand, if the code is linked with
<tt>libefence</tt>
, the debugger will stop at the very first time
the bounds are exceeded.
</p>

<h2><a id="Paralleldebugging">30.7</a> Parallel debugging</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Paralleldebugging">Parallel debugging</a>
</p>
<!-- index -->
<p name="switchToTextMode">

<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/ddt2.jpg" width=800></img>
<p name="caption">
FIGURE 30.1: Display of 16 processes in the DDT debugger
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">

Debugging in parallel is harder than sequentially, because you will run
errors that are only due to interaction of processes such as 
<i>deadlock</i>
;
see section&nbsp;
2.6.3.6
.
</p>

<p name="switchToTextMode">
As an example, consider this segment of MPI code:
<!-- environment: verbatim start embedded generator -->
</p>
MPI_Init(0,0);
// set comm, ntids, mytid
for (int it=0; ; it++) {
  double randomnumber = ntids * ( rand() / (double)RAND_MAX );
  printf("[%d] iteration %d, random %e\n",mytid,it,randomnumber);
  if (randomnumber&gt;mytid && randomnumber&lt;mytid+1./(ntids+1))
    MPI_Finalize();
}
MPI_Finalize();
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Each process computes random numbers until a certain condition is satisfied, then exits.
However, consider introducing a barrier (or something that acts like it, such as a reduction):
<!-- environment: verbatim start embedded generator -->
</p>
for (int it=0; ; it++) {
  double randomnumber = ntids * ( rand() / (double)RAND_MAX );
  printf("[%d] iteration %d, random %e\n",mytid,it,randomnumber);
  if (randomnumber&gt;mytid && randomnumber&lt;mytid+1./(ntids+1))
    MPI_Finalize();
  MPI_Barrier(comm);
}
MPI_Finalize();
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
Now the execution will hang, and this is not due to any particular process:
each process has a code path from init to finalize that does not develop
any memory errors or other runtime errors.
However as soon as one process reaches the finalize call in the conditional
it will stop, and all other processes will be waiting at the barrier.
</p>

<p name="switchToTextMode">
Figure&nbsp;
30.1
 shows the main display of the Allinea 
<i>DDT</i>
debugger (
<a href=http://www.allinea.com/products/ddt>http://www.allinea.com/products/ddt</a>
) at the point where this code stops.
Above the source panel you see that there are 16 processes, and that the status is given
for process&nbsp;1.
In the bottom display you see that out of 16 processes 15&nbsp;are calling 
<tt>MPI_Barrier</tt>
 on line&nbsp;19,
while one is at line&nbsp;18. In the right display you see a listing of the local variables:
the value specific to process&nbsp;1. A&nbsp;rudimentary graph displays the values over the processors:
the value of 
<tt>ntids</tt>
 is constant, that of 
<tt>mytid</tt>
 is linearly increasing, and 
<tt>it</tt>

is constant except for one process.
</p>

<!-- environment: exercise start embedded generator -->
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Make and run 
<tt>ring_1a</tt>
. The program does not terminate and does not crash.
  In the debugger you can interrupt the execution, and see that all processes
  are executing a receive statement. This is probably a case of deadlock.
  Diagnose and fix the error.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<!-- environment: exercise start embedded generator -->
</p>
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  The author of 
<tt>ring_1c</tt>
 was very confused about how MPI works. Run the program.
  While it terminates without a problem, the output is wrong. Set a breakpoint
  at the send and receive statements to figure out what is happening.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

</p>

<!-- index -->
<p name="switchToTextMode">

<h2><a id="Furtherreading">30.8</a> Further reading</h2>
<p name=crumbs>
crumb trail:  > <a href="debug.html">debug</a> > <a href="debug.html#Furtherreading">Further reading</a>
</p>
</p>

<p name="switchToTextMode">
A good tutorial: 
<a href=http://www.dirac.org/linux/gdb/>http://www.dirac.org/linux/gdb/</a>
.
</p>

<p name="switchToTextMode">
Reference manual: 
<a href=http://www.ofb.net/gnu/gdb/gdb_toc.html>http://www.ofb.net/gnu/gdb/gdb_toc.html</a>
.
</p>

<!-- index -->
<p name="switchToTextMode">

</div>
<a href="index.html">Back to Table of Contents</a>
