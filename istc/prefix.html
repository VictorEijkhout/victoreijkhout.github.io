<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Parallel Prefix</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


21.1 : <a href="prefix.html#Parallelprefix">Parallel prefix</a><br>
21.2 : <a href="prefix.html#Sparsematrixvectorproductasparallelprefix">Sparse matrix vector product as parallel prefix</a><br>
21.3 : <a href="prefix.html#Horner'srule">Horner's rule</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>21 Parallel Prefix</h1>
<!-- TranslatingLineGenerator file ['file'] -->
</p>

<p name="switchToTextMode">
For operations to be executable in parallel they need to be independent.
That makes recurrences problematic to evaluate in parallel.
Recurrences occur in obvious places such as solving a triangular system
of equations (section~
5.3.5
),
but they can also appear in sorting and many other operations.
</p>

<p name="switchToTextMode">
In this appendix we look at 
<i>parallel prefix</i>
 operations: the
parallel execution of an operation that is defined by a recurrence
involving an associative operator.
(See also section~
6.9.2
 for the `recursive doubling'
approach to parallelizing recurrences.)
Computing the sum of an array of
elements is an example of this type of operation (disregarding the
</p>

<!-- index -->
<p name="switchToTextMode">
for the moment).
Let $\pi(x,y)$ be the binary sum operator: 
\[
 \pi(x,y)\equiv x+y, 
\]
then we define the prefix sum of $n\geq 2$ terms as
\[
 \Pi(x_1,\ldots,x_n) =
\begin{cases}
\pi(x_1,x_2)&\hbox{if $n=2$}\\
\pi\bigl( \Pi(x_1,\ldots,x_{n-1}),x_n\bigr)&\hbox{otherwise} \\
\end{cases}
\]
</p>

<p name="switchToTextMode">
As a non-obvious of a prefix operation, we could count the number of elements
of an array that have a certain property.
</p>

<!-- environment: exercise start embedded generator -->
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Let $p(\cdot)$ be a predicate, $p(x)=1$ if it holds for~$x$
  and 0~otherwise. Define a binary operator $\pi(x,y)$ so that
  its reduction over an array of numbers yields the number of
  elements for which $p$ is true.
</p name="exercise">
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

So let us now assume the existence of an associative operator~$\oplus$,
an array of values~$x_1,\ldots,x_n$. Then we define the prefix problem
as the computation of $X_1,\ldots,X_n$, where
\[
\begin{cases}
  X_1=x_1\\
  X_k=\oplus_{i\leq k} x_i
\end{cases}
\]
</p>

<h2><a id="Parallelprefix">21.1</a> Parallel prefix</h2>
<p name=crumbs>
crumb trail:  > <a href="prefix.html">prefix</a> > <a href="prefix.html#Parallelprefix">Parallel prefix</a>
</p>
<p name="switchToTextMode">

The key to parallelizing this is the realization that we can compute
partial reductions in parallel:
\[
 x_1\oplus x_2, \quad x_3\oplus x_4, \ldots 
\]
are all independent.
Furthermore, partial reductions of these reductions,
\[
 (x_1\oplus x_2) \oplus (x_3\oplus x_4),\quad \ldots 
\]
are also independent. We use the notation
\[
 X_{i,j}=x_i\oplus\cdots\oplus x_j 
\]
for these partial reductions.
</p>

<p name="switchToTextMode">
You have seen this before in section~
2.1
:
an array of $n$ numbers can be reduced in~$\lceil \log_2 n\rceil$
steps.
What is missing to make this a full prefix operation
is computation of all intermediate values.
</p>

<p name="switchToTextMode">
Observing that, for instance, $X_3=(x_1\oplus x_2)\oplus x_3=X_2\oplus x_3$,
you can now imagine the whole process; see figure~
21.1
for the case of $8$~elements.
<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/parallel-prefix.jpeg" width=800></img>
<p name="caption">
FIGURE 21.1: A prefix operation applied to 8 elements
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
To compute, say, $X_{13}$, you express $13=8+4+1$ and compute
$X_{13}=X_8\oplus X_{9,12} \oplus x_13$.
</p>

<p name="switchToTextMode">
In this figure, operations over the same `distance' have been
horizontally aligned corresponding to a 
<span title="acronym" ><i>SIMD</i></span>
 type execution.
If the execution proceeds with a task graph, some steps can be
executed earlier than the figure suggests; for instance $X_3$ can be
computed simultaneously with~$X_6$.
</p>

<p name="switchToTextMode">
Regardless the arrangement of the computational steps,
it is not hard to see that the whole prefix calculation
can be done in $2\log_2n$ steps: $\log_2 n$~steps for
computing the final reduction~$X_n$, then another $\log_2 n$
steps for filling in the intermediate values.
</p>

<h2><a id="Sparsematrixvectorproductasparallelprefix">21.2</a> Sparse matrix vector product as parallel prefix</h2>
<p name=crumbs>
crumb trail:  > <a href="prefix.html">prefix</a> > <a href="prefix.html#Sparsematrixvectorproductasparallelprefix">Sparse matrix vector product as parallel prefix</a>
</p>

<!-- index -->
<!-- index -->
<p name="switchToTextMode">

It has been observed that the sparse matrix vector product can be considered a prefix operation;
see~
<a href="https://pages.tacc.utexas.edu/~eijkhout/istc/html/bibliography.html#Blelloc:segmented-report">[Blelloc:segmented-report]</a>
.
The reasoning here is we first compute all $y_{ij}\equiv a_{ij}x_j$, and subsequently
compute the sums $y_i=\sum_j y_{ij}$ with a prefix operation.
</p>

<p name="switchToTextMode">
A~prefix sum as explained above does not compute the right result. The first couple of $y_{ij}$ terms
do indeed sum to~$y_1$, but then continuing the prefix sum gives $y_1+y_2$, instead of~$y_2$.
The trick to making this work is to consider two-component quantities $\langle y_{ij},s_{ij}\rangle$,
where
\[
 s_{ij} =
\begin{cases}
1&\hbox{if $j$ is the first nonzero index in row $i$}\\ 0&\hbox{otherwise}
\end{cases}
\]
Now we can define prefix sums that are `reset' every time $s_{ij}=1$.
</p>

<!-- index -->
<p name="switchToTextMode">

<h2><a id="Horner'srule">21.3</a> Horner's rule</h2>
<p name=crumbs>
crumb trail:  > <a href="prefix.html">prefix</a> > <a href="prefix.html#Horner'srule">Horner's rule</a>
</p>
</p>

<i>Horner's rule</i>
<p name="switchToTextMode">
for evaluating a polynomial is an example of a simple recurrence:
<!-- environment: equation start embedded generator -->
</p>
  y = c\_0 x^n +\cdots+ c\_n x^0 \equiv
\begin{cases}
    t\_0 \leftarrow c\_0\\
    t\_i \leftarrow t\_{i-1}\cdot x + c\_i&i=1,&hellip;,n\\
    y = t\_n\\
\end{cases}
\end{equation}
</equation>
<!-- environment: equation end embedded generator -->
<p name="switchToTextMode">
or, written more explicitly
\[
 y = \left(\left( ( c_0\cdot x + c_1 ) \cdot x + c_2 \right) \cdots \right)
   .
\]
Like many other recurrences, this seemingly sequential operation
can be parallelized:
\[
\begin{array}{cccc}
  c_0 x + c_1 & c_2 x + c_3 & c_4 x + c_5 & c_6 x + c_7\\
  \multicolumn{2}{@{}c@{}}{${\upbracefill}$} &
    \multicolumn{2}{@{}c@{}}{${\upbracefill}$} \\
  \multicolumn{2}{c}{\cdot \times x^2 + \cdot}&
    \multicolumn{2}{c}{\cdot \times x^2 + \cdot}\\
  \multicolumn{4}{c}{${\upbracefill}$} \\
  \multicolumn{4}{c}{\cdot \times x^4 + \cdot}\\
\end{array}
\]
</p>

<p name="switchToTextMode">
However, we see here that some cleverness is needed:
we need $x,x^2,x^4$ etc.\ to multiply subresults.
</p>

<p name="switchToTextMode">
Interpreting Horner's rule as a prefix scheme fails:
the `horner operator' $h_x(a,b)=ax+b$ is easily seen
not to be associative.
From the above treewise calculation we see that we
need to carry and update the&nbsp;$x$,
rather than attaching it to the operator.
</p>

<p name="switchToTextMode">
A&nbsp;little experimenting shows that
\newcommand\xyvec[2]{
  \left[
\begin{array}{c}
    #1\\#2
\end{array}
  \right]
}
\[
 h\left( \xyvec ax,\xyvec by \right) \equiv \xyvec {ay+b}{xy}
\]
serves our purposes:
\[
  h\left( \xyvec ax,\xyvec by ,\xyvec cz \right)
  = \left\{
\begin{array}{lll}
      h\left( h\left( \xyvec ax,\xyvec by \right ),\xyvec cz \right)
      &=&
      h\left( \xyvec {ay+b}{xy},\xyvec cz \right)
      \\
      h\left( \xyvec ax,h\left( \xyvec by ,\xyvec cz \right ) \right)
      &=&
      h\left( \xyvec ax,\xyvec { bz+c } {yz} \right)
\end{array}
  \right\} = \xyvec{ayz + bz +c}{xyz}
\]
With this we can realize Horner's rule as
\[
 h\left( \xyvec {c_0}x,\xyvec {c_1}x,&hellip;,\xyvec {c_n}x \right) 
\]
</p>

<p name="switchToTextMode">
As an aside, this particular form of the `horner operator'
corresponds to the `rho' operator in the programming language&nbsp;
<i>APL</i>
,
which is normally phrased as evaluation in a number system
with varying radix.
</div>
<a href="index.html">Back to Table of Contents</a>
