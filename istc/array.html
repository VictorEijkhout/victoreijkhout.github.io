<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>Arrays</h1>
        <h5>Experimental html version of downloadable textbook, see https://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>

\[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% mathjax.tex : macros to facility mathjax use in html version
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\newcommand\macro[1]{$\langle$#1$\rangle$}
\newcommand\dtdxx{\frac{\alpha\Delta t}{\Delta x^2}}
\]


32.1 : <a href="array.html#Carrays">C arrays</a><br>
32.1.1 : <a href="array.html#Staticarrays">Static arrays</a><br>
32.1.1.1 : <a href="array.html#Allocation">Allocation</a><br>
32.1.1.2 : <a href="array.html#Passingtofunctions">Passing to functions</a><br>
32.1.2 : <a href="array.html#Multi-dimensionalarrays">Multi-dimensional arrays</a><br>
32.1.3 : <a href="array.html#Variable-lengtharrays">Variable-length arrays</a><br>
32.1.4 : <a href="array.html#Dynamicallyallocatedarrays">Dynamically allocated arrays</a><br>
32.1.5 : <a href="array.html#Dynamicarrays,scope,memoryleaks">Dynamic arrays, scope, memory leaks</a><br>
32.1.6 : <a href="array.html#Multi-dimensionaldynamicarrays">Multi-dimensional dynamic arrays</a><br>
32.1.7 : <a href="array.html#Typetheoryofarrays">Type theory of arrays</a><br>
32.2 : <a href="array.html#C++arrays">C++ arrays</a><br>
32.2.1 : <a href="array.html#Array">Array</a><br>
32.2.2 : <a href="array.html#Vector">Vector</a><br>
32.3 : <a href="array.html#Fortran">Fortran</a><br>
32.3.1 : <a href="array.html#Static">Static</a><br>
32.3.2 : <a href="array.html#Dynamic">Dynamic</a><br>
32.3.3 : <a href="array.html#Memorylayout">Memory layout</a><br>
32.4 : <a href="array.html#Layoutinmemory">Layout in memory</a><br>
32.4.1 : <a href="array.html#Arrayalignment">Array alignment</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>32 Arrays</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Carrays">32.1</a> C arrays</h2>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a>
</p>
</p>

<h3><a id="Staticarrays">32.1.1</a> Static arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Staticarrays">Static arrays</a>
</p>

<p name="switchToTextMode">

The easiest way to create arrays is with the `square bracket notation':
<!-- environment: lstlisting start embedded generator -->
</p>
int x[5];
int y[6][7];
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

The same square brackets are used for indexing:
<!-- environment: lstlisting start embedded generator -->
</p>
for (int row=0; row&lt;nrows; row++)
  for (int col=0; col&lt;ncols; col++)
    moments[row][col] = pow( coefficient[row],(double)col );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

In these examples we used a constant for the array bound.
See section&nbsp;
32.1.3
 for using a variable.
</p>

<h4><a id="Allocation">32.1.1.1</a> Allocation</h4>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Staticarrays">Static arrays</a> > <a href="array.html#Allocation">Allocation</a>
</p>
<p name="switchToTextMode">

What we are calling `static' arrays are actually technically called
<i>automatic array</i>
s.
Static arrays are arrays with the keyword 
<tt>static</tt>
:
<!-- environment: lstlisting start embedded generator -->
</p>
static float x[5]; // a truly `static' array
int main() {
  float y[6]; // this one is `automatic'
}
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Automatic arrays, which we will from now on call `static',
are usually allocated on the
<i>stack</i>
<!-- index -->
,
because they have static scope:
<!-- environment: lstlisting start embedded generator -->
</p>
// variables `x' and `y' don't exist
if (whatever) {
  int x;
  float y[2];
  // variables `x' and `y' exist for the duration of the conditional
  ....
}
// variables `x' and `y' don't exist anymore
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Thus, creating too many of these may lead to 
<i>stack overflow</i>
.
Check out the 
<tt>limit</tt>
 command.
</p>

<h4><a id="Passingtofunctions">32.1.1.2</a> Passing to functions</h4>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Staticarrays">Static arrays</a> > <a href="array.html#Passingtofunctions">Passing to functions</a>
</p>
<p name="switchToTextMode">

You can pass an array to a function,
indicating in the function prototype that it is an array.
However, the function can not query the array length,
so that has to be passed separately if this information is needed.
</p>

<p name="switchToTextMode">
\snippetwithoutput{cansiset1d}{array}{set1d}
</p>

<p name="switchToTextMode">
You can also use the equivalence of arrays and pointers:
</p>

<p name="switchToTextMode">
\snippetwithoutput{cansisetstar}{array}{setstar}
</p>

<h3><a id="Multi-dimensionalarrays">32.1.2</a> Multi-dimensional arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Multi-dimensionalarrays">Multi-dimensional arrays</a>
</p>
<p name="switchToTextMode">

Declaring a multi-dimensional array:
<!-- environment: lstlisting start embedded generator -->
</p>
int y[6][7];
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Initialization:
<!-- environment: lstlisting start embedded generator -->
</p>
int z[2][2] = { {1,2},{3,4} };
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Such arrays are stored in 
<i>row-major</i>
 ordering,
meaning that rows are contiguous in memory.
</p>

<p name="switchToTextMode">
\snippetwithoutput{cansiset2d}{array}{set2d}
</p>

<p name="switchToTextMode">
Passing them to functions is a little more tricky:
all dimensions except the first have to be pass explicitly.
</p>

<p name="switchToTextMode">
\snippetwithoutput{cansiset2d}{array}{pass2d}
</p>

<h3><a id="Variable-lengtharrays">32.1.3</a> Variable-length arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Variable-lengtharrays">Variable-length arrays</a>
</p>

<p name="switchToTextMode">

In 
<i>Ansi C</i>
, arrays had to be declared with compile-time bounds,
as above.
The 
<i>C99</i>

<!-- index -->
 standard has added 
<i>variable-length array</i>
s:
</p>

<p name="switchToTextMode">
\snippetwithoutput{c99array}{array}{set99}
</p>

<!-- environment: itemize start embedded generator -->
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
These arrays are still `automatic' so they only live in the
  scope where they are defined.
<li>
The term `variable-length' does not mean that the length
  is variable; only that it is specified with a variable.
  Resizable arrays only exist in&nbsp;C++; see section&nbsp;
32.2.2
.)
<li>
  Such declarations can also be done in multi-D.
  However, they are pointless for passing arrays to functions.
<li>
  Note: this mechanism was already available as an extension
  on many compilers before the C99 standard.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Dynamicallyallocatedarrays">32.1.4</a> Dynamically allocated arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Dynamicallyallocatedarrays">Dynamically allocated arrays</a>
</p>
</p>

<p name="switchToTextMode">
Before C99's variable-length arrays,
the only way to create arrays with a size determined at run-time
was through 
<i>dynamic allocation</i>
,
using the 
<tt>malloc</tt>
 keyword. This
<!-- environment: enumerate start embedded generator -->
</p>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
takes an argument that is a number of bytes, and
<li>
returns the address of a block of memory of that size.
<li>
It returns zero if the block could not be created.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<!-- environment: lstlisting start embedded generator -->
int arraysize = 500;
float *x;
x = (float*) malloc( arraysize*sizeof(float) );
if (!x) printf("Could not allocate x\n");
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Indexing, both in the scope where the array is created,
and in subprograms it is passed to,
is exactly the same as above.
For passing such arrays to functions, the type is now  <tt>float*</tt> :
\snippetwithoutput{cmallocpass}{array}{cmalloc}
</p>

<h3><a id="Dynamicarrays,scope,memoryleaks">32.1.5</a> Dynamic arrays, scope, memory leaks</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Dynamicarrays,scope,memoryleaks">Dynamic arrays, scope, memory leaks</a>
</p>
<p name="switchToTextMode">

The memory allocated for dynamic arrays is not subject to scope:
<!-- environment: lstlisting start embedded generator -->
</p>
void create( float **x,int len ) {
  float *x_space = (float*) malloc(len*sizeof(float));
  *x = s_space;
}
int main() {
  float *x;
  create(&x,50);
}
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Thus, this allocation has to happen on the
<i>heap</i>
<!-- index -->
This is good for flexible programming, but
may lead to 
<i>memory leak</i>
s.
</p>

<h3><a id="Multi-dimensionaldynamicarrays">32.1.6</a> Multi-dimensional dynamic arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Multi-dimensionaldynamicarrays">Multi-dimensional dynamic arrays</a>
</p>
<p name="switchToTextMode">

Solution 1:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#cmallocsizenn" aria-expanded="false" aria-controls="cmallocsizenn">
        C Code: cmallocsizenn
      </button>
    </h5>
  </div>
  <div id="cmallocsizenn" class="collapse">
  <pre>
// cmalloc2d.c
  int (*numbers)[cols] = malloc( sizeof(int[rows][cols]) );
</pre>
</div>
</div>
</p>

<p name="switchToTextMode">
This allocates a single block,
consisting of arrays of length&nbsp;
<tt>cols</tt>
:
\snippetwithoutput{cmallocsizenn3}{array}{rowlength}
</p>

<p name="switchToTextMode">
Solution 2:\\
create a one-dimensional array,
and convert multi-dimensional indices to one-dimensional.
</p>

<p name="switchToTextMode">
\snippetwithoutput{cmalloc2d}{array}{cmallocpass}
</p>

<h3><a id="Typetheoryofarrays">32.1.7</a> Type theory of arrays</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Carrays">C arrays</a> > <a href="array.html#Typetheoryofarrays">Type theory of arrays</a>
</p>
<p name="switchToTextMode">

After declaring
<!-- environment: lstlisting start embedded generator -->
</p>
int x[5][6];
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
the expression 
<tt>x[3]</tt>
 stands for an array of length&nbsp;6,
compatible with being an  <tt>int*</tt> .
</p>

Does that mean that \lstinline{x} itself is of type  <tt>int**</tt> ?
<p name="switchToTextMode">
No, it is not.
Careful parsing of the standard shows that 
<tt>x</tt>
 itself
is also of type  <tt>int*</tt> !
Above you already saw that multi-dimensional arrays are contiguous in memory,
so you can step through their content with pointer arithmetic.
</p>

Let's explore the notion of  <tt>int**</tt>  and arrays a little more.
<p name="switchToTextMode">
You can in fact write:
<!-- environment: lstlisting start embedded generator -->
</p>
int **x;
x = (int**)malloc( nrows*sizeof(int*) );
for (int irow=0; irow&lt;nrows; irow++)
  x[irow] = (int*)malloc( ncolumns*sizeof(int) );
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
and the resulting object can also be indexed with&nbsp; <tt>x[i][j]</tt> .
<p name="switchToTextMode">
However, this has significant disadvantages:
<!-- environment: enumerate start embedded generator -->
</p>
<!-- TranslatingLineGenerator enumerate ['enumerate'] -->
<li>
The `array' is no longer contiguous, so you can not easily step through the contents.
<li>
Copying its contents is harder than copying contiguous data.
<li>
The performance of operations may suffer because of the lack of locality and regularity.
</ol>
</enumerate>
<!-- environment: enumerate end embedded generator -->
<p name="switchToTextMode">

<h2><a id="C++arrays">32.2</a> C++ arrays</h2>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#C++arrays">C++ arrays</a>
</p>
</p>

<p name="switchToTextMode">
The C arrays described above are available in C++,
with exception of variable-length arrays.
However, better mechanisms exist.
</p>

<h3><a id="Array">32.2.1</a> Array</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#C++arrays">C++ arrays</a> > <a href="array.html#Array">Array</a>
</p>
<p name="switchToTextMode">

</p>

The C++  <tt>std::array</tt>  is close to the C `static arrays'
<p name="switchToTextMode">
(section&nbsp;
32.1.1
)
in that it requires bounds that are known at compile time.
<!-- environment: lstlisting start embedded generator -->
</p>
std::array&lt;float,8&gt; eight_floats;
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
Note that the size is a template parameter, not a parameter of the constructor.
</p>

<p name="switchToTextMode">
While the compile-time bound is a severe restriction on flexibility,
this is the most efficient array variant in C++:
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
There is no storage overhead in addition to the element storage;
<li>
Nested arrays of this type are form contiguous memory;
<li>
The compiler can optimize these arrays as much as the C-style static arrays.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
However, storage for these arrays happens on the heap,
rather than on the stack as for C static arrays.
</p>

<p name="switchToTextMode">
The convenience of having methods such as 
<tt>size</tt>

and bound checking through 
<tt>at</tt>

makes these arrays preferable over the C variant.
</p>

<h3><a id="Vector">32.2.2</a> Vector</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#C++arrays">C++ arrays</a> > <a href="array.html#Vector">Vector</a>
</p>

<p name="switchToTextMode">

The  <tt>std::vector</tt>  also creates space on the heap.
By contrast with  <tt>std::array</tt> 
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
the size can be specified as a dynamically determined quantity; and
<li>
the size can be changed.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
This first difference means that the vector now needs a control block that
contains the size and the allocated capacity.
The second difference implies that certain operations can be
computationally inefficient.
</p>

<h2><a id="Fortran">32.3</a> Fortran</h2>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Fortran">Fortran</a>
</p>
<p name="switchToTextMode">

<h3><a id="Static">32.3.1</a> Static</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Fortran">Fortran</a> > <a href="array.html#Static">Static</a>
</p>
</p>

<p name="switchToTextMode">

Arrays can be created with compile-time bounds:
<!-- environment: lstlisting start embedded generator -->
</p>
Integer,dimension(5) :: x
Integer,parameter :: size = 6
Integer,dimension(size,size) :: y
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

These arrays are scoped.
</p>

<p name="switchToTextMode">
Unlike in C, Fortran arrays can have a specified lower bound:
<!-- environment: lstlisting start embedded generator -->
</p>
Integer,dimension(-1:7) :: x
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

<h3><a id="Dynamic">32.3.2</a> Dynamic</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Fortran">Fortran</a> > <a href="array.html#Dynamic">Dynamic</a>
</p>
</p>

<!-- environment: lstlisting start embedded generator -->
Real*4,dimension(:),allocatable :: x
Integer :: n


Read *,n
Allocate(x(n))
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">

Such arrays are also scoped,
and can therefore not lead to memory leaks,
unlike 
<tt>malloc</tt>
'ed arrays in&nbsp;C.
</p>

<h3><a id="Memorylayout">32.3.3</a> Memory layout</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Fortran">Fortran</a> > <a href="array.html#Memorylayout">Memory layout</a>
</p>
<p name="switchToTextMode">

Fortran arrays are column-major:
the columns are stored contiguously.
For higher dimensions this is also phrased as
`the first index varies quickest'.
</p>

<h2><a id="Layoutinmemory">32.4</a> Layout in memory</h2>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Layoutinmemory">Layout in memory</a>
</p>

<!-- index -->
<!-- index -->
<p name="switchToTextMode">

C and Fortran have different conventions for storing multi-dimensional
arrays. You need to be aware of this when you pass an array between
routines written in different languages.
</p>

<p name="switchToTextMode">
Fortran stores multi-dimensional arrays in 
<i>column-major</i>
order; see figure&nbsp;
32.1
.
For two dimensional arrays 
<tt>A(i,j)</tt>
 this means that
the elements in each column are stored contiguously: a $2\times2$
array is stored as 
<tt>A(1,1), A(2,1), A(1,2), A(2,2)</tt>
. Three and
<!-- environment: figure start embedded generator -->
</p>
<!-- TranslatingLineGenerator figure ['figure'] -->
<img src="graphics/cf-arrays.jpeg" width=800></img>
<p name="caption">
FIGURE 32.1: Fortran and C array storage by columns and rows respectively
</p>

</float>
</figure>
<!-- environment: figure end embedded generator -->
<p name="switchToTextMode">
higher dimensional arrays are an obvious extension: it is sometimes
said that `the left index varies quickest'.
</p>

<p name="switchToTextMode">
C arrays are stored in 
<i>row-major</i>
 order: elements in each
row are stored contiguous, and columns are then placed sequentially in
memory. A&nbsp;$2\times2$ array 
<tt>A[2][2]</tt>
 is stored as

<tt>A[1][1], A[1][2], A[2][1], A[2][2]</tt>
.
</p>

<p name="switchToTextMode">
A number of remarks about arrays in&nbsp;C.
<!-- environment: itemize start embedded generator -->
</p>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
C (before the C99 standard) has multi-dimensional arrays only in
  a limited sense. You can declare them, but if you pass them to another
  C function, they no longer look multi-dimensional: they have become
  plain 
<tt>float*</tt>
 (or whatever type) arrays. That brings us to
  the next point.
<li>
Multi-dimensional arrays in C look as if they have type
  
<tt>float**</tt>
, that is, an array of pointers that point to
  (separately allocated) arrays for the rows. While you could
  certainly implement this:
<!-- environment: verbatim start embedded generator -->
</p>
float **A;
A = (float**)malloc(m*sizeof(float*));
for (i=0; i&lt;n; i++)
  A[i] = (float*)malloc(n*sizeof(float));
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
  careful reading of the standard reveals that a multi-dimensional
  array is in fact a single block of memory, no further pointers
  involved.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
Given the above limitation on passing multi-dimensional arrays, and
the fact that a C&nbsp;routine can not tell whether it's called from
Fortran or&nbsp;C, it is best not to bother with multi-dimensional arrays
in C, and to emulate them:
<!-- environment: verbatim start embedded generator -->
</p>
float *A;
A = (float*)malloc(m*n*sizeof(float));
#define SUB(i,j,m,n) i+j*m
for (i=0; i&lt;m; i++)
  for (j=0; j&lt;n; j++)
    .... A[SUB(i,j,m,n)] ....
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">
where for interoperability we store the elements in column-major fashion.
</p>

<!-- index -->
<!-- index -->
<p name="switchToTextMode">

<h3><a id="Arrayalignment">32.4.1</a> Array alignment</h3>
<p name=crumbs>
crumb trail:  > <a href="array.html">array</a> > <a href="array.html#Layoutinmemory">Layout in memory</a> > <a href="array.html#Arrayalignment">Array alignment</a>
</p>
<!-- index -->
</p>

<p name="switchToTextMode">
For reasons such as 
<span title="acronym" ><i>SIMD</i></span>
<i>vector instructions</i>
, it can
be advantageous to use 
<i>aligned allocation</i>
. For
instance, `16-byte alignment' means that the starting address of your
array, expressed in bytes, is a multiple of&nbsp;16.
</p>

<p name="switchToTextMode">
In&nbsp;C, you can force such alignment with
<tt>posix\_memalign</tt>
. In Fortran there is no general
mechanism for this. The Intel compiler allows you to write:
<!-- environment: verbatim start embedded generator -->
</p>
double precision, allocatable :: A(:), B(:)
!DIR$ ATTRIBUTES ALIGN : 32 :: A, B
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

</p>

</div>
<a href="index.html">Back to Table of Contents</a>
